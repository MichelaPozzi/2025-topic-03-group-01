
**************************************************************************************************************
0. Load Dataset and Inspect Row/Column Names
**************************************************************************************************************

```{r}
#Reads table, by indicating path to directory where the dataset is stored, and stores it to variable NS_Table (NS for Non-synchronizied HeLa-cells)

NS_Table <- read.table("Daten/Data, copy but dont open.csv", header=TRUE, row.names=1, sep = ";")
```

```{r}
#The first 12 titles of the table (NS_Table) rows/colums are read out

#Row names are protein names
head(rownames(NS_Table),12)

#Columns indicate the respective fractions from 1 to 25, and their replicated
head(colnames(NS_Table),12)
```

**************************************************************************************************************
1. Data Cleanup
1.1. Rearrange and reorder the columns to their fraction and treatment
**************************************************************************************************************

Define sample metadata vectors (Treatment, Replicates, Fractions)
Creates 3 vectors that describe the characteristics of the columns (i.e., samples) in the data set:
  levels_CR → indicates whether the sample was treated with RNASE or as a CTRL
  levels_fraction → labels the column with the replicate number (1–3) for either CTRL or RNASE
  fraction_names → creates the variables fraction1 to fraction25 to assign the replicates to each fraction

```{r}
#A vector consists of 2 variables (CTRL, RNASE) --> c("CTRL", "RNASE")
#The factor() function encodes a vector as a factor. The 2 variables CTRL and RNASE are ordered into 2 different levels (characters)
#rep(vector,75) repeats the factor() function 75 times, because we have 150 columns (75 times CTRL and RNASE)
#The factor is defined as the variable 'treatment'

levels_CR <- factor(rep(c("CTRL", "RNASE"),75))
```

```{r}
#Every sample of every fraction gets its own level to disconnect them from each other -> 6 levels per fraction because we have 3 CTRLs and 3 RNASEs per fraction

levels_fraction <- factor(rep(c("Ctrl_Rep1","RNase_Rep1","Ctrl_Rep2","RNase_Rep2","Ctrl_Rep3","RNase_Rep3"),25))
```

```{r}
# Creation of a matrix with 6 rows and 25 columns. The matrix is filled by row from fraction1 to fraction25 so every column has one single fraction.
# sep="" compares the word fraction with the numbers 1 to 25 without a blank space.
# paste("fraction",1:25,sep="") creates a vector with the strings fraction1 to fraction25
# as.vector changes the created matrix into a vector with 150 elements sorted from 6 times fraction1 to 6 times fraction25

fraction_names <- as.vector(matrix(rep(paste("fraction",1:25,sep=""),6), nrow = 6, ncol=25, byrow = TRUE))
```

Create Metadata Data Frame and Check for Missing Values

```{r}
# The number of rows are stored in a variable
n_row <- nrow(NS_Table)

# The row names (protein names) are stored in a variable
row_names <- rownames(NS_Table)
```

```{r}
# Creation of a data frame with levels_CR, levels_fraction and fraction_names. This assigns every replicate of the factions (levels_fraction) to their fraction (fraction_names) and their kind of treatment, CRTL or RNASE (levels_CR).

colmns_sorted <- data.frame(row.names = colnames(NS_Table), levels_CR = levels_CR, levels_fraction = levels_fraction, fraction_names = fraction_names)

#Check for missing values, there are none 
anyNA(NS_Table)
```
******************************************************************************************************************
1.2 Normalization step between the replicates in each fraction and for each treatment using the mean value method
******************************************************************************************************************

Split Data by Fractions and Treatment (CTRL vs RNASE)

```{r}
# lapply executes for every with paste created string (the fractions) a function fx
# colmns_sorted$fraction == fx: checks which columns are part of the fractions fx
# NS_Table[, ...] filters just these columns and assigns them to the list "fraction.tables"
# names(fraction.tables): the list "fraction.tables" gets names for its segments and assigns them to the variable selected_proteins 

fraction.tables <- lapply(paste("fraction", 1:25, sep = ""), function(fx) {NS_Table[, colmns_sorted$fraction_names == fx]})

names(fraction.tables) <- paste("fraction", 1:25, sep = "")

selected_proteins <- names(fraction.tables)
```

```{r}
# List with just CTRL/RNASE columns for each fraction
# subset filters just the fractions that fulfill the conditions: fraction_names == fx --> fraction name is part of the function fx, levels_CR == "CTRL" --> protein was treated as a CTRL
# rownames() takes the rownames of the filtered fractions and assigns them to the variable col
# NS_Table[, cols, drop = FALSE] the names that are part of NS_Table are filtered out and drop = FALSE makes sure that fraction.tables.CTRL will be a dataframe

# Liste mit nur CTRL-Spalten für jede Fraktion
fraction.tables.CTRL <- lapply(selected_proteins, function(fx) {
  cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "CTRL")) 
  NS_Table[, cols, drop = FALSE]
  })

# Liste mit nur RNASE-Spalten für jede Fraktion
fraction.tables.RNASE <- lapply(selected_proteins, function(fx) {
  cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "RNASE"))
  NS_Table[, cols, drop = FALSE]})

names(fraction.tables.CTRL) <- selected_proteins
names(fraction.tables.RNASE) <- selected_proteins
```

Calculate Mean Protein Intensities per Fraction and Treatment

```{r}
# sapply(df, mean) calculates the mean of every column of the dataframe fraction.tables.CTRL
# Für jede Bedingung (z.B fraction 1, Ctrl, Rep 1) wird der Mittelwert über die Proteine gebildet, dies ist pro Bedingung dann ein einziger Wert

avg.tables.CTRL <- lapply(fraction.tables.CTRL, function(df) {
  sapply(df, mean)
})

avg.tables.RNASE <- lapply(fraction.tables.RNASE, function(df) {
  sapply(df, mean)
})
```
Calculate Normalization Factors Based on Most Similar Replicates

```{r}
# Determine normalization factor for each condition (i.e. sample), as the mean of the 2 most similar replicates.
# Create a function norm_fact for this step:

norm_fact <- function(x) {
				if( (abs(x[1]-x[2])<abs(x[1]-x[3])) && (abs(x[1]-x[2])<abs(x[2]-x[3])) ) 
					{mean(c(x[1],x[2]))} else if( (abs(x[1]-x[3])<abs(x[1]-x[2])) && (abs(x[1]-x[3])<abs(x[2]-x[3])) )
												  {mean(c(x[1],x[3]))} else {mean(c(x[2],x[3]))} 
}
```


Normalize Mean Intensities for Each Fraction and Treatment

```{r}
# Normalisierung der Mean value Vektoren
# norm_factor <- norm_fact(vec): Auf jeden Vektor in der Liste avg.tables.CTRL (diese sind von der Länge 3) wird die Funktion norm_fact angewendet
# norm_factor / vec: ergibt einen neuen Vektor der Länge 3, der einen Korrekturfaktor für die einzelnen Replikate darstellt, um die Proteinmengen der Replikate aneinander anzugleichen

norm_mean_frxn_CTRL <- lapply(avg.tables.CTRL, function(vec) {
  norm_factor <- norm_fact(vec)
  norm_factor / vec 
})

norm_mean_frxn_RNASE <- lapply(avg.tables.RNASE, function(vec) {
  norm_factor <- norm_fact(vec)
  norm_factor / vec 
})
```


Extract Normalization Factors for Each Replicate and Treatment

```{r}
# Correction factor for the overall protein quantity
# Normalization vectors for replicates 1-3
# function(x) x[1]: extracts the first element of each vector in the list
# norm.ctrl1 is a numeric vector consisting of the 1st element of each normalized CTRL vector

norm.ctrl1 <- sapply(norm_mean_frxn_CTRL, function(x) x[1])
norm.ctrl2 <- sapply(norm_mean_frxn_CTRL, function(x) x[2])
norm.ctrl3 <- sapply(norm_mean_frxn_CTRL, function(x) x[3])

norm.rnase1 <- sapply(norm_mean_frxn_RNASE, function(x) x[1])
norm.rnase2 <- sapply(norm_mean_frxn_RNASE, function(x) x[2])
norm.rnase3 <- sapply(norm_mean_frxn_RNASE, function(x) x[3])
```

```{r}
# Defines logical vectors (TRUE, FALSE), which are later used to create subtables - separately for treatment (Ctrl vs. RNase) and replica (Rep1, Rep2, Rep3)
# colmns_sorted$levels_fraction =="Ctrl_Rep1": checks at which position exactly in the columns_sorted Ctrl_Rep1 can be found (marks it with TRUE)

data.ctrl1 <- colmns_sorted$levels_fraction =="Ctrl_Rep1"
data.ctrl2 <- colmns_sorted$levels_fraction =="Ctrl_Rep2"
data.ctrl3 <- colmns_sorted$levels_fraction =="Ctrl_Rep3"
data.rnase1 <- colmns_sorted$levels_fraction =="RNase_Rep1"
data.rnase2 <- colmns_sorted$levels_fraction =="RNase_Rep2"
data.rnase3 <- colmns_sorted$levels_fraction =="RNase_Rep3"
```

Normalize Protein Intensity Data

```{r}
# Normalization step, fraction-wise
# takes specific columns from the protein intensity table and scales each row according to a normalization factor to compensate for measurement differences between replicates
# mask: A logical vector (TRUE/FALSE) that specifies which columns of NS_Table are selected
# selected <- NS_Table[, mask]: from NS_Table only the columns marked with TRUE in mask are selected
# (`*`, selected, norm_vec, SIMPLIFY = FALSE): Multiplication of colums of selected and the vector norm_vec saved as a list

normalize_group <- function(mask, norm_vec) {
  selected <- NS_Table[, mask]                  
  as.data.frame(mapply(`*`, selected, norm_vec, SIMPLIFY = FALSE))
}

# logical vectors (data.ctrl1) and vectors with normalization-factors (norm.ctrl1) form groups
# normalize_group(): multiplication of the vectors with their normalization-factor

table.ctrl1  <- normalize_group(data.ctrl1,  norm.ctrl1)
table.ctrl2  <- normalize_group(data.ctrl2,  norm.ctrl2)
table.ctrl3  <- normalize_group(data.ctrl3,  norm.ctrl3)
table.rnase1 <- normalize_group(data.rnase1, norm.rnase1)
table.rnase2 <- normalize_group(data.rnase2, norm.rnase2)
table.rnase3 <- normalize_group(data.rnase3, norm.rnase3)
```

```{r}
# Get the proper rownames for the tables

rownames(table.ctrl1) <- row_names
rownames(table.ctrl2) <- row_names
rownames(table.ctrl3) <- row_names
rownames(table.rnase1) <- row_names
rownames(table.rnase2) <- row_names
rownames(table.rnase3) <- row_names
```

Smooth Data with Sliding Window (Moving Average of 3 Fractions)

```{r}
# Apply a sliding window/moving average of 3 points to the data to reduce noise in the data and obtain smoother curves (not possible for fraction 1 and 25)

smooth_table <- function(tbl) {
  data.frame(tbl[1], (tbl[1:23] + tbl[2:24] + tbl[3:25]) / 3, tbl[25])
}

table.ctrl1.SW <- smooth_table(table.ctrl1)
table.ctrl2.SW <- smooth_table(table.ctrl2)
table.ctrl3.SW <- smooth_table(table.ctrl3)
table.rnase1.SW <- smooth_table(table.rnase1)
table.rnase2.SW <- smooth_table(table.rnase2)
table.rnase3.SW <- smooth_table(table.rnase3)
```

```{r}
# Get the proper rownames for the tables

colnames(table.ctrl1.SW) <- colnames(table.ctrl1)
colnames(table.ctrl2.SW) <- colnames(table.ctrl2)
colnames(table.ctrl3.SW) <- colnames(table.ctrl3)
colnames(table.rnase1.SW) <- colnames(table.rnase1)
colnames(table.rnase2.SW) <- colnames(table.rnase2)
colnames(table.rnase3.SW) <- colnames(table.rnase3)
```

Normalize Fraction Intensities to Percentages (Sum to 100%)

```{r}
# Normalization of the fractions: Sum of all fraction values equals 100 (%)

normalize_table <- function(tbl) {
  tbl * 100 / rowSums(tbl)
}


tables.ctrl <- list(
  ctrl1 = table.ctrl1.SW,
  ctrl2 = table.ctrl2.SW,
  ctrl3 = table.ctrl3.SW)

tables.rnase <- list(
  rnase1 = table.rnase1.SW,
  rnase2 = table.rnase2.SW,
  rnase3 = table.rnase3.SW)

# Calculation of the percentages of the fractions in the normalized tables (table.ctrl1.SW)

norm_tables.ctrl <- lapply(tables.ctrl, normalize_table)
norm_tables.rnase <- lapply(tables.rnase, normalize_table)
```

Replace NA and NaN Values with 0

```{r}
# Function for replacing NA and NaN with 0

clean_table <- function(tbl) {
  tbl <- rapply(tbl, function(x) ifelse(is.na(x), 0, x), how = "replace")
  tbl <- rapply(tbl, function(x) ifelse(is.nan(x), 0, x), how = "replace")
  return(tbl)
}

# Getting the clean table

tables.norm.ctrl <- lapply(norm_tables.ctrl, clean_table)
tables.norm.rnase <- lapply(norm_tables.rnase, clean_table)
```

Calculate Mean Across Replicates

```{r}
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)

# Addition of all data-frames in the list my.list.ctrl.norm (element-wise) and Division of the Sum with 3 to get the mean of all 3 replicates

ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
```

```{r}
# Change names of the columns: from "fraction1" to "fraction25"

col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
```

```{r}
# second normalization of the fractions (mean destroyed first normalization): Sum of all fraction values equals 100 (%)

ctrl_norm_mean <- ctrl_norm_mean*100/rowSums(ctrl_norm_mean)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)

```

Filter Proteins with Zero Values Across All Fractions

```{r}
# Function for replacing NA and NaN with 0

replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")

ctrl_norm_mean <- replace_na_nan(ctrl_norm_mean)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
```

```{r}
# If a curve is 0 in all fractions, the other fraction is also set to 0 and is excluded from the analysis

ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
```

Plot Example Protein Fractionation Profiles

```{r}
row_data1 <- as.numeric(ctrl_norm_mean["PRKDC_HUMAN", ])
row_data2 <- as.numeric(rnase_norm_mean["PRKDC_HUMAN", ])

# Plot
plot(row_data2,
     type = "l",        
     main = "Plot for PRKDC_HUMAN",
     xlab = "Fractions",
     ylab = "Values",
     col = "blue",
     lwd = 2)

lines(row_data1,
      type = "l",
      col = "red",
      lwd = 2)
```

**************************************************************************************************************
2. Find local maxima greater than 2 as fit parameters from average curves
2.1 Identify local maxima
**************************************************************************************************************

Identify local maxima by peak calling for the mean of each protein.
In order to get rid of the noise, only values above 2 are considered.
Find shoulders that were not discovered previously.

```{r}
ctrl_norm_mean_original = ctrl_norm_mean
rnase_norm_mean_original = rnase_norm_mean
```

Define Peak Finding Function

```{r}
# Function find_local_maxima
# Peak is local maximum with a certain amount (window) of smaller points on each side
# Bigger window => more stringent peak finding procedure 

find_local_maxima <- function(x, window = 2) {
  slope_changes <- diff(sign(diff(x)))
  peak_indices <- which(slope_changes < 0)

  peaks <- c()

  for (i in peak_indices) {
    left <- max(1, i - window + 1)
    right <- min(length(x), i + window + 1)

    neighbors <- c(x[left:i], x[(i + 2):right])

    if (all(neighbors <= x[i + 1])) {
      peaks <- c(peaks, i + 1)
    }
  }
  
# part added to deal with the 1st and 25th values, in case they are max
     if ( sum(x[1]>x[2:(window+1)]) == 2 ) {peaks <- c(peaks, 1)} 
     if ( sum(x[25]>x[24:(25-window)]) == 2 ) {peaks <- c(peaks, 25)}
     peaks <- unlist(peaks)
     peaks
     
#return(peaks)
     
} 
```

```{r}
# Apply the function to the data set and retrieve the values
# restriction to values above an absolut threshold of 2%
# New column: "local_maxima" (column 26)

ctrl_norm_mean$local_maxima <- apply(ctrl_norm_mean, 1, function(x) {
															   peak_indeces <- find_local_maxima(x)
															   filtered <- peak_indeces[x[peak_indeces] > 2] 
															   local_maxima <- unlist(filtered)
															   local_maxima
															   })
															   
rnase_norm_mean$local_maxima <- apply(rnase_norm_mean, 1, function(x) {
															   peak_indeces <- find_local_maxima(x)
															   filtered <- peak_indeces[x[peak_indeces] > 2] 
															   local_maxima <- unlist(filtered)
															   local_maxima
															   })
```

```{r}
# Out of the local maxima, extract the global (greatest) maximum, and save it in a new column "global_maximum" (column 27)

ctrl_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
  x <- as.numeric(ctrl_norm_mean[i, 1:25])
  peaks <- ctrl_norm_mean$local_maxima[[i]]

  if (length(peaks) == 0) {
    return(NA)
  } else {
    peak_values <- x[peaks]
    return(peaks[which.max(peak_values)])
  }
})


rnase_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
  x <- as.numeric(rnase_norm_mean[i, 1:25])
  peaks <- rnase_norm_mean$local_maxima[[i]]

  if (length(peaks) == 0) {
    return(NA)
  } else {
    peak_values <- x[peaks]
    return(peaks[which.max(peak_values)])
  }
})


```


****************************************************************************************************************
2.2 Identify shoulders, regions that are not recognized as peaks, even though they have a high signal intensity.
****************************************************************************************************************

Create Binary Data Frames Indicating Signal > 2%

```{r}
# Identify the RNAse fractions with signal intensity > 2%. 
# Create a new data frame containing 0 (= this fraction value was ≤2% ) and 1 (= this fraction value was >2%.), as well as the intensity maxima.
# The two new data frames are created, rnase_3 and ctrl_3, as copies of the previously calculated, normalized mean tables (*_norm_mean).

rnase_3 <- rnase_norm_mean
# Compare each value in columns 1 to 25 (the fractions) of the rnase_norm_mean dataframe with the threshold of 2%.
# Convert TRUE to 1 and FALSE to 0. 
rnase_3[1:25] <- (rnase_norm_mean[1:25] > 2)*1

# Identify the CTRL fractions with signal intensity > 2%. 
# Create a new data frames containing 0 / 1, as well as the intensity maxima.
ctrl_3 <- ctrl_norm_mean
ctrl_3[1:25] <- (ctrl_norm_mean[1:25] > 2)*1
```

Mask Regions Around Detected Peaks to Exclude Them from Shoulder Search

```{r}
# Remove and exclude 3 fractions left and right of each peak (7 in total) from the shoulder search.

th_max_reg_simple <- function(x) {
  peaks <- as.numeric(unlist(x$local_maxima)) # Convert the local_maxima column from ctrl/rnase_norm_mean to a numeric vector.
  mask <- rep(1, 25)
  
  for (peak in peaks) { # peak = current peak value, peaks = detected maxima (column 26)
    if (peak > 0) { 
      left <- max(1, peak - 3)
      right <- min(25, peak + 3) # For each peak, the range from peak–3 to peak+3 is calculated.
      mask[left:right] <- 0 # These 7 fractions (the peak itself and 3 before & after it) are masked out by setting their positions in the mask to 0.
    }
  }

  x_values <- as.numeric(x[1:25]) # because $maxima contained characters. 
  x_values <- x_values * mask # Fractions with mask = 1 are retained. Fractions with mask = 0 are set to 0.
  return(x_values)
}

# Apply the function row by row to the entire rnase_3 or ctrl_3 DataFrame.
rnase_3[1:25] <- t(apply(rnase_3, 1, th_max_reg_simple))
ctrl_3[1:25]  <- t(apply(ctrl_3, 1, th_max_reg_simple))
```

Identify Shoulder Regions: Consecutive Fractions > 2% Without Peaks

```{r}
# Detect "shoulder regions"
# Define a function that identifies signal regions where there are at least 4 consecutive fractions with an intensity above 2% using the data frames rnase_3 and ctrl_3.

# select the middle of it
# Apply on the whole dataframe

peaks_regions = function(x) {
  rle_result = rle(as.numeric(x[1:25])) # rle() finds all consecutive equal values -> $lengths and $values
  
  #Find positions of all blocks of ones with length ≥4. These blocks are considered “shoulder regions”.
  peak_blocks = which(rle_result$values == 1 & rle_result$lengths >= 4)
  
  #If there are no such blocks of length >4, return an empty vector
  if (length(peak_blocks) == 0) {
    return(numeric(0))
  }
  
  #Calculate estimate middle for the peak blocks
  peak_positions = numeric(length(peak_blocks))
  
  for(i in seq_along(peak_blocks)) {
    
    #Position of the end of the respective block 
    end_of_block = sum(rle_result$lengths[1:peak_blocks[i]])
    
    #Calculate half length (middle) of the block
    half_length = floor(rle_result$lengths[peak_blocks[i]] /2)
    
    #Middle position of the shoulder 
    peak_positions[i] = end_of_block - half_length
  }
  
  return(peak_positions)
}
```

```{r}
# Calculate the positions of the "shoulders" for each protein row, i.e. regions with ≥4 consecutive fractions with signal >2%
# Save the shoulder positions as a new column called peaks in the respective data frames rnase_3 and ctrl_3.
# New column: "shoulders" (column 28)

rnase_3$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_3$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )


rnase_norm_mean$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_norm_mean$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )
```

Combine Peak and Shoulder Positions for Each Protein

```{r}
# Calculate the total of all relevant signal maxima (real peaks and shoulders) for each protein row in the dataframe 
# New column: "combined_max_ctrl" and "combined_max_rnase" (column 29) respectively

						   						
rnase_3$combined_max_rnase <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima)) # ls_max = numerical vector with the peak positions of this protein
												 ls_shoulder <- as.numeric(unlist(x$shoulders))
												 
												 combined_max_rnase <- c(ls_max, ls_shoulder) # Combine to common vector.
												 combined_max_rnase <- unlist(combined_max_rnase)
												 combined_max_rnase <- combined_max_rnase[combined_max_rnase!=0] # Remove all 0 entries from the result vector, as these do not represent real signals.
												 combined_max_rnase <- sort(combined_max_rnase, decreasing = FALSE) # Sort all peak and shoulder positions in ascending order (1 → 25)
												 if (length(combined_max_rnase) == 0) {0} else {combined_max_rnase} # If there are no peaks or shoulders, 0 (as a placeholder) is stored.
												 })

ctrl_3$combined_max_ctrl <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 ls_shoulder <- as.numeric(unlist(x$shoulders))
												 
												 combined_max_ctrl <- c(ls_max, ls_shoulder)
												 combined_max_ctrl <- unlist(combined_max_ctrl)
												 combined_max_ctrl <- combined_max_ctrl[combined_max_ctrl!=0]
												 combined_max_ctrl <- sort(combined_max_ctrl, decreasing = FALSE)
												 if (length(combined_max_ctrl) == 0) {0} else {combined_max_ctrl} 
												 })


# Füge die neue Spalte der kombinierten Maxima auch noch zu ctrl/rnase_norm_mean, um damit weiter arbeiten zu können

ctrl_norm_mean$combined_max_ctrl = ctrl_3[, "combined_max_ctrl"]
rnase_norm_mean$combined_max_rnase = rnase_3[, "combined_max_rnase"]
```

***********************************************************************************************************
2.3 Count Total Number of Maxima (Peaks + Shoulders) per Protein
***********************************************************************************************************

```{r}
# Determine the number of combined maxima (peaks + shoulders) per protein
# New column: "n_max_comb" (column 30)

rnase_3$n_max_comb <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$combined_max_rnase))
												 n = length(ls_max) # => Answers: How many peaks (maxima and shoulders) does this protein have?
												 if (sum(ls_max) == 0) {0} else {n} # If TRUE, then the result should be 0, instead of length(ls_max), which would then be 1. 
												 })
												 
ctrl_3$n_max_comb <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$combined_max_ctrl))
												 n = length(ls_max)
												 if (sum(ls_max) == 0) {0} else {n} 
												 })


# Selbes für ctrl/rnase_norm_mean

ctrl_norm_mean$n_max_comb = ctrl_3[, "n_max_comb"]
rnase_norm_mean$n_max_comb = rnase_3[, "n_max_comb"] 
```

###################################################################################################
###################################################################################################
###################################################################################################

***********************************************************************************************************
Identifizierung von Proteinen mit einer unterschiedlichen Anzahl an Maxima in CTRL vs. RNASE
***********************************************************************************************************
Erste Vorauswahl an Proteinen: Eine unterschiedliche Anzahl an Maxima ist ein erster Hinweis auf mögliche RNA-abhängige Proteine.

```{r}
# Determine the number of only peak maxima ("local_maxima") per protein
# New column: "n_local_maxima" (column 31)

rnase_3$n_local_maxima <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 n = length(ls_max) 
												 if (sum(ls_max) == 0) {0} else {n}  
												 })
												 
ctrl_3$n_local_maxima <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 n = length(ls_max)
												 if (sum(ls_max) == 0) {0} else {n} 
												 })


# Selbes für ctrl/rnase_norm_mean

ctrl_norm_mean$n_local_maxima = ctrl_3[, "n_local_maxima"]
rnase_norm_mean$n_local_maxima = rnase_3[, "n_local_maxima"]  
```









***********************************************************************************************************
1. Kriterium der Aufreinigung des Datensatzes
Das Hauptmaximum des jeweiligen Proteins ist um mindestens 2 Maxima bezüglich seiner Position verschoben
***********************************************************************************************************

```{r}
# Erstelle einen neuen Data.Frame, in welchem das Hauptmaximum der Proteine verschoben ist, Name: ctrl_main_shift, rnase_main_shift

# Differenz berechnen (Vektor mit absoluten Abweichungen)
diff_main_maxima <- abs(ctrl_norm_mean$global_maximum - rnase_norm_mean$global_maximum)

# Positionen der Proteine mit Abweichung ≥ 3 Fraktionen 
deviating_main_maxima <- which(diff_main_maxima >= 2)

# length(deviating_main_maxima)
# 1351 Proteine zeigen einen shift des Hauptmaximums ≥ 2 Fraktionen

ctrl_main_shift = ctrl_norm_mean[deviating_main_maxima, ]
rnase_main_shift = rnase_norm_mean[deviating_main_maxima, ]
```

```{r}
# Erstelle den komplementären Data.Frame, der alle die jenigen Proteine beinhaltet, deren Hauptmaximum nicht um mindestens 2 Fraktionen shiftet, ctrl_main_shift "+" ctrl_no_main_shift = ctrl_norm_mean

ctrl_no_main_shift = ctrl_norm_mean[!rownames(ctrl_norm_mean) %in% rownames(ctrl_main_shift), ]
rnase_no_main_shift = rnase_norm_mean[!rownames(rnase_norm_mean) %in% rownames(rnase_main_shift), ]
```



**********************
Hypothese: Korrelation von ctrl_main_shift mit rnase_main_shift ist geringer als von ctrl_no_main_shift mit rnase_no_main_shift
**********************

```{r}
# Funktion zur Berechnung der zeilenweise Korrelation, Vermutung: cor von ctrl_main_shift ist geringer als von ctrl_no_main_shift

correlations <- function(df1, df2, methode = "pearson") {
  
  # Prüfen, ob beide Dataframes gleich dimensioniert sind
  if (!all(dim(df1) == dim(df2))) {
    stop("Die beiden Dataframes müssen die gleiche Dimension haben")
  }

  # Anzahl der Zeilen
  n <- nrow(df1)

  # Vektor zur Speicherung der Korrelationswerte
  correlations <- numeric(n)

  # Schleife über alle Zeilen
  for (i in 1:n) {
    v1 <- as.numeric(df1[i, 1:25])
    v2 <- as.numeric(df2[i, 1:25])

    # Korrelation nur berechnen, wenn beide Vektoren Varianz haben
    if (sd(v1, na.rm = TRUE) != 0 && sd(v2, na.rm = TRUE) != 0) {
      correlations[i] <- cor(v1, v2, method = methode, use = "complete.obs")
    } else {
      correlations[i] <- NA
    }
  }

  abs_correlations = abs(correlations)
  
  mean_abs_correlation = mean(abs_correlations, na.rm = TRUE)
  
  return(list(
    correlations = correlations, mean_abs_correlation = mean_abs_correlation
  ))
}
```



**********************
Evaluierung der Hypothese 
**********************

```{r}
# Mittelwert der Korrelationswerte (ctrl vs. rnase) von denjenigen Proteinen, deren Hauptmaximum um mindestens 2 Fraktionen verschoben ist
testing_cor_shifter = correlations(ctrl_main_shift, rnase_main_shift)
testing_cor_shifter$mean_abs_correlation

# Mittelwert der Korrelationswerte (ctrl vs. rnase) von denjenigen Proteinen, deren Hauptmaximum nicht um mindestens 2 Fraktionen verschoben ist
testing_cor_no_shifter = correlations(ctrl_no_main_shift, rnase_no_main_shift)
testing_cor_no_shifter$mean_abs_correlation

# Hat sich die Hypothese bewahrheitet, ist der Mittelwert der Korrelationen der shifter kleiner als die der no_shifter?
testing_cor_shifter$mean_abs_correlation < testing_cor_no_shifter$mean_abs_correlation
```

Unsere Hypothese hat sich bestätigt. Der Mittelwert der Korrelationen zwischen ctrl und rnase ist kleiner bei den Proteinen, bei denen das Hauptmaximum um mindestens 2 Fraktionen verschoben war. Hier beträgt er 0,42. Bei den Proteinen ohne große Verschiebung des Hauptmaximums beträgt er 0,94.


```{r}
cor_all_proteins = correlations(ctrl_norm_mean, rnase_norm_mean)
cor_all_proteins$mean_abs_correlation
```

Der Mittelwert der Korrelationen auf alle Proteine bezogen beträgt 0,79. Dies ist kleiner als 0,94 und größer als 0,42. 
Dies lässt vorerst den Schluss zu, dass eine Aufreinigung von RNA-abhängigen Proteinen gemäß des Kriteriums einer deutlichen Verschiebung des Hauptmaximums sinnvoll erscheint. Unser Ziel war es, weniger ähnliche Kurven herauszuselektieren, und von ähnlichen Kurven abzutrennen. 







*******************************************************************************************************************************
2. Kriterium der Aufreinigung
Identifizierung derjenigen Proteine aus ctrl/rnase_no_main_shift (Hauptmaxima nicht wesentlich verschoben), die eine unterschiedliche Anzahl an Gesamtmaxima (n_max_comb) aufweisen
*******************************************************************************************************************************

```{r}
#Vektoren der Maxima-Anzahl extrahieren
n_max_ctrl  <- ctrl_no_main_shift$n_max_comb
n_max_rnase <- rnase_no_main_shift$n_max_comb

#Proteine (Zeilennamen) mit gleicher Maxima-Anzahl finden
unequal_max_proteins <- rownames(ctrl_no_main_shift)[n_max_ctrl != n_max_rnase]

#Neuen DataFrame ctrl_equal_max mit diesen Proteinen erstellen
ctrl_unequal_max <- ctrl_no_main_shift[unequal_max_proteins, ]
rnase_unequal_max <- rnase_no_main_shift[unequal_max_proteins, ]


#Vor Abgabe löschen
#dim(ctrl_unequal_max)
#dim(rnase_unequal_max)
```



*******************************************************************************************************************************
Proteine mit gleicher Anzahl an Gesamtmaxima (n_max_comb) aus ctrl/rnase_no_main_shift
*******************************************************************************************************************************

```{r}
#Vektoren der Maxima-Anzahl extrahieren
n_max_ctrl  <- ctrl_no_main_shift$n_max_comb
n_max_rnase <- rnase_no_main_shift$n_max_comb

#Proteine (Zeilennamen) mit gleicher Maxima-Anzahl finden
equal_max_proteins <- rownames(ctrl_no_main_shift)[n_max_ctrl == n_max_rnase]

#Neuen DataFrame ctrl_equal_max mit diesen Proteinen erstellen
ctrl_equal_max <- ctrl_no_main_shift[equal_max_proteins, ]
rnase_equal_max <- rnase_no_main_shift[equal_max_proteins, ]

#Test: Löschen vor Abgabe
#dim(ctrl_no_main_shift)
#dim(rnase_equal_max)
#dim(ctrl_main_shift)
#length(n_max_ctrl)
#length(n_max_rnase)
```





***********************************************************************************************************
Wilcoxon Test
***********************************************************************************************************

Statistische Beurteilung, ob die Aufreinigung des Datensatzes dazu geführt hat, dass die selektierten Proteine signifikante Unterschiede zwischen ctrl und rnase aufweisen (z.B. bei COM), während die nicht selektierten Proteine diese Unterschiede nicht aufweisen


1: ctrl_unequal_max und ctrl_main_shift, sowie rnase_unequal_max und rnase_main_shift werden kombiniert
--> ctrl_selected und rnase_selected entstehen

2: Test rownames(ctrl_selected) == rownames(rnase_selected), um sicherzugehen,dass die Proteine in der gleichen Reihenfolge sind, und auch sicher diegleichen Proteine vergleichen werden

3: ctrl_equal_max und rnase_equal_max umbennen zu ctrl_not_selected und rnase_not_selected

4.1: Aus der Spalte "combined_max_ctrl" von ctrl_selected wird pro Zeile der Mittelwert der Peak-Positionen  gebildet und dann verglichen mit dem Mittelwert der Peak-Positionen von "combined_max_rnase" von rnase_selected 

4.2: Aus der Spalte "combined_max_ctrl" von control_not_selected wird pro Zeile der Mittelwert der Peak-Positionen gebildet und dann verglichen mit dem Mittelwert der Peak-Positionen von "combined_max_rnase" von rnase_not_selected

4.3: Jetzt wird der Wilcoxon-Tets angewendet, um die Differenzen zu untersuchen 
--> H0: Die Verteilung der Differenzen in beiden Gruppen haben keinen systematischen Unterschied 

5. Alternative: Mittels COM (center of mass) anstatt Differenzen der Mittelwerte arbeiten



1.Schritt 
```{r}
ctrl_selected = rbind(ctrl_main_shift, ctrl_unequal_max)
rnase_selected = rbind(rnase_main_shift, rnase_unequal_max)
```


2.Schritt
```{r}
sum(rownames(ctrl_selected) != rownames(rnase_selected))
```


3.Schritt
```{r}
ctrl_not_selected = ctrl_equal_max
rnase_not_selected = rnase_equal_max

dim(ctrl_not_selected)[1] + dim(ctrl_selected)[1] == 4765
```


4.Schritt
```{r}
# Mittelwerte pro Zeile berechnen und Differenz bilden
get_differences <- function(ctrl_df, rnase_df, ctrl_col, rnase_col) {
  ctrl_means <- sapply(ctrl_df[[ctrl_col]], mean)
  rnase_means <- sapply(rnase_df[[rnase_col]], mean)
  return(ctrl_means - rnase_means)
}

# Berechne die Differenzvektoren für beide Gruppen
diff_selected <- get_differences(ctrl_selected, rnase_selected, "combined_max_ctrl", "combined_max_rnase")
diff_not_selected <- get_differences(ctrl_not_selected, rnase_not_selected, "combined_max_ctrl", "combined_max_rnase")

# Wilcoxon Rank-Sum Test (ungepaart)
wilcox_test_result <- wilcox.test(diff_selected, diff_not_selected)

# Ergebnis anzeigen
print(wilcox_test_result)
```


```{r}
library(ggplot2)

# Vektor mit Gruppenzugehörigkeit
group <- c(rep("selected", length(diff_selected)), rep("not_selected", length(diff_not_selected)))
diffs <- c(diff_selected, diff_not_selected)

df_plot <- data.frame(Group = group, Difference = diffs)

ggplot(df_plot, aes(x = Group, y = Difference)) +
  geom_violin(trim = FALSE, fill = "lightblue") +
  geom_boxplot(width = 0.1, outlier.shape = NA) +
  theme_minimal() +
  labs(title = "Verteilung der Differenzen", y = "ctrl - rnase", x = "")
```










###################################################################################################
###################################################################################################
###################################################################################################
* hier ruht unser Gaussian fit ˙◠˙ 

***********************************************************************************************************
T-Test (Bens)
***********************************************************************************************************

```{r}
df1 <- table.ctrl.fit[1:25] # Gruppe A
df2 <- table.rnase.fit[1:25] # Gruppe B

df_numeric1 <- as.data.frame(lapply(df1, function(x) as.numeric(as.character(x))))
df_numeric2 <- as.data.frame(lapply(df2, function(x) as.numeric(as.character(x))))

colnames(df_numeric1) <- colnames(table.ctrl.fit[1:25])
colnames(df_numeric2) <- colnames(table.rnase.fit[1:25])

rownames(df_numeric1) <- rownames(table.ctrl.fit[1:25])
rownames(df_numeric2) <- rownames(table.rnase.fit[1:25])

```

```{r}
# T-Test pro Reihenpaar
t_test_ergebnisse <- lapply(seq_len(nrow(df_numeric1)), function(i) {
  x <- as.numeric(df_numeric1[i, ])
  y <- as.numeric(df_numeric2[i, ])

  # Nur t-Test, wenn beide Gruppen mindestens 2 gültige Werte haben
  if (sum(!is.na(x)) >= 2 && sum(!is.na(y)) >= 2) {
    t_res <- t.test(x, y, paired = TRUE)
    data.frame(
      proteine = rownames(df_numeric1)[i],
      p_wert = t_res$p.value,
      mittelwert_df1 = mean(x, na.rm = TRUE),
      mittelwert_df2 = mean(y, na.rm = TRUE),
      t_wert = t_res$statistic,
      df = t_res$parameter
    )
  } else {
    NULL
  }
})

# Entferne NULLs (wo T-Test nicht möglich war)
t_test_ergebnisse <- Filter(Negate(is.null), t_test_ergebnisse)

# Ergebnisse zusammenführen
t_test_ergebnisse_df <- do.call(rbind, t_test_ergebnisse)

# Optional: Nach p-Wert sortieren
t_test_ergebnisse_df <- t_test_ergebnisse_df[order(t_test_ergebnisse_df$p_wert), ]

# Ausgabe
print(t_test_ergebnisse_df)
```

```{r}
list_significant_shift <- t_test_ergebnisse_df[t_test_ergebnisse_df$p_wert < 0.05, ]

# Beispiel: p-Wert zwischen 0.05 und 0.7
list_possible_shift <- t_test_ergebnisse_df[t_test_ergebnisse_df$p_wert > 0.05 & t_test_ergebnisse_df$p_wert < 0.7, ]


list_no_shift <- t_test_ergebnisse_df[ t_test_ergebnisse_df$p_wert > 0.7 , ]

# Nur Namen der Proteine
significant_shift_proteins <- list_significant_shift$zeile
possible_shift_proteins <- list_possible_shift$zeile
no_shift_proteins <- list_no_shift$zeile
```


***********************************************************************************************************
PCA
***********************************************************************************************************

```{r}
# Nur numerische Spalten behalten
pca_ctrl_numeric <- table.ctrl.fit[1:25, sapply(table.ctrl.fit, is.numeric)]
pca_rnase_numeric <- table.rnase.fit[1:25, sapply(table.rnase.fit, is.numeric)]

# Zeilen mit NAs entfernen
pca_ctrl_clean <- pca_ctrl_numeric[complete.cases(pca_ctrl_numeric), ]
pca_rnase_clean <- pca_rnase_numeric[complete.cases(pca_rnase_numeric), ]

pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)

# Einfaches 2D PCA-Plot
plot(pca_result_ctrl$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL")

plot(pca_result_rnase$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE")
```

```{r}
#chech which PCs have the most variance
summary(pca_result_ctrl)
summary(pca_result_rnase)
```

```{r}
#plot PC1 with PC3
plot(pca_result_ctrl$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL")

plot(pca_result_rnase$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE")


#plot PC2 with PC3
plot(pca_result_ctrl$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")

plot(pca_result_rnase$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE")
```
```{r}
# Namen der Zeilen in PCA müssen mit Protein-Namen übereinstimmen
# Setze z. B. signifikante auf "red"
highlight_proteine_significant <- list_significant_shift
highlight_proteine_possible <- possible_shift_proteins
highlight_proteine_no <- no_shift_proteins
```

```{r}
farben <- rep("grey", nrow(pca_result_ctrl$x))
farben[rownames(pca_result_ctrl$x[, 1:2]) %in% highlight_proteine_significant] <- "red"
farben[rownames(pca_result_ctrl$x[, 1:2]) %in% highlight_proteine_possible] <- "blue"
farben[rownames(pca_result_ctrl$x[, 1:2]) %in% highlight_proteine_no] <- "green"


plot(pca_result_ctrl$x[, 1:2], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_ctrl$x[,c(1, 3)], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_ctrl$x[,2:3], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)


plot(pca_result_rnase$x[,1:2], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_rnase$x[,c(1, 3)], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_rnase$x[,2:3], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
```
```{r}
# Reihennamen beider Tabellen
rows_ctrl_pca <- rownames(table.ctrl.fit)
rows_rnase_pca <- rownames(table.rnase.fit)
no_shift_proteins <- list_no_shift$zeile

# Reihen, die NICHT in table2 vorkommen (nur die willst du behalten)
rows_to_keep_ctrl_no_shift <- setdiff(rows_ctrl_pca, no_shift_proteins)
rows_to_keep_rnase_no_shift <- setdiff(rows_rnase_pca, no_shift_proteins)

# table1 ohne die gemeinsamen Reihen
ctrl_mean_filtert_final_pca <- table.ctrl.fit[rows_to_keep_ctrl_no_shift,]
rnase_mean_filtert_final_pca <- table.rnase.fit[rows_to_keep_rnase_no_shift,]
```


```{r}
# Nur numerische Spalten behalten
pca_ctrl_numeric_sig <- ctrl_mean_filtert_final_pca[1:251, sapply(ctrl_mean_filtert_final_pca, is.numeric)]
pca_rnase_numeric_sig <- rnase_mean_filtert_final_pca[1:251, sapply(rnase_mean_filtert_final_pca, is.numeric)]

# Zeilen mit NAs entfernen
pca_ctrl_clean_sig <- pca_ctrl_numeric_sig[complete.cases(pca_ctrl_numeric_sig), ]
pca_rnase_clean_sig <- pca_rnase_numeric_sig[complete.cases(pca_rnase_numeric_sig), ]

# Funktion: Entferne Spalten ohne Varianz
remove_const_cols <- function(df) {
  df[, apply(df, 2, function(col) sd(col, na.rm = TRUE) > 0)]
}

# Anwenden
pca_ctrl_clean_sig <- remove_const_cols(pca_ctrl_clean_sig)
pca_rnase_clean_sig <- remove_const_cols(pca_rnase_clean_sig)


pca_result_ctrl_sig <- prcomp(pca_ctrl_clean_sig, center = TRUE, scale. = TRUE, )
pca_result_rnase_sig <- prcomp(pca_rnase_clean_sig, center = TRUE, scale. = TRUE)
```

```{r}
farben <- rep("grey", nrow(pca_result_ctrl_sig$x))
farben[rownames(pca_result_ctrl_sig$x[, 1:2]) %in% highlight_proteine_significant] <- "red"
farben[rownames(pca_result_ctrl_sig$x[, 1:2]) %in% highlight_proteine_possible] <- "blue"
farben[rownames(pca_result_ctrl_sig$x[, 1:2]) %in% highlight_proteine_no] <- "green"


plot(pca_result_ctrl_sig$x[, 1:2], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_ctrl_sig$x[,c(1, 3)], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_ctrl_sig$x[,2:3], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)


plot(pca_result_rnase_sig$x[,1:2], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_rnase_sig$x[,c(1, 3)], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_rnase_sig$x[,2:3], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
```

```{r}
plot(pca_result_ctrl_sig, type = "l", main = "Elbow-Plot CTRL")
plot(pca_result_rnase_sig, type = "l", main = "Elbow-Plot RNASE")
```

```{r}
pca_ctrl_pc1_pc2 <- as.data.frame(pca_result_ctrl_sig$x[, 1:2])
pca_ctrl_pc1_pc3 <- as.data.frame(pca_result_ctrl_sig$x[, c(1,3)])
pca_ctrl_pc2_pc3 <- as.data.frame(pca_result_ctrl_sig$x[, 2:3])

pca_rnase_pc1_pc2 <- as.data.frame(pca_result_rnase_sig$x[, 1:2])
pca_rnase_pc1_pc3 <- as.data.frame(pca_result_rnase_sig$x[, c(1,3)])
pca_rnase_pc2_pc3 <- as.data.frame(pca_result_rnase_sig$x[, 2:3])
```

***********************************************************************************************************
kmeans Clustering
***********************************************************************************************************

```{r}
library(factoextra)

fviz_nbclust(pca_ctrl_pc1_pc2, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc1_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc2_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC2/PC3") +
  theme_minimal()

fviz_nbclust(pca_rnase_pc1_pc2, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC3") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc2_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC2/PC3") +
  theme_minimal() 
```

```{r}
km_result_ctrl<- kmeans(pca_ctrl_pc1_pc2, centers = 2)

km_result_rnase<- kmeans(pca_rnase_pc1_pc2, centers = 2)
```

```{r}
library(factoextra)

# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL")

fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc2,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der RNASE")

fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der RNASE")
fviz_cluster(km_result_rnase, data = pca_rnase_pc2_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der RNASE")
```

