
**************************************************************************************************************
0. Load Dataset and Inspect Row/Column Names
**************************************************************************************************************

```{r}
#Reads table, by indicating path to directory where the dataset is stored, and stores it to variable NS_Table (NS for Non-synchronizied HeLa-cells)

NS_Table <- read.table("Daten/Data, copy but dont open.csv", header=TRUE, row.names=1, sep = ";")
```

```{r}
#The first 12 titles of the table (NS_Table) rows/colums are read out

#Row names are protein names
head(rownames(NS_Table),12)

#Columns indicate the respective fractions from 1 to 25, and their replicated
head(colnames(NS_Table),12)
```

**************************************************************************************************************
1. Data Cleanup
1.1. Rearrange and reorder the columns to their fraction and treatment
**************************************************************************************************************

Define sample metadata vectors (Treatment, Replicates, Fractions)
Creates 3 vectors that describe the characteristics of the columns (i.e., samples) in the data set:
  levels_CR → indicates whether the sample was treated with RNASE or as a CTRL
  levels_fraction → labels the column with the replicate number (1–3) for either CTRL or RNASE
  fraction_names → creates the variables fraction1 to fraction25 to assign the replicates to each fraction

```{r}
#A vector consists of 2 variables (CTRL, RNASE) --> c("CTRL", "RNASE")
#The factor() function encodes a vector as a factor. The 2 variables CTRL and RNASE are ordered into 2 different levels (characters)
#rep(vector,75) repeats the factor() function 75 times, because we have 150 columns (75 times CTRL and RNASE)
#The factor is defined as the variable 'treatment'

levels_CR <- factor(rep(c("CTRL", "RNASE"),75))
```

```{r}
#Every sample of every fraction gets its own level to disconnect them from each other -> 6 levels per fraction because we have 3 CTRLs and 3 RNASEs per fraction

levels_fraction <- factor(rep(c("Ctrl_Rep1","RNase_Rep1","Ctrl_Rep2","RNase_Rep2","Ctrl_Rep3","RNase_Rep3"),25))
```

```{r}
# Creation of a matrix with 6 rows and 25 columns. The matrix is filled by row from fraction1 to fraction25 so every column has one single fraction.
# sep="" compares the word fraction with the numbers 1 to 25 without a blank space.
# paste("fraction",1:25,sep="") creates a vector with the strings fraction1 to fraction25
# as.vector changes the created matrix into a vector with 150 elements sorted from 6 times fraction1 to 6 times fraction25

fraction_names <- as.vector(matrix(rep(paste("fraction",1:25,sep=""),6), nrow = 6, ncol=25, byrow = TRUE))
```

Create Metadata Data Frame and Check for Missing Values

```{r}
# The number of rows are stored in a variable
n_row <- nrow(NS_Table)

# The row names (protein names) are stored in a variable
row_names <- rownames(NS_Table)
```

```{r}
# Creation of a data frame with levels_CR, levels_fraction and fraction_names. This assigns every replicate of the factions (levels_fraction) to their fraction (fraction_names) and their kind of treatment, CRTL or RNASE (levels_CR).

colmns_sorted <- data.frame(row.names = colnames(NS_Table), levels_CR = levels_CR, levels_fraction = levels_fraction, fraction_names = fraction_names)

#Check for missing values, there are none 
anyNA(NS_Table)
```
******************************************************************************************************************
1.2 Normalization step between the replicates in each fraction and for each treatment using the mean value method
******************************************************************************************************************

Split Data by Fractions and Treatment (CTRL vs RNASE)

```{r}
# lapply executes for every with paste created string (the fractions) a function fx
# colmns_sorted$fraction == fx: checks which columns are part of the fractions fx
# NS_Table[, ...] filters just these columns and assigns them to the list "fraction.tables"
# names(fraction.tables): the list "fraction.tables" gets names for its segments and assigns them to the variable selected_proteins 

fraction.tables <- lapply(paste("fraction", 1:25, sep = ""), function(fx) {NS_Table[, colmns_sorted$fraction_names == fx]})

names(fraction.tables) <- paste("fraction", 1:25, sep = "")

selected_proteins <- names(fraction.tables)
```

```{r}
# List with just CTRL/RNASE columns for each fraction
# subset filters just the fractions that fulfill the conditions: fraction_names == fx --> fraction name is part of the function fx, levels_CR == "CTRL" --> protein was treated as a CTRL
# rownames() takes the rownames of the filtered fractions and assigns them to the variable col
# NS_Table[, cols, drop = FALSE] the names that are part of NS_Table are filtered out and drop = FALSE makes sure that fraction.tables.CTRL will be a dataframe

# Liste mit nur CTRL-Spalten für jede Fraktion
fraction.tables.CTRL <- lapply(selected_proteins, function(fx) {
  cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "CTRL")) 
  NS_Table[, cols, drop = FALSE]
  })

# Liste mit nur RNASE-Spalten für jede Fraktion
fraction.tables.RNASE <- lapply(selected_proteins, function(fx) {
  cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "RNASE"))
  NS_Table[, cols, drop = FALSE]})

names(fraction.tables.CTRL) <- selected_proteins
names(fraction.tables.RNASE) <- selected_proteins
```

Calculate Mean Protein Intensities per Fraction and Treatment

```{r}
# sapply(df, mean) calculates the mean of every column of the dataframe fraction.tables.CTRL
# Für jede Bedingung (z.B fraction 1, Ctrl, Rep 1) wird der Mittelwert über die Proteine gebildet, dies ist pro Bedingung dann ein einziger Wert

avg.tables.CTRL <- lapply(fraction.tables.CTRL, function(df) {
  sapply(df, mean)
})

avg.tables.RNASE <- lapply(fraction.tables.RNASE, function(df) {
  sapply(df, mean)
})
```
Calculate Normalization Factors Based on Most Similar Replicates

```{r}
# Determine normalization factor for each condition (i.e. sample), as the mean of the 2 most similar replicates.
# Create a function norm_fact for this step:

norm_fact <- function(x) {
				if( (abs(x[1]-x[2])<abs(x[1]-x[3])) && (abs(x[1]-x[2])<abs(x[2]-x[3])) ) 
					{mean(c(x[1],x[2]))} else if( (abs(x[1]-x[3])<abs(x[1]-x[2])) && (abs(x[1]-x[3])<abs(x[2]-x[3])) )
												  {mean(c(x[1],x[3]))} else {mean(c(x[2],x[3]))} 
}
```


Normalize Mean Intensities for Each Fraction and Treatment

```{r}
# Normalisierung der Mean value Vektoren
# norm_factor <- norm_fact(vec): Auf jeden Vektor in der Liste avg.tables.CTRL (diese sind von der Länge 3) wird die Funktion norm_fact angewendet
# norm_factor / vec: ergibt einen neuen Vektor der Länge 3, der einen Korrekturfaktor für die einzelnen Replikate darstellt, um die Proteinmengen der Replikate aneinander anzugleichen

norm_mean_frxn_CTRL <- lapply(avg.tables.CTRL, function(vec) {
  norm_factor <- norm_fact(vec)
  norm_factor / vec 
})

norm_mean_frxn_RNASE <- lapply(avg.tables.RNASE, function(vec) {
  norm_factor <- norm_fact(vec)
  norm_factor / vec 
})
```


Extract Normalization Factors for Each Replicate and Treatment

```{r}
# Correction factor for the overall protein quantity
# Normalization vectors for replicates 1-3
# function(x) x[1]: extracts the first element of each vector in the list
# norm.ctrl1 is a numeric vector consisting of the 1st element of each normalized CTRL vector

norm.ctrl1 <- sapply(norm_mean_frxn_CTRL, function(x) x[1])
norm.ctrl2 <- sapply(norm_mean_frxn_CTRL, function(x) x[2])
norm.ctrl3 <- sapply(norm_mean_frxn_CTRL, function(x) x[3])

norm.rnase1 <- sapply(norm_mean_frxn_RNASE, function(x) x[1])
norm.rnase2 <- sapply(norm_mean_frxn_RNASE, function(x) x[2])
norm.rnase3 <- sapply(norm_mean_frxn_RNASE, function(x) x[3])
```

```{r}
# Defines logical vectors (TRUE, FALSE), which are later used to create subtables - separately for treatment (Ctrl vs. RNase) and replica (Rep1, Rep2, Rep3)
# colmns_sorted$levels_fraction =="Ctrl_Rep1": checks at which position exactly in the columns_sorted Ctrl_Rep1 can be found (marks it with TRUE)

data.ctrl1 <- colmns_sorted$levels_fraction =="Ctrl_Rep1"
data.ctrl2 <- colmns_sorted$levels_fraction =="Ctrl_Rep2"
data.ctrl3 <- colmns_sorted$levels_fraction =="Ctrl_Rep3"
data.rnase1 <- colmns_sorted$levels_fraction =="RNase_Rep1"
data.rnase2 <- colmns_sorted$levels_fraction =="RNase_Rep2"
data.rnase3 <- colmns_sorted$levels_fraction =="RNase_Rep3"
```

Normalize Protein Intensity Data

```{r}
# Normalization step, fraction-wise
# takes specific columns from the protein intensity table and scales each row according to a normalization factor to compensate for measurement differences between replicates
# mask: A logical vector (TRUE/FALSE) that specifies which columns of NS_Table are selected
# selected <- NS_Table[, mask]: from NS_Table only the columns marked with TRUE in mask are selected
# (`*`, selected, norm_vec, SIMPLIFY = FALSE): Multiplication of colums of selected and the vector norm_vec saved as a list

normalize_group <- function(mask, norm_vec) {
  selected <- NS_Table[, mask]                  
  as.data.frame(mapply(`*`, selected, norm_vec, SIMPLIFY = FALSE))
}

# logical vectors (data.ctrl1) and vectors with normalization-factors (norm.ctrl1) form groups
# normalize_group(): multiplication of the vectors with their normalization-factor

table.ctrl1  <- normalize_group(data.ctrl1,  norm.ctrl1)
table.ctrl2  <- normalize_group(data.ctrl2,  norm.ctrl2)
table.ctrl3  <- normalize_group(data.ctrl3,  norm.ctrl3)
table.rnase1 <- normalize_group(data.rnase1, norm.rnase1)
table.rnase2 <- normalize_group(data.rnase2, norm.rnase2)
table.rnase3 <- normalize_group(data.rnase3, norm.rnase3)
```

```{r}
# Get the proper rownames for the tables

rownames(table.ctrl1) <- row_names
rownames(table.ctrl2) <- row_names
rownames(table.ctrl3) <- row_names
rownames(table.rnase1) <- row_names
rownames(table.rnase2) <- row_names
rownames(table.rnase3) <- row_names
```

Smooth Data with Sliding Window (Moving Average of 3 Fractions)

```{r}
# Apply a sliding window/moving average of 3 points to the data to reduce noise in the data and obtain smoother curves (not possible for fraction 1 and 25)

smooth_table <- function(tbl) {
  data.frame(tbl[1], (tbl[1:23] + tbl[2:24] + tbl[3:25]) / 3, tbl[25])
}

table.ctrl1.SW <- smooth_table(table.ctrl1)
table.ctrl2.SW <- smooth_table(table.ctrl2)
table.ctrl3.SW <- smooth_table(table.ctrl3)
table.rnase1.SW <- smooth_table(table.rnase1)
table.rnase2.SW <- smooth_table(table.rnase2)
table.rnase3.SW <- smooth_table(table.rnase3)
```

```{r}
# Get the proper rownames for the tables

colnames(table.ctrl1.SW) <- colnames(table.ctrl1)
colnames(table.ctrl2.SW) <- colnames(table.ctrl2)
colnames(table.ctrl3.SW) <- colnames(table.ctrl3)
colnames(table.rnase1.SW) <- colnames(table.rnase1)
colnames(table.rnase2.SW) <- colnames(table.rnase2)
colnames(table.rnase3.SW) <- colnames(table.rnase3)
```

Normalize Fraction Intensities to Percentages (Sum to 100%)

```{r}
# Normalization of the fractions: Sum of all fraction values equals 100 (%)

normalize_table <- function(tbl) {
  tbl * 100 / rowSums(tbl)
}


tables.ctrl <- list(
  ctrl1 = table.ctrl1.SW,
  ctrl2 = table.ctrl2.SW,
  ctrl3 = table.ctrl3.SW)

tables.rnase <- list(
  rnase1 = table.rnase1.SW,
  rnase2 = table.rnase2.SW,
  rnase3 = table.rnase3.SW)

# Calculation of the percentages of the fractions in the normalized tables (table.ctrl1.SW)

norm_tables.ctrl <- lapply(tables.ctrl, normalize_table)
norm_tables.rnase <- lapply(tables.rnase, normalize_table)
```

Replace NA and NaN Values with 0

```{r}
# Function for replacing NA and NaN with 0

clean_table <- function(tbl) {
  tbl <- rapply(tbl, function(x) ifelse(is.na(x), 0, x), how = "replace")
  tbl <- rapply(tbl, function(x) ifelse(is.nan(x), 0, x), how = "replace")
  return(tbl)
}

# Getting the clean table

tables.norm.ctrl <- lapply(norm_tables.ctrl, clean_table)
tables.norm.rnase <- lapply(norm_tables.rnase, clean_table)
```

Calculate Mean Across Replicates

```{r}
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)

# Addition of all data-frames in the list my.list.ctrl.norm (element-wise) and Division of the Sum with 3 to get the mean of all 3 replicates

ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
```

```{r}
# Change names of the columns: from "fraction1" to "fraction25"

col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
```

```{r}
# second normalization of the fractions (mean destroyed first normalization): Sum of all fraction values equals 100 (%)

ctrl_norm_mean <- ctrl_norm_mean*100/rowSums(ctrl_norm_mean)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)

```

Filter Proteins with Zero Values Across All Fractions

```{r}
# Function for replacing NA and NaN with 0

replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")

ctrl_norm_mean <- replace_na_nan(ctrl_norm_mean)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
```

```{r}
# If a curve is 0 in all fractions, the other fraction is also set to 0 and is excluded from the analysis

ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
```

Plot Example Protein Fractionation Profiles

```{r}
row_data1 <- as.numeric(ctrl_norm_mean["PRKDC_HUMAN", ])
row_data2 <- as.numeric(rnase_norm_mean["PRKDC_HUMAN", ])

# Plot
plot(row_data2,
     type = "l",        
     main = "Plot for PRKDC_HUMAN",
     xlab = "Fractions",
     ylab = "Values",
     col = "blue",
     lwd = 2)

lines(row_data1,
      type = "l",
      col = "red",
      lwd = 2)
```

**************************************************************************************************************
2. Find local maxima greater than 2 as fit parameters from average curves
2.1 Identify local maxima
**************************************************************************************************************

Identify local maxima by peak calling for the mean of each protein.
In order to get rid of the noise, only values above 2 are considered.
Find shoulders that were not discovered previously.

Define Peak Finding Function

```{r}
#Function find_peaks
#Peak is local maximum with smaller "window" points on each side
#Bigger window =>more stringent peak finding procedure 

find_peaks <- function(x, window = 2) {
  slope_changes <- diff(sign(diff(x)))
  peak_indices <- which(slope_changes < 0)

  peaks <- c()

  for (i in peak_indices) {
    left <- max(1, i - window + 1)
    right <- min(length(x), i + window + 1)

    neighbors <- c(x[left:i], x[(i + 2):right])

    if (all(neighbors <= x[i + 1])) {
      peaks <- c(peaks, i + 1)
    }
  }

# part added to deal with plateau
# Ergibt diese Operation überhaupt Sinn, Plateaus haben ja auch nur einen Hochpunkt, und alle anderen (ähnlichen) werden doch ohnehin nicht erkannt werden?
     n = length(peaks)
     if (n>1) {
     			rem <- numeric(0)
     			for (i in 1:(n-1)) { if  ((peaks[i]+1) == peaks[(i+1)]) {rem <- c(rem, peaks[i+1]) } }
     			for (i in 1:(n-1)) { if  ((peaks[i]+2) == peaks[(i+1)]) {rem <- c(rem, peaks[i+1]) } }
     			peaks <- peaks[! peaks%in% rem]
     		  }	 
  
# part added to deal with the 1st and 25th values, in case they are max
     if ( sum(x[1]>x[2:(window+1)]) == 2 ) {peaks <- c(peaks, 1)} 
     if ( sum(x[25]>x[24:(25-window)]) == 2 ) {peaks <- c(peaks, 25)}
     peaks <- unlist(peaks)
     peaks
     
 #return(peaks)
     
} 
  
#Test, ob die Peak-Positionen richtig ausgegeben werden
#test_vec2 = as.numeric(ctrl_norm_mean[4, ])
#find_peaks(test_vec2)
#z = c(30, 2, 2, 2, 2, 2, 5, 4, 3, 2, 2, 2, 2, 2, 31, 30, 31, 32, 2, 2, 2, 2, 2, 2, 30)
#find_peaks(z)
```

Apply Peak Finding to Mean Data and Filter Peaks > 2

```{r}
# Apply the function to the data set and retrieve the values
# restriction to values above an absolut threshold of 2%
# New column: "maxima" (column 26)

ctrl_norm_mean$maxima <- apply(ctrl_norm_mean, 1, function(x) {
															   list <- find_peaks(x)
															   list <- list[x[list] > 2] 
															   list <- unlist(list)
															   list
															   })
															   
rnase_norm_mean$maxima <- apply(rnase_norm_mean, 1, function(x) {
															   list <- find_peaks(x)
															   list <- list[x[list] > 2] 
															   list <- unlist(list)
															   list
															   })
```

****************************************************************************************************************
2.2 Identify shoulders, regions that are not recognized as peaks, even though they have a high signal intensity.
****************************************************************************************************************

Create Binary Data Frames Indicating Signal > 2%

```{r}
# Identify the RNAse fractions with signal intensity > 2%. 
# Create a new data frame containing 0 (= this fraction value was ≤2% ) and 1 (= this fraction value was >2%.), as well as the intensity maxima.
# The two new data frames are created, rnase_3 and ctrl_3, as copies of the previously calculated, normalized mean tables (*_norm_mean).

rnase_3 <- rnase_norm_mean
# Compare each value in columns 1 to 25 (the fractions) of the rnase_norm_mean dataframe with the threshold of 2%.
# Convert TRUE to 1 and FALSE to 0. 
rnase_3[1:25] <- (rnase_norm_mean[1:25] > 2)*1

# Identify the CTRL fractions with signal intensity > 2%. 
# Create a new data frames containing 0 / 1, as well as the intensity maxima.
ctrl_3 <- ctrl_norm_mean
ctrl_3[1:25] <- (ctrl_norm_mean[1:25] > 2)*1
```

Mask Regions Around Detected Peaks to Exclude Them from Shoulder Search

```{r}
# Remove and exclude 3 fractions left and right of each peak (7 in total) from the shoulder search.
# Wie können überhaupt noch Werte auf "1" bleiben, sie können natürlich mehr als 2% haben, aber einer hätte als Maximum erkannt werden müssen, und somit hätten alle anderen drum herum gestrichen werden müssen?!

th_max_reg_simple <- function(x) {
  peaks <- as.numeric(unlist(x$maxima)) # Convert the maxima column from *_norm_mean to a numeric vector.
  mask <- rep(1, 25)
  
  for (peak in peaks) { # peak = current peak value, peaks = detected maxima (column 26)
    if (peak > 0) { 
      left <- max(1, peak - 3)
      right <- min(25, peak + 3) # For each peak, the range from peak–3 to peak+3 is calculated.
      mask[left:right] <- 0 # These 7 fractions (the peak itself and 3 before & after it) are masked out by setting their positions in the mask to 0.
    }
  }

  x_values <- as.numeric(x[1:25]) # because $maxima contained characters. 
  x_values <- x_values * mask # Fractions with mask = 1 are retained. Fractions with mask = 0 are set to 0.
  return(x_values)
}

# Apply the function row by row to the entire rnase_3 or ctrl_3 DataFrame.
rnase_3[1:25] <- t(apply(rnase_3, 1, th_max_reg_simple))
ctrl_3[1:25]  <- t(apply(ctrl_3, 1, th_max_reg_simple))
```

Identify Shoulder Regions: Consecutive Fractions > 2% Without Peaks

```{r}
# Detect "shoulder regions"
# Define a function that identifies signal regions where there are at least 4 consecutive fractions with an intensity above 2% using the data frames rnase_3 and ctrl_3.

# select the middle of it
# Apply on the whole dataframe

peaks_regions = function(x) {
  rle_result = rle(as.numeric(x[1:25])) # rle() finds all consecutive equal values -> $lengths and $values
  
  #Find positions of all blocks of ones with length ≥4. These blocks are considered “shoulder regions”.
  peak_blocks = which(rle_result$values == 1 & rle_result$lengths >= 4)
  
  #If there are no such blocks of length >4, return an empty vector
  if (length(peak_blocks) == 0) {
    return(numeric(0))
  }
  
  #Calculate estimate middle for the peak blocks
  peak_positions = numeric(length(peak_blocks))
  
  for(i in seq_along(peak_blocks)) {
    
    #Position of the end of the respective block 
    end_of_block = sum(rle_result$lengths[1:peak_blocks[i]])
    
    #Calculate half length (middle) of the block
    half_length = floor(rle_result$lengths[peak_blocks[i]] /2)
    
    #Middle position of the shoulder 
    peak_positions[i] = end_of_block - half_length
  }
  
  return(peak_positions)
}
```

```{r}
# Calculate the positions of the "shoulders" for each protein row, i.e. regions with ≥4 consecutive fractions with signal >2%
# Save the shoulder positions as a new column called peaks in the respective data frames rnase_3 and ctrl_3.
# New column: "peaks" (column 27)

rnase_3$peaks <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_3$peaks <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )

```

Combine Peak and Shoulder Positions for Each Protein

```{r}
# Calculate the total of all relevant signal maxima (real peaks and shoulders) for each protein row in the dataframe 
# New column: "ctrl_max" and "rnase_max" (column 28) respectively

						   						
rnase_3$rnase_max <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$maxima)) # ls_max = numerical vector with the peak positions of this protein
												 ls_peaks <- as.numeric(unlist(x$peaks))
												 
												 rnase_max <- c(ls_max, ls_peaks) # Combine to common vector.
												 rnase_max <- unlist(rnase_max)
												 rnase_max <- rnase_max[rnase_max!=0] # Remove all 0 entries from the result vector, as these do not represent real signals.
												 rnase_max <- sort(rnase_max, decreasing = FALSE) # Sort all peak and shoulder positions in ascending order (1 → 25)
												 if (length(rnase_max) == 0) {0} else {rnase_max} # If there are no peaks or shoulders, 0 (as a placeholder) is stored.
												 })

ctrl_3$ctrl_max <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$maxima))
												 ls_peaks <- as.numeric(unlist(x$peaks))
												 
												 ctrl_max <- c(ls_max, ls_peaks)
												 ctrl_max <- unlist(ctrl_max)
												 ctrl_max <- ctrl_max[ctrl_max!=0]
												 ctrl_max <- sort(ctrl_max, decreasing = FALSE)
												 if (length(ctrl_max) == 0) {0} else {ctrl_max} 
												 })
```

***********************************************************************************************************
2.3 Count Total Number of Maxima (Peaks + Shoulders) per Protein
***********************************************************************************************************

```{r}
# Determine the number of maxima per protein row in the rnase_3 and ctrl_3 data tables – but only if there are any.
# New column: "nb_max" (column 29)

rnase_3$nb_max <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$rnase_max))
												 n = length(ls_max) # => Answers: How many peaks (maxima and shoulders) does this protein have?
												 if (sum(ls_max) == 0) {0} else {n} # If TRUE, then the result should be 0, instead of length(ls_max), which would then be 1. 
												 })
												 
ctrl_3$nb_max <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$ctrl_max))
												 n = length(ls_max)
												 if (sum(ls_max) == 0) {0} else {n} 
												 })
```

###################################################################################################
###################################################################################################
###################################################################################################

***********************************************************************************************************
Identifizierung von Proteinen mit einer unterschiedlichen Anzahl an Maxima in CTRL vs. RNASE
***********************************************************************************************************
Erste Vorauswahl an Proteinen: Eine unterschiedliche Anzahl an Maxima ist ein erster Hinweis auf mögliche RNA-abhängige Proteine.

```{r}
rnase_3$only_max <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$maxima))
												 n = length(ls_max) 
												 if (sum(ls_max) == 0) {0} else {n}  
												 })
												 
ctrl_3$only_max <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$maxima))
												 n = length(ls_max)
												 if (sum(ls_max) == 0) {0} else {n} 
												 })

```

```{r}
ctrl_3_selection = ctrl_3
rnase_3_selection = rnase_3

ctrl_3_same_maxima_amount = ctrl_3
rnase_3_same_maxima_amount = rnase_3

diff_index = ctrl_3_selection$only_max != rnase_3_selection$only_max
#diff_index_only_maxima = ctrl_3_selection$only_max != rnase_3_selection$only_max
same_index = ctrl_3_same_maxima_amount$only_max == rnase_3_same_maxima_amount$only_max

ctrl_3_selection = ctrl_3_selection[diff_index, ]
rnase_3_selection = rnase_3_selection[diff_index, ]

ctrl_3_same_maxima_amount = ctrl_3_same_maxima_amount[same_index, ]
rnase_3_same_maxima_amount = rnase_3_same_maxima_amount[same_index, ]

#1333 Proteine zeigen eine unterschiedliche Anzahl an Peaks, hierbei sollte allerdings bedacht werden, dass die Anzahl der Peaks auch von den Schultern abhängt. Wir dachten uns aber, dass das Entstehen einer Schulter auch bedeutet, dass sich zwischen beiden Versuchsansätzen etwas geändert hatte, und somit eventuell eine RNA-abhängigkeit vorliegt. Bei 1253 alleine Unterschied sich die Anzahl der tatsächlichen Maxima unabhängig von den Schultern
```



***********************************************************************************************************
Identifizierung von Proteinen bei denen die Maxima um 2 Fraktionen verschoben sind zwischen CTRL und RNASE
***********************************************************************************************************
Zweite Vorauswahl an Proteinen mit potentieller RNA-Abhängigkeit.

```{r}

ctrl_maxima_list <- ctrl_3_same_maxima_amount$maxima
rnase_maxima_list <- rnase_3_same_maxima_amount$maxima
length(ctrl_maxima_list)
length(rnase_maxima_list)

#Liste zum Speichern der Treffer
verschobene_proteine <- c()

protein_ids <- rownames(ctrl_3_same_maxima_amount)

#Für jede Zeile (jedes Protein) prüfen
for (i in seq_along(ctrl_maxima_list)) {
  ctrl_maxima <- as.numeric(unlist(ctrl_maxima_list[[i]]))
  rnase_maxima <- as.numeric(unlist(rnase_maxima_list[[i]]))

  if (length(ctrl_maxima) > 0 && length(ctrl_maxima) == length(rnase_maxima)) { #hab hier noch leere Vektoren ausgeschlossen, wegen Fehlermeldung, vorher: if (length(ctrl_maxima) == length(rnase_maxima))
    max_diff <- max(abs(ctrl_maxima - rnase_maxima))
    if (max_diff >= 2) {
      verschobene_proteine <- c(verschobene_proteine, protein_ids[i])
    }
  }
}
ctrl_3_same_maxima_amount = ctrl_3_same_maxima_amount[verschobene_proteine, ]
rnase_3_same_maxima_amount = rnase_3_same_maxima_amount[verschobene_proteine, ]

```

***********************************************************************************************************
T-Test: Wie ungleich sind die Proteinintensitäten über alle Fraktionen?
***********************************************************************************************************

```{r}

Denkfehler: Die Daten dürfen anscheinend nicht normalisiert, gerundet und brauchen alle 3 Replikate?

#Ergebnistabelle zum Speichern der p-Werte
t_test_results <- data.frame(protein = character(),
                             p_value = numeric(),
                             stringsAsFactors = FALSE)

# Paired t-Test für jedes Protein über 25 Fraktionen hinweg
for (i in 1:nrow(ctrl_norm_mean)) {
  ctrl_signal_intensities <- as.numeric(ctrl_norm_mean[i, 1:25])
  rnase_signal_intensities <- as.numeric(rnase_norm_mean[i, 1:25])
  
  # Paired t-test
  test_result <- t.test(ctrl_signal_intensities, rnase_signal_intensities, paired = TRUE)
  
  t_test_results <- rbind(t_test_results,
                          data.frame(protein = rownames(ctrl_norm_mean)[i],
                                     p_value = test_result$p.value))
}

# Füge adjustierte p-Werte (FDR, Benjamini-Hochberg) hinzu
t_test_results$adj_p_value <- p.adjust(t_test_results$p_value, method = "BH")

significant_proteins <- t_test_results[t_test_results$adj_p_value < 0.05, ]
```

```{r}
summary(ctrl_norm_mean[1:5, 1:25])
summary(rnase_norm_mean[1:5, 1:25])

apply(ctrl_norm_mean[ ,1:25], 1, var)  
apply(rnase_norm_mean[,1:25], 1, var)
```


###################################################################################################
###################################################################################################
###################################################################################################
* hier ruht unser Gaussian fit ˙◠˙

***********************************************************************************************************
T-Test (Bens)
***********************************************************************************************************

```{r}
df1 <- table.ctrl.fit[1:25] # Gruppe A
df2 <- table.rnase.fit[1:25] # Gruppe B

df_numeric1 <- as.data.frame(lapply(df1, function(x) as.numeric(as.character(x))))
df_numeric2 <- as.data.frame(lapply(df2, function(x) as.numeric(as.character(x))))

colnames(df_numeric1) <- colnames(table.ctrl.fit[1:25])
colnames(df_numeric2) <- colnames(table.rnase.fit[1:25])

rownames(df_numeric1) <- rownames(table.ctrl.fit[1:25])
rownames(df_numeric2) <- rownames(table.rnase.fit[1:25])

```

```{r}
# T-Test pro Reihenpaar
t_test_ergebnisse <- lapply(seq_len(nrow(df_numeric1)), function(i) {
  x <- as.numeric(df_numeric1[i, ])
  y <- as.numeric(df_numeric2[i, ])

  # Nur t-Test, wenn beide Gruppen mindestens 2 gültige Werte haben
  if (sum(!is.na(x)) >= 2 && sum(!is.na(y)) >= 2) {
    t_res <- t.test(x, y, paired = TRUE)
    data.frame(
      proteine = rownames(df_numeric1)[i],
      p_wert = t_res$p.value,
      mittelwert_df1 = mean(x, na.rm = TRUE),
      mittelwert_df2 = mean(y, na.rm = TRUE),
      t_wert = t_res$statistic,
      df = t_res$parameter
    )
  } else {
    NULL
  }
})

# Entferne NULLs (wo T-Test nicht möglich war)
t_test_ergebnisse <- Filter(Negate(is.null), t_test_ergebnisse)

# Ergebnisse zusammenführen
t_test_ergebnisse_df <- do.call(rbind, t_test_ergebnisse)

# Optional: Nach p-Wert sortieren
t_test_ergebnisse_df <- t_test_ergebnisse_df[order(t_test_ergebnisse_df$p_wert), ]

# Ausgabe
print(t_test_ergebnisse_df)
```

```{r}
list_significant_shift <- t_test_ergebnisse_df[t_test_ergebnisse_df$p_wert < 0.05, ]

# Beispiel: p-Wert zwischen 0.05 und 0.7
list_possible_shift <- t_test_ergebnisse_df[t_test_ergebnisse_df$p_wert > 0.05 & t_test_ergebnisse_df$p_wert < 0.7, ]


list_no_shift <- t_test_ergebnisse_df[ t_test_ergebnisse_df$p_wert > 0.7 , ]

# Nur Namen der Proteine
significant_shift_proteins <- list_significant_shift$zeile
possible_shift_proteins <- list_possible_shift$zeile
no_shift_proteins <- list_no_shift$zeile
```


***********************************************************************************************************
PCA
***********************************************************************************************************

```{r}
# Nur numerische Spalten behalten
pca_ctrl_numeric <- table.ctrl.fit[1:25, sapply(table.ctrl.fit, is.numeric)]
pca_rnase_numeric <- table.rnase.fit[1:25, sapply(table.rnase.fit, is.numeric)]

# Zeilen mit NAs entfernen
pca_ctrl_clean <- pca_ctrl_numeric[complete.cases(pca_ctrl_numeric), ]
pca_rnase_clean <- pca_rnase_numeric[complete.cases(pca_rnase_numeric), ]

pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)

# Einfaches 2D PCA-Plot
plot(pca_result_ctrl$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL")

plot(pca_result_rnase$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE")
```

```{r}
#chech which PCs have the most variance
summary(pca_result_ctrl)
summary(pca_result_rnase)
```

```{r}
#plot PC1 with PC3
plot(pca_result_ctrl$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL")

plot(pca_result_rnase$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE")


#plot PC2 with PC3
plot(pca_result_ctrl$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")

plot(pca_result_rnase$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE")
```
```{r}
# Namen der Zeilen in PCA müssen mit Protein-Namen übereinstimmen
# Setze z. B. signifikante auf "red"
highlight_proteine_significant <- list_significant_shift
highlight_proteine_possible <- possible_shift_proteins
highlight_proteine_no <- no_shift_proteins
```

```{r}
farben <- rep("grey", nrow(pca_result_ctrl$x))
farben[rownames(pca_result_ctrl$x[, 1:2]) %in% highlight_proteine_significant] <- "red"
farben[rownames(pca_result_ctrl$x[, 1:2]) %in% highlight_proteine_possible] <- "blue"
farben[rownames(pca_result_ctrl$x[, 1:2]) %in% highlight_proteine_no] <- "green"


plot(pca_result_ctrl$x[, 1:2], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_ctrl$x[,c(1, 3)], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_ctrl$x[,2:3], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)


plot(pca_result_rnase$x[,1:2], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_rnase$x[,c(1, 3)], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_rnase$x[,2:3], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
```
```{r}
# Reihennamen beider Tabellen
rows_ctrl_pca <- rownames(table.ctrl.fit)
rows_rnase_pca <- rownames(table.rnase.fit)
no_shift_proteins <- list_no_shift$zeile

# Reihen, die NICHT in table2 vorkommen (nur die willst du behalten)
rows_to_keep_ctrl_no_shift <- setdiff(rows_ctrl_pca, no_shift_proteins)
rows_to_keep_rnase_no_shift <- setdiff(rows_rnase_pca, no_shift_proteins)

# table1 ohne die gemeinsamen Reihen
ctrl_mean_filtert_final_pca <- table.ctrl.fit[rows_to_keep_ctrl_no_shift,]
rnase_mean_filtert_final_pca <- table.rnase.fit[rows_to_keep_rnase_no_shift,]
```


```{r}
# Nur numerische Spalten behalten
pca_ctrl_numeric_sig <- ctrl_mean_filtert_final_pca[1:251, sapply(ctrl_mean_filtert_final_pca, is.numeric)]
pca_rnase_numeric_sig <- rnase_mean_filtert_final_pca[1:251, sapply(rnase_mean_filtert_final_pca, is.numeric)]

# Zeilen mit NAs entfernen
pca_ctrl_clean_sig <- pca_ctrl_numeric_sig[complete.cases(pca_ctrl_numeric_sig), ]
pca_rnase_clean_sig <- pca_rnase_numeric_sig[complete.cases(pca_rnase_numeric_sig), ]

# Funktion: Entferne Spalten ohne Varianz
remove_const_cols <- function(df) {
  df[, apply(df, 2, function(col) sd(col, na.rm = TRUE) > 0)]
}

# Anwenden
pca_ctrl_clean_sig <- remove_const_cols(pca_ctrl_clean_sig)
pca_rnase_clean_sig <- remove_const_cols(pca_rnase_clean_sig)


pca_result_ctrl_sig <- prcomp(pca_ctrl_clean_sig, center = TRUE, scale. = TRUE, )
pca_result_rnase_sig <- prcomp(pca_rnase_clean_sig, center = TRUE, scale. = TRUE)
```

```{r}
farben <- rep("grey", nrow(pca_result_ctrl_sig$x))
farben[rownames(pca_result_ctrl_sig$x[, 1:2]) %in% highlight_proteine_significant] <- "red"
farben[rownames(pca_result_ctrl_sig$x[, 1:2]) %in% highlight_proteine_possible] <- "blue"
farben[rownames(pca_result_ctrl_sig$x[, 1:2]) %in% highlight_proteine_no] <- "green"


plot(pca_result_ctrl_sig$x[, 1:2], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_ctrl_sig$x[,c(1, 3)], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_ctrl_sig$x[,2:3], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)


plot(pca_result_rnase_sig$x[,1:2], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_rnase_sig$x[,c(1, 3)], col = farben, pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)

plot(pca_result_rnase_sig$x[,2:3], col = farben, pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
```

```{r}
plot(pca_result_ctrl_sig, type = "l", main = "Elbow-Plot CTRL")
plot(pca_result_rnase_sig, type = "l", main = "Elbow-Plot RNASE")
```

```{r}
pca_ctrl_pc1_pc2 <- as.data.frame(pca_result_ctrl_sig$x[, 1:2])
pca_ctrl_pc1_pc3 <- as.data.frame(pca_result_ctrl_sig$x[, c(1,3)])
pca_ctrl_pc2_pc3 <- as.data.frame(pca_result_ctrl_sig$x[, 2:3])

pca_rnase_pc1_pc2 <- as.data.frame(pca_result_rnase_sig$x[, 1:2])
pca_rnase_pc1_pc3 <- as.data.frame(pca_result_rnase_sig$x[, c(1,3)])
pca_rnase_pc2_pc3 <- as.data.frame(pca_result_rnase_sig$x[, 2:3])
```

***********************************************************************************************************
kmeans Clustering
***********************************************************************************************************

```{r}
library(factoextra)

fviz_nbclust(pca_ctrl_pc1_pc2, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc1_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc2_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC2/PC3") +
  theme_minimal()

fviz_nbclust(pca_rnase_pc1_pc2, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC3") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc2_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC2/PC3") +
  theme_minimal() 
```

```{r}
km_result_ctrl<- kmeans(pca_ctrl_pc1_pc2, centers = 2)

km_result_rnase<- kmeans(pca_rnase_pc1_pc2, centers = 2)
```

```{r}
library(factoextra)

# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL")

fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc2,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der RNASE")

fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der RNASE")
fviz_cluster(km_result_rnase, data = pca_rnase_pc2_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der RNASE")
```

