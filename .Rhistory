peaks <- c(peaks, i + 1)
}
}
# part added to deal with plateau
# Ergibt diese Operation überhaupt Sinn, Plateaus haben ja auch nur einen Hochpunkt, und alle anderen (ähnlichen) werden doch ohnehin nicht erkannt werden?
n = length(peaks)
if (n>1) {
rem <- numeric(0)
for (i in 1:(n-1)) { if  ((peaks[i]+1) == peaks[(i+1)]) {rem <- c(rem, peaks[i+1]) } }
for (i in 1:(n-1)) { if  ((peaks[i]+2) == peaks[(i+1)]) {rem <- c(rem, peaks[i+1]) } }
peaks <- peaks[! peaks%in% rem]
}
# part added to deal with the 1st and 25th values, in case they are max
if ( sum(x[1]>x[2:(window+1)]) == 2 ) {peaks <- c(peaks, 1)}
if ( sum(x[25]>x[24:(25-window)]) == 2 ) {peaks <- c(peaks, 25)}
peaks <- unlist(peaks)
peaks
#return(peaks)
}
#Test, ob die Peak-Positionen richtig ausgegeben werden
#test_vec2 = as.numeric(ctrl_norm_mean[4, ])
#find_peaks(test_vec2)
#z = c(30, 2, 2, 2, 2, 2, 5, 4, 3, 2, 2, 2, 2, 2, 31, 30, 31, 32, 2, 2, 2, 2, 2, 2, 30)
#find_peaks(z)
# Apply the function to the data set and retrieve the values
# restriction to values above an absolut threshold of 2%
# New column: "maxima" (column 26)
ctrl_norm_mean$maxima <- apply(ctrl_norm_mean, 1, function(x) {
list <- find_peaks(x)
list <- list[x[list] > 2]
list <- unlist(list)
list
})
rnase_norm_mean$maxima <- apply(rnase_norm_mean, 1, function(x) {
list <- find_peaks(x)
list <- list[x[list] > 2]
list <- unlist(list)
list
})
# Identify the RNAse fractions with signal intensity > 2%.
# Create a new data frame containing 0 (= this fraction value was ≤2% ) and 1 (= this fraction value was >2%.), as well as the intensity maxima.
# The two new data frames are created, rnase_3 and ctrl_3, as copies of the previously calculated, normalized mean tables (*_norm_mean).
rnase_3 <- rnase_norm_mean
# Compare each value in columns 1 to 25 (the fractions) of the rnase_norm_mean dataframe with the threshold of 2%.
# Convert TRUE to 1 and FALSE to 0.
rnase_3[1:25] <- (rnase_norm_mean[1:25] > 2)*1
# Identify the CTRL fractions with signal intensity > 2%.
# Create a new data frames containing 0 / 1, as well as the intensity maxima.
ctrl_3 <- ctrl_norm_mean
ctrl_3[1:25] <- (ctrl_norm_mean[1:25] > 2)*1
# Remove and exclude 3 fractions left and right of each peak (7 in total) from the shoulder search.
# Wie können überhaupt noch Werte auf "1" bleiben, sie können natürlich mehr als 2% haben, aber einer hätte als Maximum erkannt werden müssen, und somit hätten alle anderen drum herum gestrichen werden müssen?!
th_max_reg_simple <- function(x) {
peaks <- as.numeric(unlist(x$maxima)) # Convert the maxima column from *_norm_mean to a numeric vector.
mask <- rep(1, 25)
for (peak in peaks) { # peak = current peak value, peaks = detected maxima (column 26)
if (peak > 0) {
left <- max(1, peak - 3)
right <- min(25, peak + 3) # For each peak, the range from peak–3 to peak+3 is calculated.
mask[left:right] <- 0 # These 7 fractions (the peak itself and 3 before & after it) are masked out by setting their positions in the mask to 0.
}
}
x_values <- as.numeric(x[1:25]) # because $maxima contained characters.
x_values <- x_values * mask # Fractions with mask = 1 are retained. Fractions with mask = 0 are set to 0.
return(x_values)
}
# Apply the function row by row to the entire rnase_3 or ctrl_3 DataFrame.
rnase_3[1:25] <- t(apply(rnase_3, 1, th_max_reg_simple))
ctrl_3[1:25]  <- t(apply(ctrl_3, 1, th_max_reg_simple))
# Detect "shoulder regions"
# Define a function that identifies signal regions where there are at least 4 consecutive fractions with an intensity above 2% using the data frames rnase_3 and ctrl_3.
# select the middle of it
# Apply on the whole dataframe
peaks_regions = function(x) {
rle_result = rle(as.numeric(x[1:25])) # rle() finds all consecutive equal values -> $lengths and $values
#Find positions of all blocks of ones with length ≥4. These blocks are considered “shoulder regions”.
peak_blocks = which(rle_result$values == 1 & rle_result$lengths >= 4)
#If there are no such blocks of length >4, return an empty vector
if (length(peak_blocks) == 0) {
return(numeric(0))
}
#Calculate estimate middle for the peak blocks
peak_positions = numeric(length(peak_blocks))
for(i in seq_along(peak_blocks)) {
#Position of the end of the respective block
end_of_block = sum(rle_result$lengths[1:peak_blocks[i]])
#Calculate half length (middle) of the block
half_length = floor(rle_result$lengths[peak_blocks[i]] /2)
#Middle position of the shoulder
peak_positions[i] = end_of_block - half_length
}
return(peak_positions)
}
# Calculate the positions of the "shoulders" for each protein row, i.e. regions with ≥4 consecutive fractions with signal >2%
# Save the shoulder positions as a new column called peaks in the respective data frames rnase_3 and ctrl_3.
# New column: "peaks" (column 27)
rnase_3$peaks <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_3$peaks <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )
# Calculate the total of all relevant signal maxima (real peaks and shoulders) for each protein row in the dataframe
# New column: "ctrl_max" and "rnase_max" (column 28) respectively
rnase_3$rnase_max <- apply(rnase_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$maxima)) # ls_max = numerical vector with the peak positions of this protein
ls_peaks <- as.numeric(unlist(x$peaks))
rnase_max <- c(ls_max, ls_peaks) # Combine to common vector.
rnase_max <- unlist(rnase_max)
rnase_max <- rnase_max[rnase_max!=0] # Remove all 0 entries from the result vector, as these do not represent real signals.
rnase_max <- sort(rnase_max, decreasing = FALSE) # Sort all peak and shoulder positions in ascending order (1 → 25)
if (length(rnase_max) == 0) {0} else {rnase_max} # If there are no peaks or shoulders, 0 (as a placeholder) is stored.
})
ctrl_3$ctrl_max <- apply(ctrl_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$maxima))
ls_peaks <- as.numeric(unlist(x$peaks))
ctrl_max <- c(ls_max, ls_peaks)
ctrl_max <- unlist(ctrl_max)
ctrl_max <- ctrl_max[ctrl_max!=0]
ctrl_max <- sort(ctrl_max, decreasing = FALSE)
if (length(ctrl_max) == 0) {0} else {ctrl_max}
})
# Determine the number of maxima per protein row in the rnase_3 and ctrl_3 data tables – but only if there are any.
# New column: "nb_max" (column 29)
rnase_3$nb_max <- apply(rnase_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$rnase_max))
n = length(ls_max) # => Answers: How many peaks (maxima and shoulders) does this protein have?
if (sum(ls_max) == 0) {0} else {n} # If TRUE, then the result should be 0, instead of length(ls_max), which would then be 1.
})
ctrl_3$nb_max <- apply(ctrl_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$ctrl_max))
n = length(ls_max)
if (sum(ls_max) == 0) {0} else {n}
})
rnase_3$only_max <- apply(rnase_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$maxima))
n = length(ls_max)
if (sum(ls_max) == 0) {0} else {n}
})
ctrl_3$only_max <- apply(ctrl_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$maxima))
n = length(ls_max)
if (sum(ls_max) == 0) {0} else {n}
})
ctrl_3_selection = ctrl_3
rnase_3_selection = rnase_3
ctrl_3_same_maxima_amount = ctrl_3
rnase_3_same_maxima_amount = rnase_3
diff_index = ctrl_3_selection$only_max != rnase_3_selection$only_max
#diff_index_only_maxima = ctrl_3_selection$only_max != rnase_3_selection$only_max
same_index = ctrl_3_same_maxima_amount$only_max == rnase_3_same_maxima_amount$only_max
ctrl_3_selection = ctrl_3_selection[diff_index, ]
rnase_3_selection = rnase_3_selection[diff_index, ]
ctrl_3_same_maxima_amount = ctrl_3_same_maxima_amount[same_index, ]
rnase_3_same_maxima_amount = rnase_3_same_maxima_amount[same_index, ]
#1333 Proteine zeigen eine unterschiedliche Anzahl an Peaks, hierbei sollte allerdings bedacht werden, dass die Anzahl der Peaks auch von den Schultern abhängt. Wir dachten uns aber, dass das Entstehen einer Schulter auch bedeutet, dass sich zwischen beiden Versuchsansätzen etwas geändert hatte, und somit eventuell eine RNA-abhängigkeit vorliegt. Bei 1253 alleine Unterschied sich die Anzahl der tatsächlichen Maxima unabhängig von den Schultern
ctrl_maxima_list <- ctrl_3_same_maxima_amount$maxima
rnase_maxima_list <- rnase_3_same_maxima_amount$maxima
length(ctrl_maxima_list)
length(rnase_maxima_list)
#Liste zum Speichern der Treffer
verschobene_proteine <- c()
protein_ids <- rownames(ctrl_3_same_maxima_amount)
#Für jede Zeile (jedes Protein) prüfen
for (i in seq_along(ctrl_maxima_list)) {
ctrl_maxima <- as.numeric(unlist(ctrl_maxima_list[[i]]))
rnase_maxima <- as.numeric(unlist(rnase_maxima_list[[i]]))
if (length(ctrl_maxima) > 0 && length(ctrl_maxima) == length(rnase_maxima)) { #hab hier noch leere Vektoren ausgeschlossen, wegen Fehlermeldung, vorher: if (length(ctrl_maxima) == length(rnase_maxima))
max_diff <- max(abs(ctrl_maxima - rnase_maxima))
if (max_diff >= 2) {
verschobene_proteine <- c(verschobene_proteine, protein_ids[i])
}
}
}
ctrl_3_same_maxima_amount = ctrl_3_same_maxima_amount[verschobene_proteine, ]
rnase_3_same_maxima_amount = rnase_3_same_maxima_amount[verschobene_proteine, ]
Denkfehler: Die Daten dürfen anscheinend nicht normalisiert, gerundet und brauchen alle 3 Replikate?
list_significant_shift <- t_test_ergebnisse_df[t_test_ergebnisse_df$p_wert < 0.05, ]
# Beispiel: p-Wert zwischen 0.05 und 0.7
list_possible_shift <- t_test_ergebnisse_df[t_test_ergebnisse_df$p_wert > 0.05 & t_test_ergebnisse_df$p_wert < 0.7, ]
list_no_shift <- t_test_ergebnisse_df[ t_test_ergebnisse_df$p_wert > 0.7 , ]
# Nur Namen der Proteine
significant_shift_proteins <- list_significant_shift$zeile
possible_shift_proteins <- list_possible_shift$zeile
no_shift_proteins <- list_no_shift$zeile
list_significant_shift <- t_test_ergebnisse_df[t_test_ergebnisse_df$p_wert < 0.05, ]
# Beispiel: p-Wert zwischen 0.05 und 0.7
list_possible_shift <- t_test_ergebnisse_df[t_test_ergebnisse_df$p_wert > 0.05 & t_test_ergebnisse_df$p_wert < 0.7, ]
list_no_shift <- t_test_ergebnisse_df[ t_test_ergebnisse_df$p_wert > 0.7 , ]
# Nur Namen der Proteine
significant_shift_proteins <- list_significant_shift$zeile
possible_shift_proteins <- list_possible_shift$zeile
no_shift_proteins <- list_no_shift$zeile
# Nur numerische Spalten behalten
pca_ctrl_numeric <- table.ctrl.fit[1:25, sapply(table.ctrl.fit, is.numeric)]
pca_rnase_numeric <- table.rnase.fit[1:25, sapply(table.rnase.fit, is.numeric)]
# Zeilen mit NAs entfernen
pca_ctrl_clean <- pca_ctrl_numeric[complete.cases(pca_ctrl_numeric), ]
pca_rnase_clean <- pca_rnase_numeric[complete.cases(pca_rnase_numeric), ]
pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
# Einfaches 2D PCA-Plot
plot(pca_result_ctrl$x[,1:2], col = "blue", pch = 16,
xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL")
plot(pca_result_rnase$x[,1:2], col = "blue", pch = 16,
xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE")
# Nur numerische Spalten behalten
pca_ctrl_numeric <- ctrl_norm_mean[1:25, sapply(ctrl_norm_mean, is.numeric)]
pca_rnase_numeric <- rnase_norm_mean[1:25, sapply(rnase_norm_mean, is.numeric)]
# Zeilen mit NAs entfernen
pca_ctrl_clean <- pca_ctrl_numeric[complete.cases(pca_ctrl_numeric), ]
pca_rnase_clean <- pca_rnase_numeric[complete.cases(pca_rnase_numeric), ]
pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
# Einfaches 2D PCA-Plot
plot(pca_result_ctrl$x[,1:2], col = "blue", pch = 16,
xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL")
plot(pca_result_rnase$x[,1:2], col = "blue", pch = 16,
xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE")
#chech which PCs have the most variance
summary(pca_result_ctrl)
summary(pca_result_rnase)
#plot PC1 with PC3
plot(pca_result_ctrl$x[,c(1, 3)], col = "blue", pch = 16,
xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL")
plot(pca_result_rnase$x[,c(1, 3)], col = "blue", pch = 16,
xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE")
#plot PC2 with PC3
plot(pca_result_ctrl$x[,2:3], col = "blue", pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
plot(pca_result_rnase$x[,2:3], col = "blue", pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE")
# Namen der Zeilen in PCA müssen mit Protein-Namen übereinstimmen
# Setze z. B. signifikante auf "red"
highlight_proteine_significant <- list_significant_shift
highlight_proteine_possible <- possible_shift_proteins
highlight_proteine_no <- no_shift_proteins
farben <- rep("grey", nrow(pca_result_ctrl$x))
farben[rownames(pca_result_ctrl$x[, 1:2]) %in% highlight_proteine_significant] <- "red"
farben[rownames(pca_result_ctrl$x[, 1:2]) %in% highlight_proteine_possible] <- "blue"
farben[rownames(pca_result_ctrl$x[, 1:2]) %in% highlight_proteine_no] <- "green"
plot(pca_result_ctrl$x[, 1:2], col = farben, pch = 16,
xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
plot(pca_result_ctrl$x[,c(1, 3)], col = farben, pch = 16,
xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
plot(pca_result_ctrl$x[,2:3], col = farben, pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
plot(pca_result_rnase$x[,1:2], col = farben, pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
plot(pca_result_rnase$x[,c(1, 3)], col = farben, pch = 16,
xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
plot(pca_result_rnase$x[,2:3], col = farben, pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
# Reihennamen beider Tabellen
rows_ctrl_pca <- rownames(table.ctrl.fit)
rows_rnase_pca <- rownames(table.rnase.fit)
no_shift_proteins <- list_no_shift$zeile
# Reihen, die NICHT in table2 vorkommen (nur die willst du behalten)
rows_to_keep_ctrl_no_shift <- setdiff(rows_ctrl_pca, no_shift_proteins)
rows_to_keep_rnase_no_shift <- setdiff(rows_rnase_pca, no_shift_proteins)
# table1 ohne die gemeinsamen Reihen
ctrl_mean_filtert_final_pca <- table.ctrl.fit[rows_to_keep_ctrl_no_shift,]
rnase_mean_filtert_final_pca <- table.rnase.fit[rows_to_keep_rnase_no_shift,]
# Nur numerische Spalten behalten
pca_ctrl_numeric_sig <- ctrl_mean_filtert_final_pca[1:251, sapply(ctrl_mean_filtert_final_pca, is.numeric)]
pca_rnase_numeric_sig <- rnase_mean_filtert_final_pca[1:251, sapply(rnase_mean_filtert_final_pca, is.numeric)]
# Zeilen mit NAs entfernen
pca_ctrl_clean_sig <- pca_ctrl_numeric_sig[complete.cases(pca_ctrl_numeric_sig), ]
pca_rnase_clean_sig <- pca_rnase_numeric_sig[complete.cases(pca_rnase_numeric_sig), ]
# Funktion: Entferne Spalten ohne Varianz
remove_const_cols <- function(df) {
df[, apply(df, 2, function(col) sd(col, na.rm = TRUE) > 0)]
}
# Anwenden
pca_ctrl_clean_sig <- remove_const_cols(pca_ctrl_clean_sig)
pca_rnase_clean_sig <- remove_const_cols(pca_rnase_clean_sig)
pca_result_ctrl_sig <- prcomp(pca_ctrl_clean_sig, center = TRUE, scale. = TRUE, )
pca_result_rnase_sig <- prcomp(pca_rnase_clean_sig, center = TRUE, scale. = TRUE)
farben <- rep("grey", nrow(pca_result_ctrl_sig$x))
farben[rownames(pca_result_ctrl_sig$x[, 1:2]) %in% highlight_proteine_significant] <- "red"
farben[rownames(pca_result_ctrl_sig$x[, 1:2]) %in% highlight_proteine_possible] <- "blue"
farben[rownames(pca_result_ctrl_sig$x[, 1:2]) %in% highlight_proteine_no] <- "green"
plot(pca_result_ctrl_sig$x[, 1:2], col = farben, pch = 16,
xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
plot(pca_result_ctrl_sig$x[,c(1, 3)], col = farben, pch = 16,
xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
plot(pca_result_ctrl_sig$x[,2:3], col = farben, pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
plot(pca_result_rnase_sig$x[,1:2], col = farben, pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
plot(pca_result_rnase_sig$x[,c(1, 3)], col = farben, pch = 16,
xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
plot(pca_result_rnase_sig$x[,2:3], col = farben, pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
legend("topright", legend = c("Significant Shift","Possible Shift","No Shift"), col = c("red", "blue", "green"), pch = 16)
plot(pca_result_ctrl_sig, type = "l", main = "Elbow-Plot CTRL")
plot(pca_result_rnase_sig, type = "l", main = "Elbow-Plot RNASE")
pca_ctrl_pc1_pc2 <- as.data.frame(pca_result_ctrl_sig$x[, 1:2])
pca_ctrl_pc1_pc3 <- as.data.frame(pca_result_ctrl_sig$x[, c(1,3)])
pca_ctrl_pc2_pc3 <- as.data.frame(pca_result_ctrl_sig$x[, 2:3])
pca_rnase_pc1_pc2 <- as.data.frame(pca_result_rnase_sig$x[, 1:2])
pca_rnase_pc1_pc3 <- as.data.frame(pca_result_rnase_sig$x[, c(1,3)])
pca_rnase_pc2_pc3 <- as.data.frame(pca_result_rnase_sig$x[, 2:3])
library(factoextra)
fviz_nbclust(pca_ctrl_pc1_pc2, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode CTRL PC1/PC2") +
theme_minimal()
fviz_nbclust(pca_ctrl_pc1_pc3, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode CTRL PC1/PC2") +
theme_minimal()
fviz_nbclust(pca_ctrl_pc2_pc3, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode CTRL PC2/PC3") +
theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc2, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode RNASE PC1/PC2") +
theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc3, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode RNASE PC1/PC3") +
theme_minimal()
fviz_nbclust(pca_rnase_pc2_pc3, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode RNASE PC2/PC3") +
theme_minimal()
km_result_ctrl<- kmeans(pca_ctrl_pc1_pc2, centers = 2)
km_result_rnase<- kmeans(pca_rnase_pc1_pc2, centers = 2)
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
fviz_cluster(km_result_rnase, data = pca_rnase_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
km_result_ctrl_pc1_pc2<- kmeans(pca_ctrl_pc1_pc2, centers = 3)
km_result_ctrl_pc1_pc3<- kmeans(pca_ctrl_pc1_pc3, centers = 3)
km_result_ctrl_pc2_pc3<- kmeans(pca_ctrl_pc2_pc3, centers = 3)
km_result_rnase_pc1_pc2<- kmeans(pca_rnase_pc1_pc2, centers = 3)
km_result_rnase_pc1_pc3<- kmeans(pca_rnase_pc1_pc3, centers = 3)
km_result_rnase_pc2_pc3<- kmeans(pca_rnase_pc2_pc3, centers = 3)
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
fviz_cluster(km_result_rnase, data = pca_rnase_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl_pc1_pc2, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl_pc1_pc3, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl_pc2_pc3, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_rnase_pc1_pc2, data = pca_rnase_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
fviz_cluster(km_result_rnase_pc1_pc3, data = pca_rnase_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
fviz_cluster(km_result_rnase_pc2_pc3, data = pca_rnase_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
View(ctrl_mean_filtert_final)
ctrl_maxima_list <- ctrl_3_same_maxima_amount$maxima
rnase_maxima_list <- rnase_3_same_maxima_amount$maxima
length(ctrl_maxima_list)
length(rnase_maxima_list)
#Liste zum Speichern der Treffer
verschobene_proteine <- c()
protein_ids <- rownames(ctrl_3_same_maxima_amount)
#Für jede Zeile (jedes Protein) prüfen
for (i in seq_along(ctrl_maxima_list)) {
ctrl_maxima <- as.numeric(unlist(ctrl_maxima_list[[i]]))
rnase_maxima <- as.numeric(unlist(rnase_maxima_list[[i]]))
if (length(ctrl_maxima) > 0 && length(ctrl_maxima) == length(rnase_maxima)) { #hab hier noch leere Vektoren ausgeschlossen, wegen Fehlermeldung, vorher: if (length(ctrl_maxima) == length(rnase_maxima))
max_diff <- max(abs(ctrl_maxima - rnase_maxima))
if (max_diff >= 2) {
verschobene_proteine <- c(verschobene_proteine, protein_ids[i])
}
}
}
ctrl_3_same_maxima_amount = ctrl_3_same_maxima_amount[verschobene_proteine, ]
rnase_3_same_maxima_amount = rnase_3_same_maxima_amount[verschobene_proteine, ]
#Define the rownames of the tables as a new varible
rows_rnase1 <- rownames(table.rnase.fit)
rows_rnase2 <- rownames(ctrl_3_same_maxima_amount)
rows_ctrl1 <- rownames(table.ctrl.fit)
rows_ctrl2 <- rownames(rnase_3_same_maxima_amount)
#Search the rows with the same
rows_to_keep_rnase_rnase <- setdiff(rows_rnase1, rows_rnase2)
rows_to_keep_rnase_ctrl <- setdiff(rows_rnase1, rows_ctrl2)
rows_to_keep_ctrl_rnase <- setdiff(rows_ctrl1, rows_rnase2)
rows_to_keep_ctrl_ctrl <- setdiff(rows_ctrl1, rows_ctrl2)
# table1 ohne die gemeinsamen Reihen. Damit sind alle Proteine in dieser Tabelle gegaust
rnase_mean_filtert <- rnase_mean[rows_to_keep_rnase_rnase,]
#Define the rownames of the tables as a new varible
rows_rnase1 <- rownames(table.rnase.fit)
rows_rnase2 <- rownames(ctrl_3_same_maxima_amount)
rows_ctrl1 <- rownames(table.ctrl.fit)
rows_ctrl2 <- rownames(rnase_3_same_maxima_amount)
#Search the rows with the same
rows_to_keep_rnase_rnase <- setdiff(rows_rnase1, rows_rnase2)
rows_to_keep_rnase_ctrl <- setdiff(rows_rnase1, rows_ctrl2)
rows_to_keep_ctrl_rnase <- setdiff(rows_ctrl1, rows_rnase2)
rows_to_keep_ctrl_ctrl <- setdiff(rows_ctrl1, rows_ctrl2)
# table1 ohne die gemeinsamen Reihen. Damit sind alle Proteine in dieser Tabelle gegaust
table.rnase.fit <- table.rnase.fit[rows_to_keep_rnase_rnase,]
table.rnase.fit <- table.rnase.fit[rows_to_keep_rnase_ctrl,]
table.ctrl.fit <- table.ctrl.fit[rows_to_keep_ctrl_rnase,]
table.ctrl.fit <- table.ctrl.fit[rows_to_keep_ctrl_ctrl,]
df1 <- table.ctrl.fit[1:25] # Gruppe A
df2 <- table.rnase.fit[1:25] # Gruppe B
df_numeric1 <- as.data.frame(lapply(df1, function(x) as.numeric(as.character(x))))
df_numeric2 <- as.data.frame(lapply(df2, function(x) as.numeric(as.character(x))))
colnames(df_numeric1) <- colnames(table.ctrl.fit[1:25])
colnames(df_numeric2) <- colnames(table.rnase.fit[1:25])
rownames(df_numeric1) <- rownames(table.ctrl.fit[1:25])
rownames(df_numeric2) <- rownames(table.rnase.fit[1:25])
# T-Test pro Reihenpaar
t_test_ergebnisse <- lapply(seq_len(nrow(df_numeric1)), function(i) {
x <- as.numeric(df_numeric1[i, ])
y <- as.numeric(df_numeric2[i, ])
# Nur t-Test, wenn beide Gruppen mindestens 2 gültige Werte haben
if (sum(!is.na(x)) >= 2 && sum(!is.na(y)) >= 2) {
t_res <- t.test(x, y, paired = TRUE)
data.frame(
proteine = rownames(df_numeric1)[i],
p_wert = t_res$p.value,
mittelwert_df1 = mean(x, na.rm = TRUE),
mittelwert_df2 = mean(y, na.rm = TRUE),
t_wert = t_res$statistic,
df = t_res$parameter
)
} else {
NULL
}
})
# Entferne NULLs (wo T-Test nicht möglich war)
t_test_ergebnisse <- Filter(Negate(is.null), t_test_ergebnisse)
# Ergebnisse zusammenführen
t_test_ergebnisse_df <- do.call(rbind, t_test_ergebnisse)
# Optional: Nach p-Wert sortieren
t_test_ergebnisse_df <- t_test_ergebnisse_df[order(t_test_ergebnisse_df$p_wert), ]
# Ausgabe
print(t_test_ergebnisse_df)
row_data3 <- as.numeric(table.ctrl.fit["ALG1_HUMAN", 1:25 ])
row_data4 <- as.numeric(table.rnase.fit["ALG1_HUMAN",1:25 ])
# Plot
plot(row_data4,
type = "l",                # Linienplot
main = "Plot for PRKDC_HUMAN",
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2)
lines(row_data3,
type = "l",
col = "red",
lwd = 2)
