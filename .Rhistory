}
}
#Flattens q (vector with parameters)into numeric vector, removes list
q <- unlist(q)
#Checks is q is a single numeric vector (scalar)
if (length(q) == 1 && is.numeric(q)) {
if (q > 1000) {
0
} else {
as.numeric(q)
}
} else {
0
}
#Applies function gauss_fit_res to each element in second dimension (column) of vect, using ctrl_3 and norm_tables.ctrl$ctrl1 as additional arguments. The result of each function is stored as a list in a new column named fit_res in the data frame table.ctrl1.fit
table.ctrl1.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, ctrl_3, norm_tables.ctrl$ctrl1) })
table.ctrl2.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, ctrl_3, norm_tables.ctrl$ctrl2) })
table.ctrl3.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, ctrl_3, norm_tables.ctrl$ctrl3) })
#Same for RNASE
table.rnase1.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, rnase_3, norm_tables.rnase$rnase1) })
table.rnase2.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, rnase_3, norm_tables.rnase$rnase2) })
table.rnase3.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, rnase_3, norm_tables.rnase$rnase3) })
#Fit is normalized to 100
table.ctrl1.fit.norm <- table.ctrl1.fit[1:25] * 100 / rowSums(table.ctrl1.fit[1:25])
table.ctrl2.fit.norm <- table.ctrl2.fit[1:25] * 100 / rowSums(table.ctrl2.fit[1:25])
table.ctrl3.fit.norm <- table.ctrl3.fit[1:25] * 100 / rowSums(table.ctrl3.fit[1:25])
table.rnase1.fit.norm <- table.rnase1.fit[1:25] * 100 / rowSums(table.rnase1.fit[1:25])
table.rnase2.fit.norm <- table.rnase2.fit[1:25] * 100 / rowSums(table.rnase2.fit[1:25])
table.rnase3.fit.norm <- table.rnase3.fit[1:25] * 100 / rowSums(table.rnase3.fit[1:25])
#Nas/NaNs are replaced with 0
table.ctrl1.fit.norm <- rapply(table.ctrl1.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace")
table.ctrl2.fit.norm <- rapply(table.ctrl2.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.ctrl3.fit.norm <- rapply(table.ctrl3.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.rnase1.fit.norm <- rapply(table.rnase1.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.rnase2.fit.norm <- rapply(table.rnase2.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.rnase3.fit.norm <- rapply(table.rnase3.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.ctrl1.fit.norm <- rapply(table.ctrl1.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace")
table.ctrl2.fit.norm <- rapply(table.ctrl2.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.ctrl3.fit.norm <- rapply(table.ctrl3.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.rnase1.fit.norm <- rapply(table.rnase1.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.rnase2.fit.norm <- rapply(table.rnase2.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.rnase3.fit.norm <- rapply(table.rnase3.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
#Columns are added to nb_max, the tables with the fitted values
table.ctrl1.fit.norm$nb_max <- ctrl_3$nb_max
table.ctrl2.fit.norm$nb_max <- ctrl_3$nb_max
table.ctrl3.fit.norm$nb_max <- ctrl_3$nb_max
table.rnase1.fit.norm$nb_max <- rnase_3$nb_max
table.rnase2.fit.norm$nb_max <- rnase_3$nb_max
table.rnase3.fit.norm$nb_max <- rnase_3$nb_max
#Same for fit_param
table.ctrl1.fit.norm$fit_param <- table.ctrl1.fit$fit_param
table.ctrl2.fit.norm$fit_param <- table.ctrl2.fit$fit_param
table.ctrl3.fit.norm$fit_param <- table.ctrl3.fit$fit_param
table.rnase1.fit.norm$fit_param <- table.rnase1.fit$fit_param
table.rnase2.fit.norm$fit_param <- table.rnase2.fit$fit_param
table.rnase3.fit.norm$fit_param <- table.rnase3.fit$fit_param
#Same for fit_res
table.ctrl1.fit.norm$fit_res <- table.ctrl1.fit$fit_res
table.ctrl2.fit.norm$fit_res <- table.ctrl2.fit$fit_res
table.ctrl3.fit.norm$fit_res <- table.ctrl3.fit$fit_res
table.rnase1.fit.norm$fit_res <- table.rnase1.fit$fit_res
table.rnase2.fit.norm$fit_res <- table.rnase2.fit$fit_res
table.rnase3.fit.norm$fit_res <- table.rnase3.fit$fit_res
# Uses function check_sum
table.ctrl1.fit.norm$check_sum <- table.ctrl1.fit$check_sum
table.ctrl2.fit.norm$check_sum <- table.ctrl2.fit$check_sum
table.ctrl3.fit.norm$check_sum <- table.ctrl3.fit$check_sum
table.rnase1.fit.norm$check_sum <- table.rnase1.fit$check_sum
table.rnase2.fit.norm$check_sum <- table.rnase2.fit$check_sum
table.rnase3.fit.norm$check_sum <- table.rnase3.fit$check_sum
#Function fine_fit(fit) generates Gaussian mixture curve based on parameter vector 6. Supports 6 Gaussian components and returns the normalized values of the resulting curve over the interval from 0 to 25 in 0.1 increments.
fine_fit <- function(fit)			{
#Creates output data structure with sequence from 0 to 25, 0.1 steps
dffit <- data.frame(y=seq(0, 25, 0.1))
z <- round(seq(0, 25, 0.1), digits=1)
#Gives number of gaussians, as each gaussian is defined by three parameters (c, mean, sigma)
n <- length(fit)/3
#If no parameters are provided, set all output values to 0
if (n==0) {dffit$df.y <- rep(0,251)} else {
#For each case from n==1 to n==6, the appropriate values from fit are extracted (C1, mean1, sigma1, C2, ...) Then it computes the sum of n Gaussian curves. The value is stored in dffit$df.y
if (n==1) {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
dffit$df.y <- C1 * exp(-(z-mean1)**2/(2 * sigma1**2))
} else {
if (n==2) {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
C2 <- q[4]
mean2 <- q[5]
sigma2 <- q[6]
dffit$df.y <- ( C1 * exp(-(z-mean1)**2/(2 * sigma1**2)) + C2 * exp(-(z-mean2)**2/(2 * sigma2**2)) )
} else {
if (n==3) {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
C2 <- q[4]
mean2 <- q[5]
sigma2 <- q[6]
C3 <- q[7]
mean3 <- q[8]
sigma3 <- q[9]
dffit$df.y <- ( C1 * exp(-(z-mean1)**2/(2 * sigma1**2)) + C2 * exp(-(z-mean2)**2/(2 * sigma2**2)) + C3 * exp(-(z-mean3)**2/(2 * sigma3**2)) )
} else {
if (n==4) {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
C2 <- q[4]
mean2 <- q[5]
sigma2 <- q[6]
C3 <- q[7]
mean3 <- q[8]
sigma3 <- q[9]
C4 <- q[10]
mean4 <- q[11]
sigma4 <- q[12]
dffit$df.y <- ( C1 * exp(-(z-mean1)**2/(2 * sigma1**2)) + C2 * exp(-(z-mean2)**2/(2 * sigma2**2)) + C3 * exp(-(z-mean3)**2/(2 * sigma3**2)) + C4 * exp(-(z-mean4)**2/(2 * sigma4**2)) )
} else {
if (n==5) {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
C2 <- q[4]
mean2 <- q[5]
sigma2 <- q[6]
C3 <- q[7]
mean3 <- q[8]
sigma3 <- q[9]
C4 <- q[10]
mean4 <- q[11]
sigma4 <- q[12]
C5 <- q[13]
mean5 <- q[14]
sigma5 <- q[15]
dffit$df.y <- ( C1 * exp(-(z-mean1)**2/(2 * sigma1**2)) + C2 * exp(-(z-mean2)**2/(2 * sigma2**2)) + C3 * exp(-(z-mean3)**2/(2 * sigma3**2)) + C4 * exp(-(z-mean4)**2/(2 * sigma4**2)) + C5 * exp(-(z-mean5)**2/(2 * sigma5**2)) )
} else {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
C2 <- q[4]
mean2 <- q[5]
sigma2 <- q[6]
C3 <- q[7]
mean3 <- q[8]
sigma3 <- q[9]
C4 <- q[10]
mean4 <- q[11]
sigma4 <- q[12]
C5 <- q[13]
mean5 <- q[14]
sigma5 <- q[15]
C6 <- q[16]
mean6 <- q[17]
sigma6 <- q[18]
dffit$df.y <- ( C1 * exp(-(z-mean1)**2/(2 * sigma1**2)) + C2 * exp(-(z-mean2)**2/(2 * sigma2**2)) + C3 * exp(-(z-mean3)**2/(2 * sigma3**2)) + C4 * exp(-(z-mean4)**2/(2 * sigma4**2)) + C5 * exp(-(z-mean5)**2/(2 * sigma5**2)) + C6 * exp(-(z-mean6)**2/(2 * sigma6**2)) )
}
}
}
}
}
}
#Result is scaled so that the area under the curve equals 100%. The *0.1 accounts for the integration step size since z increases in 0.1 increments
return(dffit$df.y * 100 / (sum(dffit$df.y) * 0.1))
}
# *0.1 is used to scale the resulting curve at the level of the normalized raw data. However, sum is 1000 and not 100.
#For each index t, fit_param are extracted and flattend. fine_fit() is applied to parameters returning vector of 251 normalized values (z= 0, 0.1,...)
table.ctrl1.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl1.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
#Assign row and column names
rownames(table.ctrl1.fit.fine) <- rownames(table.ctrl1.fit)
colnames(table.ctrl1.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.ctrl2.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl2.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.ctrl2.fit.fine) <- rownames(table.ctrl2.fit)
colnames(table.ctrl2.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.ctrl3.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl3.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.ctrl3.fit.fine) <- rownames(table.ctrl3.fit)
colnames(table.ctrl3.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.rnase1.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.rnase1.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.rnase1.fit.fine) <- rownames(table.rnase1.fit)
colnames(table.rnase1.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.rnase2.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.rnase2.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.rnase2.fit.fine) <- rownames(table.rnase2.fit)
colnames(table.rnase2.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.rnase3.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.rnase3.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.rnase3.fit.fine) <- rownames(table.rnase3.fit)
colnames(table.rnase3.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.ctrl.fit.fine <- (table.ctrl1.fit.fine + table.ctrl2.fit.fine + table.ctrl3.fit.fine) / 3
table.rnase.fit.fine <- (table.rnase1.fit.fine + table.rnase2.fit.fine + table.rnase3.fit.fine) / 3
row_data3 <- as.numeric(table.ctrl1.fit.fine["PRKDC_HUMAN", ])
row_data4 <- as.numeric(table.rnase1.fit.fine["PRKDC_HUMAN", ])
# Plot
plot(row_data4,
type = "l",                # Linienplot
main = "Plot for AHNK_HUMAN",
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2)
lines(row_data3,
type = "l",
col = "red",
lwd = 2)
df1 <- table.ctrl1.fit[1:25] # Gruppe A
df2 <- table.rnase1.fit[1:25] # Gruppe B
df_numeric1 <- as.data.frame(lapply(df1, function(x) as.numeric(as.character(x))))
df_numeric2 <- as.data.frame(lapply(df2, function(x) as.numeric(as.character(x))))
colnames(df_numeric1) <- colnames(table.ctrl1.fit[1:25])
colnames(df_numeric2) <- colnames(table.rnase1.fit[1:25])
rownames(df_numeric1) <- rownames(table.ctrl1.fit[1:25])
rownames(df_numeric2) <- rownames(table.rnase1.fit[1:25])
# T-Test pro Zeilenpaar
t_test_ergebnisse <- lapply(seq_len(nrow(df_numeric1)), function(i) {
x <- as.numeric(df_numeric1[i, ])
y <- as.numeric(df_numeric2[i, ])
# Nur t-Test, wenn beide Gruppen mindestens 2 gültige Werte haben
if (sum(!is.na(x)) >= 2 && sum(!is.na(y)) >= 2) {
t_res <- t.test(x, y)
data.frame(
zeile = rownames(df_numeric1)[i],
p_wert = t_res$p.value,
mittelwert_df1 = mean(x, na.rm = TRUE),
mittelwert_df2 = mean(y, na.rm = TRUE),
t_wert = t_res$statistic,
df = t_res$parameter
)
} else {
NULL
}
})
# Entferne NULLs (wo T-Test nicht möglich war)
t_test_ergebnisse <- Filter(Negate(is.null), t_test_ergebnisse)
# Ergebnisse zusammenführen
t_test_ergebnisse_df <- do.call(rbind, t_test_ergebnisse)
# Optional: Nach p-Wert sortieren
t_test_ergebnisse_df <- t_test_ergebnisse_df[order(t_test_ergebnisse_df$p_wert), ]
# Ausgabe
print(t_test_ergebnisse_df)
#At a peak, the fit value is calculated with 0.1 (not 1 for precision). The created function will be used at each maximum to evaluate the p-value. Amplitude of the fit curve at a given position is returned.
fine_fit_corr <- function(pos,vector,table_rep)	 {
#Get 25 values from the pos-th row in table_rep, representing data points to be fitted
df.y <- c(as.numeric(table_rep[pos,1:25]))
y <- c(1:25)
q <- vector
n <- length(vector)/3
gauss <- numeric(0)
value <- numeric(0)
#Defines the squared error between a 1-component gaussian with parameters q and the observed data df.y.
fun_f1 <- function(q) {
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
res <- (C1 * exp(-(y-mean1)**2/(2 * sigma1**2))) - df.y
sum(res * res)
}
#Handels edge cases, if input vector is empty, a flat line of zeros is returned.
if (n==0) {df.z <- rep(0,251)}
else {
#Attempts to fit the Gaussiann to the data using optim and fun_f1.     If it fails, sets gauss to empty.
gauss <- tryCatch(round( (fit <- optim(vector, fun_f1, method="BFGS", control=list(reltol=1e-9)))$par,digits = 1 ),error=function(e) numeric(0))
#z is a fine resolution grid from 0 to 25 in 0.1 steps (251            values). The fitted gaussian is evaluated at each point of this        grid.
z <- round(seq(0, 25, 0.1),digits=1)
if (length(gauss) == 0) {df.z <- rep(0,251)} else { df.z <- (gauss[1] * exp(-(z-gauss[2])**2/(2 * gauss[3]**2))) }
}
#Normalizes the fitted curve, converts it to a total are of 100
df.z <- df.z*100/sum(df.z)
#Takes normalized value of fitted curve at original input mean         (q[2]). Index is calculated by converting mean to corresponding index   in z.
value <- df.z[q[2]/0.1+1]
value
}
# Create summary tables
ctrl_mean <- cbind(table.ctrl.fit.fine, ctrl_3[, 26:37])
rnase_mean <- cbind(table.rnase.fit.fine, rnase_3[, 26:37])
# Area under the curve: here, area under the respective maxima
fun_gauss_area <- function(x) {
C <- x[1]
Mean <- x[2]
Sigma <- x[3]
y <- round(seq(1,25,0.2), digits=1)
if (Sigma == 0) {res <- 0} else {
res <- C * exp(-(y-Mean)**2/(2 * Sigma**2))
}
res <- round(sum(res)*0.2, digits=1)
res
}
# add a column with areas under each maximum and sum of the areas
# column "fit_area"
# column "sum_area" - the sum of the areas is expected to be close to 100 (due to the previous normalization step)
ctrl_mean$fit_area <- apply(vect, 2, function(z) {
list_c <- as.numeric(unlist(ctrl_mean[z,"fit_c"]))
list_mean <- as.numeric(unlist(ctrl_mean[z,"fit_mean"]))
list_sigma <- as.numeric(unlist(ctrl_mean[z,"fit_sigma"]))
n <- as.numeric(unlist(ctrl_mean[z,"nb_max"]))
area <- numeric(0)
vector <- numeric(0)
area_list <- numeric(0)
if (n == 0) {area_list <- 0} else {
for (i in 1:n) {
vector <- c(list_c[i],list_mean[i],list_sigma[i])
area <- fun_gauss_area(vector)
area_list <- c(area_list, area)
}
}
area_list
}
)
ctrl_mean$sum_area <- apply(vect, 2, function(z) {
list_area <- as.numeric(unlist(ctrl_mean[z,"fit_area"]))
sum_area <- sum(list_area)
sum_area
})
rnase_mean$fit_area <- apply(vect, 2, function(z) {
list_c <- as.numeric(unlist(rnase_mean[z,"fit_c"]))
list_mean <- as.numeric(unlist(rnase_mean[z,"fit_mean"]))
list_sigma <- as.numeric(unlist(rnase_mean[z,"fit_sigma"]))
n <- as.numeric(unlist(rnase_mean[z,"nb_max"]))
area <- numeric(0)
vector <- numeric(0)
area_list <- numeric(0)
if (n == 0) {area_list <- 0} else {
for (i in 1:n) {
vector <- c(list_c[i],list_mean[i],list_sigma[i])
area <- fun_gauss_area(vector)
area_list <- c(area_list, area)
}
}
area_list
}
)
rnase_mean$sum_area <- apply(vect, 2, function(z) {
list_area <- as.numeric(unlist(rnase_mean[z,"fit_area"]))
sum_area <- sum(list_area)
sum_area
})
# Label peaks which have either a residual value > 260 (no good fitting) or negative area (area under the curve < 0 after fitting)
# add column "pb_fit"
ctrl_mean$pb_fit <- apply(vect, 2, function(x) {
res <- as.numeric(unlist(ctrl_mean[x,"fit_res"]))
sigma <- as.numeric(unlist(ctrl_mean[x,"fit_sigma"]))
list_area <- unlist(ctrl_mean[x, "fit_area"])
neg <- any(list_area < 0)
nl <- any(sigma == 0) && (res != 0)
if (res > 260 || neg == "TRUE" || nl == "TRUE") {TRUE} else FALSE
})
rnase_mean$pb_fit <- apply(vect, 2, function(x) {
res <- as.numeric(unlist(rnase_mean[x,"fit_res"]))
sigma <- as.numeric(unlist(rnase_mean[x,"fit_sigma"]))
list_area <- unlist(rnase_mean[x, "fit_area"])
neg <- any(list_area < 0)
nl <- any(sigma == 0) && (res != 0)
if (res > 260 || neg == "TRUE" || nl == "TRUE") {TRUE} else FALSE
})
# Create a subtable with the problematic peaks from the control table
ctrl_mean_corr <- ctrl_mean[ctrl_mean$pb_fit == "TRUE",]
ctrl_mean_corr <- ctrl_mean_corr[, c(1:251,254)]
rnase_mean_corr <- rnase_mean[rnase_mean$pb_fit == "TRUE",]
rnase_mean_corr <- rnase_mean_corr[, c(1:251,254)]
# Reihennamen beider Tabellen
rows_rnase1 <- rownames(rnase_mean)
rows_rnase2 <- rownames(rnase_mean_corr)
rows_ctrl1 <- rownames(ctrl_mean)
rows_ctrl2 <- rownames(ctrl_mean_corr)
# Reihen, die NICHT in table2 vorkommen (nur die willst du behalten)
rows_to_keep_rnase_rnase <- setdiff(rows_rnase1, rows_rnase2)
rows_to_keep_rnase_ctrl <- setdiff(rows_rnase1, rows_ctrl2)
rows_to_keep_ctrl_rnase <- setdiff(rows_ctrl1, rows_rnase2)
rows_to_keep_ctrl_ctrl <- setdiff(rows_ctrl1, rows_ctrl2)
# table1 ohne die gemeinsamen Reihen
rnase_mean_filtert <- rnase_mean[rows_to_keep_rnase_rnase,]
rnase_mean_filtert_final <- rnase_mean_filtert[rows_to_keep_rnase_ctrl,]
ctrl_mean_filtert <- ctrl_mean[rows_to_keep_ctrl_rnase,]
ctrl_mean_filtert_final <- ctrl_mean_filtert[rows_to_keep_ctrl_ctrl,]
# eigentlich mit ctrl_mean_filtert_final
df_ctrl <- ctrl_mean_filtert_final[1:251] # Gruppe A
df_rnase <- rnase_mean_filtert_final[1:251] # Gruppe B
df_numeric_ctrl <- as.data.frame(lapply(df_ctrl, function(x) as.numeric(as.character(x))))
df_numeric_rnase <- as.data.frame(lapply(df_rnase, function(x) as.numeric(as.character(x))))
colnames(df_numeric_ctrl) <- colnames(ctrl_mean_filtert_final[1:251])
colnames(df_numeric_rnase) <- colnames(rnase_mean_filtert_final[1:251])
rownames(df_numeric_ctrl) <- rownames(ctrl_mean_filtert_final[1:251])
rownames(df_numeric_rnase) <- rownames(rnase_mean_filtert_final[1:251])
# T-Test pro Zeilenpaar
t_test_final <- lapply(seq_len(nrow(df_numeric_ctrl)), function(i) {
x <- as.numeric(df_numeric_ctrl[i, ])
y <- as.numeric(df_numeric_rnase[i, ])
# Nur t-Test, wenn beide Gruppen mindestens 2 gültige Werte haben
if (sum(!is.na(x)) >= 2 && sum(!is.na(y)) >= 2) {
t_res <- t.test(x, y)
data.frame(
zeile = rownames(df_numeric_ctrl)[i],
p_wert = t_res$p.value,
mittelwert = mean(x, na.rm = TRUE),
mittelwert = mean(y, na.rm = TRUE),
t_wert = t_res$statistic,
df = t_res$parameter
)
} else {
NULL
}
})
# Entferne NULLs (wo T-Test nicht möglich war)
t_test_final <- Filter(Negate(is.null), t_test_final)
# Ergebnisse zusammenführen
t_test_final_df <- do.call(rbind, t_test_final)
# Optional: Nach p-Wert sortieren
t_test_final_df <- t_test_final_df[order(t_test_final_df$p_wert), ]
# Ausgabe
print(t_test_final_df)
ctrl_clean <- as.data.frame(lapply(ctrl_mean_filtert_final, function(col) unlist(col)))
ctrl_clean <- as.data.frame(lapply(ctrl_mean_filtert_final, function(col) unlist(col)))
sapply(names(ctrl_mean_filtert_final), function(col) {
cor(as.numeric(ctrl_mean_filtert_final[[col]]),
as.numeric(rnase_mean_filtert_final[[col]]),
use = "complete.obs", method = "pearson")
})
pca_result_ctrl <- prcomp(ctrl_mean_filtert_final[1:251], center = TRUE, scale. = TRUE)
pca_ctrl <- as.numeric(ctrl_mean_filtert_final[1:251])
pca_ctrl <- as.numeric(as.matrix(ctrl_mean_filtert_final[1:251]))
pca_rnase <- as.numeric(as.matrix(rnase_mean_filtert_final[1:251]))
pca_result_ctrl <- prcomp(pca_ctrl, center = TRUE, scale. = TRUE, )
pca_ctrl <- as.numeric(as.matrix(ctrl_mean_filtert_final[1:251]))
pca_rnase <- as.numeric(as.matrix(rnase_mean_filtert_final[1:251]))
pca_ctrl_clean <- pca_ctrl[!is.na(pca_ctrl)]
pca_ctrl_rnase <- pca_rnase[!is.na(pca_rnase)]
pca_result_ctrl <- prcomp(pca_ctrl, center = TRUE, scale. = TRUE, )
pca_ctrl <- as.numeric(as.matrix(ctrl_mean_filtert_final[1:251]))
pca_rnase <- as.numeric(as.matrix(rnase_mean_filtert_final[1:251]))
pca_ctrl_clean <- pca_ctrl[!is.na(pca_ctrl)]
pca_ctrl_rnase <- pca_rnase[!is.na(pca_rnase)]
pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
pca_ctrl <- as.numeric(as.matrix(ctrl_mean_filtert_final[1:251]))
pca_rnase <- as.numeric(as.matrix(rnase_mean_filtert_final[1:251]))
pca_ctrl_clean <- pca_ctrl[!is.na(pca_ctrl)]
pca_rnase_rnase <- pca_rnase[!is.na(pca_rnase)]
pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
pca_ctrl <- as.numeric(as.matrix(ctrl_mean_filtert_final[1:251]))
pca_rnase <- as.numeric(as.matrix(rnase_mean_filtert_final[1:251]))
pca_ctrl_clean <- pca_ctrl[!is.na(pca_ctrl)]
pca_rnase_clean <- pca_rnase[!is.na(pca_rnase)]
pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
# PCA-Objekt anschauen
summary(pca_result)       # erklärt Varianz pro Komponente
pca_ctrl <- as.numeric(as.matrix(ctrl_mean_filtert_final[1:251]))
pca_rnase <- as.numeric(as.matrix(rnase_mean_filtert_final[1:251]))
pca_ctrl_clean <- pca_ctrl[!is.na(pca_ctrl)]
pca_rnase_clean <- pca_rnase[!is.na(pca_rnase)]
pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
# PCA-Objekt anschauen
summary(pca_result-clean)       # erklärt Varianz pro Komponente
pca_ctrl <- as.numeric(as.matrix(ctrl_mean_filtert_final[1:251]))
pca_rnase <- as.numeric(as.matrix(rnase_mean_filtert_final[1:251]))
pca_ctrl_clean <- pca_ctrl[!is.na(pca_ctrl)]
pca_rnase_clean <- pca_rnase[!is.na(pca_rnase)]
pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
# PCA-Objekt anschauen
summary(pca_result_clean)       # erklärt Varianz pro Komponente
pca_ctrl <- as.numeric(as.matrix(ctrl_mean_filtert_final[1:251]))
pca_rnase <- as.numeric(as.matrix(rnase_mean_filtert_final[1:251]))
pca_ctrl_clean <- pca_ctrl[!is.na(pca_ctrl)]
pca_rnase_clean <- pca_rnase[!is.na(pca_rnase)]
pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
# PCA-Objekt anschauen
summary(pca_result_ctrl)       # erklärt Varianz pro Komponente
pca_result_ctrl$rotation       # die "Ladungen" (loadings)
pca_result_ctrl$x              # die projizierten Daten (scores)
# Einfaches 2D PCA-Plot
plot(pca_result_ctrl$x[,1:2], col = "blue", pch = 16,
xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2")
pca_ctrl <- as.numeric(as.matrix(ctrl_mean_filtert_final[1:251]))
pca_rnase <- as.numeric(as.matrix(rnase_mean_filtert_final[1:251]))
pca_ctrl_clean <- pca_ctrl[!is.na(pca_ctrl)]
pca_rnase_clean <- pca_rnase[!is.na(pca_rnase)]
pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
# Einfaches 2D PCA-Plot
plot(pca_result_ctrl$x[,1:2], col = "blue", pch = 16,
xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2")
str(pca_result_ctrl)
View(pca_result_ctrl)
View(pca_rnase_clean)
