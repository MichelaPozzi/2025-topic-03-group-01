# Normalization of the mean vectors
# norm_factor <- norm_fact(vec): The function norm_fact is applied to every vector in the list avg.tables.CTRL (length 3)
# norm_factor / vec: Results in new vector of length 3 and represents a correcting factor for the single replicates in order to align the amount of protein of the replicates
norm_mean_frxn_CTRL <- lapply(avg.tables.CTRL, function(vec) {
norm_factor <- norm_fact(vec)
norm_factor / vec
})
norm_mean_frxn_RNASE <- lapply(avg.tables.RNASE, function(vec) {
norm_factor <- norm_fact(vec)
norm_factor / vec
})
# Correction factor for the overall protein quantity
# Normalization vectors for replicates 1-3
# function(x) x[1]: extracts the first element of each vector in the list
# norm.ctrl1 is a numeric vector consisting of the 1st element of each normalized CTRL vector
norm.ctrl1 <- sapply(norm_mean_frxn_CTRL, function(x) x[1])
norm.ctrl2 <- sapply(norm_mean_frxn_CTRL, function(x) x[2])
norm.ctrl3 <- sapply(norm_mean_frxn_CTRL, function(x) x[3])
norm.rnase1 <- sapply(norm_mean_frxn_RNASE, function(x) x[1])
norm.rnase2 <- sapply(norm_mean_frxn_RNASE, function(x) x[2])
norm.rnase3 <- sapply(norm_mean_frxn_RNASE, function(x) x[3])
# Defines logical vectors (TRUE, FALSE), which are later used to create subtables - separately for treatment (Ctrl vs. RNase) and replica (Rep1, Rep2, Rep3)
# colmns_sorted$levels_fraction =="Ctrl_Rep1": checks at which position exactly in the columns_sorted Ctrl_Rep1 can be found (marks it with TRUE)
data.ctrl1 <- colmns_sorted$levels_fraction =="Ctrl_Rep1"
data.ctrl2 <- colmns_sorted$levels_fraction =="Ctrl_Rep2"
data.ctrl3 <- colmns_sorted$levels_fraction =="Ctrl_Rep3"
data.rnase1 <- colmns_sorted$levels_fraction =="RNase_Rep1"
data.rnase2 <- colmns_sorted$levels_fraction =="RNase_Rep2"
data.rnase3 <- colmns_sorted$levels_fraction =="RNase_Rep3"
# Normalization step, fraction-wise
# takes specific columns from the protein intensity table and scales each row according to a normalization factor to compensate for measurement differences between replicates
# mask: A logical vector (TRUE/FALSE) that specifies which columns of NS_Table are selected
# selected <- NS_Table[, mask]: from NS_Table only the columns marked with TRUE in mask are selected
# (`*`, selected, norm_vec, SIMPLIFY = FALSE): Multiplication of colums of selected and the vector norm_vec saved as a list
normalize_group <- function(mask, norm_vec) {
selected <- NS_Table[, mask]
as.data.frame(mapply(`*`, selected, norm_vec, SIMPLIFY = FALSE))
}
# logical vectors (data.ctrl1) and vectors with normalization-factors (norm.ctrl1) form groups
# normalize_group(): multiplication of the vectors with their normalization-factor
table.ctrl1  <- normalize_group(data.ctrl1,  norm.ctrl1)
table.ctrl2  <- normalize_group(data.ctrl2,  norm.ctrl2)
table.ctrl3  <- normalize_group(data.ctrl3,  norm.ctrl3)
table.rnase1 <- normalize_group(data.rnase1, norm.rnase1)
table.rnase2 <- normalize_group(data.rnase2, norm.rnase2)
table.rnase3 <- normalize_group(data.rnase3, norm.rnase3)
# Get the proper rownames for the tables
rownames(table.ctrl1) <- row_names
rownames(table.ctrl2) <- row_names
rownames(table.ctrl3) <- row_names
rownames(table.rnase1) <- row_names
rownames(table.rnase2) <- row_names
rownames(table.rnase3) <- row_names
# Apply a sliding window/moving average of 3 points to the data to reduce noise in the data and obtain smoother curves (not possible for fraction 1 and 25)
smooth_table <- function(tbl) {
data.frame(tbl[1], (tbl[1:23] + tbl[2:24] + tbl[3:25]) / 3, tbl[25])
}
table.ctrl1.SW <- smooth_table(table.ctrl1)
table.ctrl2.SW <- smooth_table(table.ctrl2)
table.ctrl3.SW <- smooth_table(table.ctrl3)
table.rnase1.SW <- smooth_table(table.rnase1)
table.rnase2.SW <- smooth_table(table.rnase2)
table.rnase3.SW <- smooth_table(table.rnase3)
# Get the proper rownames for the tables
colnames(table.ctrl1.SW) <- colnames(table.ctrl1)
colnames(table.ctrl2.SW) <- colnames(table.ctrl2)
colnames(table.ctrl3.SW) <- colnames(table.ctrl3)
colnames(table.rnase1.SW) <- colnames(table.rnase1)
colnames(table.rnase2.SW) <- colnames(table.rnase2)
colnames(table.rnase3.SW) <- colnames(table.rnase3)
# Normalization of the fractions: Sum of all fraction values equals 100 (%)
normalize_table <- function(tbl) {
tbl * 100 / rowSums(tbl)
}
tables.ctrl <- list(
ctrl1 = table.ctrl1.SW,
ctrl2 = table.ctrl2.SW,
ctrl3 = table.ctrl3.SW)
tables.rnase <- list(
rnase1 = table.rnase1.SW,
rnase2 = table.rnase2.SW,
rnase3 = table.rnase3.SW)
# Calculation of the percentages of the fractions in the normalized tables (table.ctrl1.SW)
norm_tables.ctrl <- lapply(tables.ctrl, normalize_table)
norm_tables.rnase <- lapply(tables.rnase, normalize_table)
# Function for replacing NA and NaN with 0
clean_table <- function(tbl) {
tbl <- rapply(tbl, function(x) ifelse(is.na(x), 0, x), how = "replace")
tbl <- rapply(tbl, function(x) ifelse(is.nan(x), 0, x), how = "replace")
return(tbl)
}
# Getting the clean table
tables.norm.ctrl <- lapply(norm_tables.ctrl, clean_table)
tables.norm.rnase <- lapply(norm_tables.rnase, clean_table)
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)
# Addition of all data-frames in the list my.list.ctrl.norm (element-wise) and Division of the Sum with 3 to get the mean of all 3 replicates
ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
# Change names of the columns: from "fraction1" to "fraction25"
col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
# second normalization of the fractions (mean destroyed first normalization): Sum of all fraction values equals 100 (%)
ctrl_norm_mean <- ctrl_norm_mean*100/rowSums(ctrl_norm_mean)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)
# Function for replacing NA and NaN with 0
replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")
ctrl_norm_mean <- replace_na_nan(ctrl_norm_mean)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
# If a curve is 0 in all fractions, the other fraction is also set to 0 and is excluded from the analysis
ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
row_data1 <- as.numeric(ctrl_norm_mean["NUCL_HUMAN", 1:25])
row_data2 <- as.numeric(rnase_norm_mean["NUCL_HUMAN", 1:25])
# Plot
plot(row_data1,
type = "l",
main = "Plot for NUCL_HUMAN",
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2)
lines(row_data2,
type = "l",
col = "red",
lwd = 2)
# In case the original data is advantageous for later analysis
ctrl_norm_mean_original = ctrl_norm_mean
rnase_norm_mean_original = rnase_norm_mean
# Function find_local_maxima
# Peak is local maximum with a certain amount (=window) of smaller points on each side
# Bigger window => more stringent peak finding procedure
find_local_maxima <- function(x, window = 2) {
n <- length(x)
peaks <- c()
for (i in 1:n) {
left <- max(1, i - window)
right <- min(n, i + window)
neighbors <- x[left:right][-which((left:right) == i)]
if (all(neighbors <= x[i])) {
peaks <- c(peaks, i)
}
}
return(peaks)
}
# Apply the function to the data set
# Restriction to values above an absolute threshold of 2%
# New column: "local_maxima" (column 26)
ctrl_norm_mean$local_maxima <- apply(ctrl_norm_mean, 1, function(x) {
peak_indices <- find_local_maxima(x)
filtered <- peak_indices[x[peak_indices] > 2]
local_maxima <- unlist(filtered)
local_maxima
})
rnase_norm_mean$local_maxima <- apply(rnase_norm_mean, 1, function(x) {
peak_indices <- find_local_maxima(x)
filtered <- peak_indices[x[peak_indices] > 2]
local_maxima <- unlist(filtered)
local_maxima
})
# Out of the local maxima, extract the global (greatest) maximum, and save it in a new column "global_maximum" (column 27)
ctrl_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
x <- as.numeric(ctrl_norm_mean[i, 1:25])
peaks <- ctrl_norm_mean$local_maxima[[i]]
if (length(peaks) == 0) {
return(NA)
} else {
peak_values <- x[peaks]
return(peaks[which.max(peak_values)])
}
})
rnase_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
x <- as.numeric(rnase_norm_mean[i, 1:25])
peaks <- rnase_norm_mean$local_maxima[[i]]
if (length(peaks) == 0) {
return(NA)
} else {
peak_values <- x[peaks]
return(peaks[which.max(peak_values)])
}
})
# Identify the RNAse fractions with signal intensity > 2%.
# Create a new data frame containing 0 (= this fraction value was ≤2% ) and 1 (= this fraction value was >2%.), as well as the intensity maxima.
# The two new data frames are created, rnase_3 and ctrl_3, as copies of the previously calculated, normalized mean tables (*_norm_mean).
rnase_3 <- rnase_norm_mean
# Compare each value in columns 1 to 25 (the fractions) of the rnase_norm_mean dataframe with the threshold of 2%.
# Convert TRUE to 1 and FALSE to 0.
rnase_3[1:25] <- (rnase_norm_mean[1:25] > 2)*1
# Identify the CTRL fractions with signal intensity > 2%.
# Create a new data frames containing 0 / 1, as well as the intensity maxima.
ctrl_3 <- ctrl_norm_mean
ctrl_3[1:25] <- (ctrl_norm_mean[1:25] > 2)*1
# Remove and exclude 3 fractions left and right of each peak (7 in total) from the shoulder search.
th_max_reg_simple <- function(x) {
peaks <- as.numeric(unlist(x$local_maxima))
mask <- rep(1, 25)
for (peak in peaks) { # peak = current peak value, peaks = detected maxima (column 26)
if (peak > 0) {
left <- max(1, peak - 3)
right <- min(25, peak + 3)
mask[left:right] <- 0 # For each peak, the range from peak–3 to peak+3 is calculated and set to 0 in the mask
}
}
x_values <- as.numeric(x[1:25])
x_values <- x_values * mask # Fractions with mask = 1 are retained. Fractions with mask = 0 are set to 0.
return(x_values)
}
# Apply the function row by row to the entire rnase_3 or ctrl_3 DataFrame.
rnase_3[1:25] <- t(apply(rnase_3, 1, th_max_reg_simple))
ctrl_3[1:25]  <- t(apply(ctrl_3, 1, th_max_reg_simple))
# Detect "shoulder regions"
# Define a function that identifies signal regions where there are at least 4 consecutive fractions with an intensity above 2% using the data frames rnase_3 and ctrl_3.
# select the middle of this region as shoulder
peaks_regions = function(x) {
rle_result = rle(as.numeric(x[1:25])) # rle() finds all consecutive equal values -> $lengths and $values
#Find positions of all blocks consisting of 1s with length ≥4. These blocks are considered “shoulder regions”.
peak_blocks = which(rle_result$values == 1 & rle_result$lengths >= 4)
#If there are no such blocks of length >4, return an empty vector
if (length(peak_blocks) == 0) {
return(numeric(0))
}
#Calculate estimate middle for the peak blocks
peak_positions = numeric(length(peak_blocks))
for(i in seq_along(peak_blocks)) {
#Position of the end of the respective block
end_of_block = sum(rle_result$lengths[1:peak_blocks[i]])
#Calculate half length of the block
half_length = floor(rle_result$lengths[peak_blocks[i]] /2)
#Middle position of the shoulder
peak_positions[i] = end_of_block - half_length
}
return(peak_positions)
}
# Calculate the positions of the "shoulders" for each row for the data.frames ctrl/rnase_3 and ctrl/rnase_norm_mean
# New column: "shoulders" (column 28)
rnase_3$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_3$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )
rnase_norm_mean$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_norm_mean$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )
# Calculate the total of all relevant signal maxima (real peaks and shoulders) for each protein row in the data.frames
# New column: "combined_max_ctrl" and "combined_max_rnase" (column 29) respectively
rnase_3$combined_max_rnase <- apply(rnase_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$local_maxima)) # ls_max = numerical vector with the peak positions of this protein
ls_shoulder <- as.numeric(unlist(x$shoulders))
combined_max_rnase <- c(ls_max, ls_shoulder) # Combine to common vector.
combined_max_rnase <- unlist(combined_max_rnase)
combined_max_rnase <- combined_max_rnase[combined_max_rnase!=0] # Remove all 0 entries from the result vector, as these do not represent real signals.
combined_max_rnase <- sort(combined_max_rnase, decreasing = FALSE) # Sort all peak and shoulder positions in ascending order (1 → 25)
if (length(combined_max_rnase) == 0) {0} else {combined_max_rnase} # If there are no peaks or shoulders, 0 (as a placeholder) is stored.
})
ctrl_3$combined_max_ctrl <- apply(ctrl_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$local_maxima))
ls_shoulder <- as.numeric(unlist(x$shoulders))
combined_max_ctrl <- c(ls_max, ls_shoulder)
combined_max_ctrl <- unlist(combined_max_ctrl)
combined_max_ctrl <- combined_max_ctrl[combined_max_ctrl!=0]
combined_max_ctrl <- sort(combined_max_ctrl, decreasing = FALSE)
if (length(combined_max_ctrl) == 0) {0} else {combined_max_ctrl}
})
# Add new column of the combined maxima to ctrl/rnase_nrom_mean, to continue working with it
ctrl_norm_mean$combined_max_ctrl = ctrl_3[, "combined_max_ctrl"]
rnase_norm_mean$combined_max_rnase = rnase_3[, "combined_max_rnase"]
# Determine the number of combined maxima (peaks + shoulders) per protein
# New column: "n_max_comb" (column 30)
rnase_3$n_max_comb <- apply(rnase_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$combined_max_rnase))
n = length(ls_max) # determines how many peaks (maxima and shoulders) the protein has
if (sum(ls_max) == 0) {0} else {n}
})
ctrl_3$n_max_comb <- apply(ctrl_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$combined_max_ctrl))
n = length(ls_max)
if (sum(ls_max) == 0) {0} else {n}
})
# Same for ctrl/rnase_norm_mean
ctrl_norm_mean$n_max_comb = ctrl_3[, "n_max_comb"]
rnase_norm_mean$n_max_comb = rnase_3[, "n_max_comb"]
# Determine the number of only peak maxima ("local_maxima") per protein
# New column: "n_local_maxima" (column 31)
rnase_3$n_local_maxima <- apply(rnase_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$local_maxima))
n = length(ls_max)
if (sum(ls_max) == 0) {0} else {n}
})
ctrl_3$n_local_maxima <- apply(ctrl_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$local_maxima))
n = length(ls_max)
if (sum(ls_max) == 0) {0} else {n}
})
# Same for ctrl/rnase_norm_mean
ctrl_norm_mean$n_local_maxima = ctrl_3[, "n_local_maxima"]
rnase_norm_mean$n_local_maxima = rnase_3[, "n_local_maxima"]
# Calculate the center of mass for each row
# x is the vector with the intensities of a protein across all 25 fractions for which the COM is currently being calculated
# * means element-wise multiplication
ctrl_norm_mean$COM <- apply(ctrl_norm_mean[, 1:25], 1, function(x) {
sum((1:25) * x, na.rm = TRUE) / sum(x, na.rm = TRUE)
})
rnase_norm_mean$COM <- apply(rnase_norm_mean[, 1:25], 1, function(x) {
sum((1:25) * x, na.rm = TRUE) / sum(x, na.rm = TRUE)
})
# Calculate the absolute difference of the position of the global maximum between ctrl and rnase
diff_main_maxima <- abs(ctrl_norm_mean$global_maximum - rnase_norm_mean$global_maximum)
# Indices of proteins with deviation ≥ 3 fractions
deviating_main_maxima <- which(diff_main_maxima >= 3)
# Apply on the data.frames
ctrl_main_shift = ctrl_norm_mean[deviating_main_maxima, ]
rnase_main_shift = rnase_norm_mean[deviating_main_maxima, ]
# ctrl/rnase_main_shift contain 1075 proteins
ctrl_no_main_shift = ctrl_norm_mean[!rownames(ctrl_norm_mean) %in% rownames(ctrl_main_shift), ]
rnase_no_main_shift = rnase_norm_mean[!rownames(rnase_norm_mean) %in% rownames(rnase_main_shift), ]
# Function to calculate the row-wise correlation, assumption: cor of ctrl_main_shift is lower than of ctrl_no_main_shift
correlations <- function(df1, df2, methode = "pearson") {
# Check whether both data frames have the same dimensions
if (!all(dim(df1) == dim(df2))) {
stop("Die beiden Dataframes müssen die gleiche Dimension haben")
}
# Number of rows
n <- nrow(df1)
# Vector for storing the correlation values
correlations <- numeric(n)
# Loop over all rows
for (i in 1:n) {
v1 <- as.numeric(df1[i, 1:25])
v2 <- as.numeric(df2[i, 1:25])
# Calculate correlation only if both vectors have variance
if (sd(v1, na.rm = TRUE) != 0 && sd(v2, na.rm = TRUE) != 0) {
correlations[i] <- cor(v1, v2, method = methode, use = "complete.obs")
} else {
correlations[i] <- NA
}
}
abs_correlations = abs(correlations)
mean_abs_correlation = mean(abs_correlations, na.rm = TRUE)
return(list(
correlations = correlations, mean_abs_correlation = mean_abs_correlation
))
}
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is shifted by at least 2 fractions
testing_cor_shifter = correlations(ctrl_main_shift, rnase_main_shift)
testing_cor_shifter$mean_abs_correlation
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is not shifted by at least 2 fractions
testing_cor_no_shifter = correlations(ctrl_no_main_shift, rnase_no_main_shift)
testing_cor_no_shifter$mean_abs_correlation
# If the hypothesis is correct, is the mean of the correlations of the shifters smaller than that of the no_shifters?
testing_cor_shifter$mean_abs_correlation < testing_cor_no_shifter$mean_abs_correlation
cor_all_proteins = correlations(ctrl_norm_mean, rnase_norm_mean)
cor_all_proteins$mean_abs_correlation
par(mfrow = c(1, 2))
hist(
testing_cor_shifter$correlations,
main = "Correlation values main shifter",
xlab = "Correlation value",
ylab = "Frequency",
col = "skyblue",
border = "white",
xlim = c(-1, 1)
)
# Zweiter Plot: testing_cor_no_shifter
hist(
testing_cor_no_shifter$correlations,
main = "Correlation values no main shifter",
xlab = "Correlation value",
ylab = "Frequency",
col = "salmon",
border = "white",
xlim = c(-1, 1)
)
par(mfrow = c(1, 1))
# Vector with indices of proteins, that show a near zero correlation between ctrl and rnase
near_zero_cors = which(abs(testing_cor_shifter$correlations) <= 0.01)
indices = near_zero_cors[1:5]
# Plotting a respective curves
for(i in indices) {
cs <- as.numeric(ctrl_main_shift[i, 1:25])
rs <- as.numeric(rnase_main_shift[i, 1:25])
# Plot
plot(cs,
type = "l",
main = paste("Protein at index", i),
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2,
ylim = range(c(cs, rs)))
lines(rs,
type = "l",
col = "red",
lwd = 2)
}
# Vector with indices of proteins, that show a near one correlation between ctrl and rnase
near_one_cors = which(abs(testing_cor_no_shifter$correlations) >0.99)
indices = near_one_cors[1:5]
# Plotting a respective curves
for(i in indices) {
cs <- as.numeric(ctrl_no_main_shift[i, 1:25])
rs <- as.numeric(rnase_no_main_shift[i, 1:25])
# Plot
plot(cs,
type = "l",
main = paste("Protein at index", i),
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2,
ylim = range(c(cs, rs)))
lines(rs,
type = "l",
col = "red",
lwd = 2)
}
# Vector with indices of proteins, that show a near one correlation between ctrl and rnase
near_one_cors_question = which(abs(testing_cor_shifter$correlations) >0.95)
indices = near_one_cors_question[1:5]
# Plotting a respective curves
for(i in indices) {
cs <- as.numeric(ctrl_main_shift[i, 1:25])
rs <- as.numeric(rnase_main_shift[i, 1:25])
# Plot
plot(cs,
type = "l",
main = paste("Protein at index", i),
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2,
ylim = range(c(cs, rs)))
lines(rs,
type = "l",
col = "red",
lwd = 2)
}
# Calculate the absolute difference of the position of the COM values between ctrl and rnase
diff_COM <- abs(ctrl_main_shift$COM - rnase_main_shift$COM)
# Indices of proteins with deviation ≥ 3 fractions
deviating_COM <- which(diff_COM >= 3)
# Apply on the data.frames
ctrl_COM_shift = ctrl_main_shift[deviating_COM, ]
rnase_COM_shift = rnase_main_shift[deviating_COM, ]
# ctrl/rnase_COM_shift contain 806 proteins
ctrl_no_COM_shift = ctrl_main_shift[!rownames(ctrl_main_shift) %in% rownames(ctrl_COM_shift), ]
rnase_no_COM_shift = rnase_main_shift[!rownames(rnase_main_shift) %in% rownames(rnase_COM_shift), ]
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is shifted by at least 2 fractions
COM_shifter = correlations(ctrl_COM_shift, rnase_COM_shift)
COM_shifter$mean_abs_correlation
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is not shifted by at least 2 fractions
COM_no_shifter = correlations(ctrl_no_COM_shift, rnase_no_COM_shift)
COM_no_shifter$mean_abs_correlation
par(mfrow = c(1, 2))
hist(
COM_shifter$correlations,
main = "Correlation values COM shifter",
xlab = "Correlation value",
ylab = "Frequency",
col = "skyblue",
border = "white",
xlim = c(-1, 1)
)
# Zweiter Plot: testing_cor_no_shifter
hist(
COM_no_shifter$correlations,
main = "Correlation values no COM shifter",
xlab = "Correlation value",
ylab = "Frequency",
col = "salmon",
border = "white",
xlim = c(-1, 1)
)
par(mfrow = c(1, 1))
# Vector with indices of proteins, that show a near zero correlation between ctrl and rnase
near_zero_cors = which(abs(COM_shifter$correlations) <= 0.01)
indices = near_zero_cors[1:5]
# Plotting respective curves
for(i in indices) {
cs <- as.numeric(ctrl_COM_shift[i, 1:25])
rs <- as.numeric(rnase_COM_shift[i, 1:25])
# Plot
plot(cs,
type = "l",
main = paste("Protein at index", i),
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2,
ylim = range(c(cs, rs)))
lines(rs,
type = "l",
col = "red",
lwd = 2)
}
# Vector with indices of proteins, that show a near one correlation between ctrl and rnase
near_one_cors = which(abs(COM_no_shifter$correlations) >0.99)
indices = near_one_cors[1:5]
# Plotting a respective curves
for(i in indices) {
cs <- as.numeric(ctrl_no_main_shift[i, 1:25])
rs <- as.numeric(rnase_no_main_shift[i, 1:25])
# Plot
plot(cs,
type = "l",
main = paste("Protein at index", i),
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2,
ylim = range(c(cs, rs)))
lines(rs,
type = "l",
col = "red",
lwd = 2)
}
