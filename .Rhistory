ctrl_norm_mean <- ctrl_norm_mean*100/rowSums(ctrl_norm_mean)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)
# Function for replacing NA and NaN with 0
replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")
ctrl_norm_mean <- replace_na_nan(ctrl_norm_mean)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
# If a curve is 0 in all fractions, the other fraction is also set to 0 and is excluded from the analysis
ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
par(mfrow = c(1, 2))
row_data1 <- as.numeric(ctrl_norm_mean["SPTN1_HUMAN", 1:25])
row_data2 <- as.numeric(rnase_norm_mean["SPTN1_HUMAN", 1:25])
# Plot
plot(row_data1,
type = "l",
main = "Plot for SPTN1_HUMAN",
xlab = "Fractions",
ylab = "Values",
col = "midnightblue",
lwd = 2)
lines(row_data2,
type = "l",
col = "firebrick3",
lwd = 2)
row_data3 <- as.numeric(ctrl_norm_mean["DDX21_HUMAN", 1:25])
row_data4 <- as.numeric(rnase_norm_mean["DDX21_HUMAN", 1:25])
# Plot
plot(row_data3,
type = "l",
main = "Plot for DDX21_HUMAN",
xlab = "Fractions",
ylab = "Values",
col = "midnightblue",
lwd = 2)
lines(row_data4,
type = "l",
col = "firebrick3",
lwd = 2)
par(mfrow = c(1, 1))
# In case the original data is advantageous for later analysis
ctrl_norm_mean_original = ctrl_norm_mean
rnase_norm_mean_original = rnase_norm_mean
# Function find_local_maxima
# Peak is local maximum with a certain amount (=window) of smaller points on each side
# Bigger window => more stringent peak finding procedure
find_local_maxima <- function(x, window = 2) {
n <- length(x)
peaks <- c()
for (i in 1:n) {
left <- max(1, i - window)
right <- min(n, i + window)
neighbors <- x[left:right][-which((left:right) == i)]
if (all(neighbors <= x[i])) {
peaks <- c(peaks, i)
}
}
return(peaks)
}
# Apply the function to the data set
# Restriction to values above an absolute threshold of 2%
# New column: "local_maxima" (column 26)
ctrl_norm_mean$local_maxima <- apply(ctrl_norm_mean, 1, function(x) {
peak_indices <- find_local_maxima(x)
filtered <- peak_indices[x[peak_indices] > 2]
local_maxima <- unlist(filtered)
local_maxima
})
rnase_norm_mean$local_maxima <- apply(rnase_norm_mean, 1, function(x) {
peak_indices <- find_local_maxima(x)
filtered <- peak_indices[x[peak_indices] > 2]
local_maxima <- unlist(filtered)
local_maxima
})
# Out of the local maxima, extract the global (greatest) maximum, and save it in a new column "global_maximum" (column 27)
ctrl_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
x <- as.numeric(ctrl_norm_mean[i, 1:25])
peaks <- ctrl_norm_mean$local_maxima[[i]]
if (length(peaks) == 0) {
return(NA)
} else {
peak_values <- x[peaks]
return(peaks[which.max(peak_values)])
}
})
rnase_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
x <- as.numeric(rnase_norm_mean[i, 1:25])
peaks <- rnase_norm_mean$local_maxima[[i]]
if (length(peaks) == 0) {
return(NA)
} else {
peak_values <- x[peaks]
return(peaks[which.max(peak_values)])
}
})
# Identify the RNAse fractions with signal intensity > 2%.
# Create a new data frame containing 0 (= this fraction value was ≤2% ) and 1 (= this fraction value was >2%.), as well as the intensity maxima.
# The two new data frames are created, rnase_3 and ctrl_3, as copies of the previously calculated, normalized mean tables (*_norm_mean).
rnase_3 <- rnase_norm_mean
# Compare each value in columns 1 to 25 (the fractions) of the rnase_norm_mean dataframe with the threshold of 2%.
# Convert TRUE to 1 and FALSE to 0.
rnase_3[1:25] <- (rnase_norm_mean[1:25] > 2)*1
# Identify the CTRL fractions with signal intensity > 2%.
# Create a new data frames containing 0 / 1, as well as the intensity maxima.
ctrl_3 <- ctrl_norm_mean
ctrl_3[1:25] <- (ctrl_norm_mean[1:25] > 2)*1
# Remove and exclude 3 fractions left and right of each peak (7 in total) from the shoulder search.
th_max_reg_simple <- function(x) {
peaks <- as.numeric(unlist(x$local_maxima))
mask <- rep(1, 25)
for (peak in peaks) { # peak = current peak value, peaks = detected maxima (column 26)
if (peak > 0) {
left <- max(1, peak - 3)
right <- min(25, peak + 3)
mask[left:right] <- 0 # For each peak, the range from peak–3 to peak+3 is calculated and set to 0 in the mask
}
}
x_values <- as.numeric(x[1:25])
x_values <- x_values * mask # Fractions with mask = 1 are retained. Fractions with mask = 0 are set to 0.
return(x_values)
}
# Apply the function row by row to the entire rnase_3 or ctrl_3 DataFrame.
rnase_3[1:25] <- t(apply(rnase_3, 1, th_max_reg_simple))
ctrl_3[1:25]  <- t(apply(ctrl_3, 1, th_max_reg_simple))
# Detect "shoulder regions"
# Define a function that identifies signal regions where there are at least 4 consecutive fractions with an intensity above 2% using the data frames rnase_3 and ctrl_3.
# select the middle of this region as shoulder
peaks_regions = function(x) {
rle_result = rle(as.numeric(x[1:25])) # rle() finds all consecutive equal values -> $lengths and $values
#Find positions of all blocks consisting of 1s with length ≥4. These blocks are considered “shoulder regions”.
peak_blocks = which(rle_result$values == 1 & rle_result$lengths >= 4)
#If there are no such blocks of length >4, return an empty vector
if (length(peak_blocks) == 0) {
return(numeric(0))
}
#Calculate estimate middle for the peak blocks
peak_positions = numeric(length(peak_blocks))
for(i in seq_along(peak_blocks)) {
#Position of the end of the respective block
end_of_block = sum(rle_result$lengths[1:peak_blocks[i]])
#Calculate half length of the block
half_length = floor(rle_result$lengths[peak_blocks[i]] /2)
#Middle position of the shoulder
peak_positions[i] = end_of_block - half_length
}
return(peak_positions)
}
# Calculate the positions of the "shoulders" for each row for the data.frames ctrl/rnase_3 and ctrl/rnase_norm_mean
# New column: "shoulders" (column 28)
rnase_3$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_3$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )
rnase_norm_mean$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_norm_mean$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )
# Calculate the total of all relevant signal maxima (real peaks and shoulders) for each protein row in the data.frames
# New column: "combined_max_ctrl" and "combined_max_rnase" (column 29) respectively
rnase_3$combined_max_rnase <- apply(rnase_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$local_maxima)) # ls_max = numerical vector with the peak positions of this protein
ls_shoulder <- as.numeric(unlist(x$shoulders))
combined_max_rnase <- c(ls_max, ls_shoulder) # Combine to common vector.
combined_max_rnase <- unlist(combined_max_rnase)
combined_max_rnase <- combined_max_rnase[combined_max_rnase!=0] # Remove all 0 entries from the result vector, as these do not represent real signals.
combined_max_rnase <- sort(combined_max_rnase, decreasing = FALSE) # Sort all peak and shoulder positions in ascending order (1 → 25)
if (length(combined_max_rnase) == 0) {0} else {combined_max_rnase} # If there are no peaks or shoulders, 0 (as a placeholder) is stored.
})
ctrl_3$combined_max_ctrl <- apply(ctrl_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$local_maxima))
ls_shoulder <- as.numeric(unlist(x$shoulders))
combined_max_ctrl <- c(ls_max, ls_shoulder)
combined_max_ctrl <- unlist(combined_max_ctrl)
combined_max_ctrl <- combined_max_ctrl[combined_max_ctrl!=0]
combined_max_ctrl <- sort(combined_max_ctrl, decreasing = FALSE)
if (length(combined_max_ctrl) == 0) {0} else {combined_max_ctrl}
})
# Add new column of the combined maxima to ctrl/rnase_nrom_mean, to continue working with it
ctrl_norm_mean$combined_max_ctrl = ctrl_3[, "combined_max_ctrl"]
rnase_norm_mean$combined_max_rnase = rnase_3[, "combined_max_rnase"]
# Determine the number of combined maxima (peaks + shoulders) per protein
# New column: "n_max_comb" (column 30)
rnase_3$n_max_comb <- apply(rnase_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$combined_max_rnase))
n = length(ls_max) # determines how many peaks (maxima and shoulders) the protein has
if (sum(ls_max) == 0) {0} else {n}
})
ctrl_3$n_max_comb <- apply(ctrl_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$combined_max_ctrl))
n = length(ls_max)
if (sum(ls_max) == 0) {0} else {n}
})
# Same for ctrl/rnase_norm_mean
ctrl_norm_mean$n_max_comb = ctrl_3[, "n_max_comb"]
rnase_norm_mean$n_max_comb = rnase_3[, "n_max_comb"]
# Determine the number of only peak maxima ("local_maxima") per protein
# New column: "n_local_maxima" (column 31)
rnase_3$n_local_maxima <- apply(rnase_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$local_maxima))
n = length(ls_max)
if (sum(ls_max) == 0) {0} else {n}
})
ctrl_3$n_local_maxima <- apply(ctrl_3, 1, function(x) {
ls_max <- as.numeric(unlist(x$local_maxima))
n = length(ls_max)
if (sum(ls_max) == 0) {0} else {n}
})
# Same for ctrl/rnase_norm_mean
ctrl_norm_mean$n_local_maxima = ctrl_3[, "n_local_maxima"]
rnase_norm_mean$n_local_maxima = rnase_3[, "n_local_maxima"]
# Calculate the center of mass for each row
# x is the vector with the intensities of a protein across all 25 fractions for which the COM is currently being calculated
# * means element-wise multiplication
ctrl_norm_mean$COM <- apply(ctrl_norm_mean[, 1:25], 1, function(x) {
sum((1:25) * x, na.rm = TRUE) / sum(x, na.rm = TRUE)
})
rnase_norm_mean$COM <- apply(rnase_norm_mean[, 1:25], 1, function(x) {
sum((1:25) * x, na.rm = TRUE) / sum(x, na.rm = TRUE)
})
# Function to calculate the row-wise correlation between the rows of two data.frames
correlations <- function(df1, df2, methode = "pearson") {
# Check whether both data frames have the same dimensions
if (!all(dim(df1) == dim(df2))) {
stop("Both data frames need to have same dimension")
}
# Number of rows
n <- nrow(df1)
# Vector for storing the correlation values
correlations <- numeric(n)
# Loop over all rows
for (i in 1:n) {
v1 <- as.numeric(df1[i, 1:25])
v2 <- as.numeric(df2[i, 1:25])
# Calculate correlation only if both vectors have variance
if (sd(v1, na.rm = TRUE) != 0 && sd(v2, na.rm = TRUE) != 0) {
correlations[i] <- cor(v1, v2, method = methode, use = "complete.obs")
} else {
correlations[i] <- NA
}
}
abs_correlations = abs(correlations)
mean_abs_correlation = mean(abs_correlations, na.rm = TRUE)
return(list(
correlations = correlations, mean_abs_correlation = mean_abs_correlation
))
}
# Function to plot a defined amount of protein curves (ctrl & rnase), based on a selected threshold and condition (= direction)
header_plotting <- function(cor_vector,
ctrl_data,
rnase_data,
n = 5,
cor_threshold = 0.6,
direction = "abs_lt") {
# selecting the indices based on the direction
selected <- switch(direction,
lt      = which(cor_vector < cor_threshold),
gt      = which(cor_vector > cor_threshold),
abs_lt  = which(abs(cor_vector) < cor_threshold),
abs_gt  = which(abs(cor_vector) > cor_threshold),
stop("wrong value for direction used")
)
# Just use n plots
selected_indices = head(selected, n)
# Plotting
for (i in selected_indices) {
cs = as.numeric(ctrl_data[i, 1:25])
rs = as.numeric(rnase_data[i, 1:25])
corr_value = cor_vector[i]
plot(
cs,
type = "l",
main = paste("Protein at index", i, "/ Correlation: ", round(corr_value, 3), "/ name: ", rownames(ctrl_data)[i]),
xlab = "Fractions",
ylab = "Values",
col = "midnightblue",
lwd = 2,
ylim = range(c(cs, rs), na.rm = TRUE)
)
lines(
rs,
type = "l",
col = "firebrick",
lwd = 2
)
}
}
# Calculate the absolute difference of the positions of the COM values between ctrl and rnase
diff_COM <- abs(ctrl_norm_mean$COM - rnase_norm_mean$COM)
# Indices of proteins with deviation ≥ 2 fractions
deviating_COM <- which(diff_COM >= 2)
# Apply on the data.frames
ctrl_COM_shift = ctrl_norm_mean[deviating_COM, ]
rnase_COM_shift = rnase_norm_mean[deviating_COM, ]
# Create the complementary data.frame that contains all proteins whose COM do not shift by at least 2 fractions
ctrl_no_COM_shift = ctrl_norm_mean[!rownames(ctrl_norm_mean) %in% rownames(ctrl_COM_shift), ]
rnase_no_COM_shift = rnase_norm_mean[!rownames(rnase_norm_mean) %in% rownames(rnase_COM_shift), ]
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose COM is shifted by at least 2 fractions
COM_shifter = correlations(ctrl_COM_shift, rnase_COM_shift)
COM_shifter$mean_abs_correlation
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose COM is not shifted by at least 2 fractions
COM_no_shifter = correlations(ctrl_no_COM_shift, rnase_no_COM_shift)
COM_no_shifter$mean_abs_correlation
# Calculate the mean correlation value among all proteins
cor_all_proteins = correlations(ctrl_norm_mean, rnase_norm_mean)
cor_all_proteins$mean_abs_correlation
par(mfrow = c(1, 2))
hist(
COM_shifter$correlations,
main = "Correlation values for COM shifter",
xlab = "Correlation value",
ylab = "Frequency",
col = "midnightblue",
border = "white",
xlim = c(-1, 1)
)
hist(
COM_no_shifter$correlations,
main = "Correlation values for not COM shifter",
xlab = "Correlation value",
ylab = "Frequency",
col = "firebrick",
border = "white",
xlim = c(-1, 1)
)
par(mfrow = c(1, 1))
header_plotting(COM_shifter$correlations, ctrl_COM_shift, rnase_COM_shift, n = 5, cor_threshold = 0.9, direction = "gt")
header_plotting(COM_no_shifter$correlations, ctrl_no_COM_shift, rnase_no_COM_shift, n = 5, cor_threshold = 0.9, direction = "gt")
header_plotting(COM_no_shifter$correlations, ctrl_no_COM_shift, rnase_no_COM_shift, n = 5, cor_threshold = 0.7, direction = "lt")
# Calculate the absolute difference of the position of the global maximum between ctrl and rnase
diff_main_maxima <- abs(ctrl_no_COM_shift$global_maximum - rnase_no_COM_shift$global_maximum)
# Indices of proteins with deviation ≥ 3 fractions
deviating_main_maxima <- which(diff_main_maxima >= 3)
# Apply on the data.frames
ctrl_main_shift = ctrl_no_COM_shift[deviating_main_maxima, ]
rnase_main_shift = rnase_no_COM_shift[deviating_main_maxima, ]
# Create the complementary data.frame that contains all proteins whose main maximum does not shift by at least 2 fractions
ctrl_no_main_shift = ctrl_no_COM_shift[!rownames(ctrl_no_COM_shift) %in% rownames(ctrl_main_shift), ]
rnase_no_main_shift = rnase_no_COM_shift[!rownames(rnase_no_COM_shift) %in% rownames(rnase_main_shift), ]
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is shifted by at least 2 fractions
main_shifter = correlations(ctrl_main_shift, rnase_main_shift)
main_shifter$mean_abs_correlation
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is not shifted by at least 2 fractions
main_no_shifter = correlations(ctrl_no_main_shift, rnase_no_main_shift)
main_no_shifter$mean_abs_correlation
# Calculate the mean correlation value among all proteins, that show no shift in their COM
cor_all_proteins_no_COM = correlations(ctrl_no_COM_shift, rnase_no_COM_shift)
cor_all_proteins_no_COM$mean_abs_correlation
par(mfrow = c(1, 2))
hist(
main_shifter$correlations,
main = "Corr values for main shifter",
xlab = "Correlation value",
ylab = "Frequency",
col = "midnightblue",
border = "white",
xlim = c(-1, 1)
)
hist(
main_no_shifter$correlations,
main = "Corr values for not main shifter",
xlab = "Correlation value",
ylab = "Frequency",
col = "firebrick",
border = "white",
xlim = c(-1, 1)
)
par(mfrow = c(1, 1))
header_plotting(main_shifter$correlations, ctrl_main_shift, rnase_main_shift, n = 5, cor_threshold = 0.9, direction = "gt" )
hist(
main_shifter$correlations,
main = "Corr values main shifter",
xlab = "Correlation value",
ylab = "Frequency",
col = "midnightblue",
border = "white",
breaks = 50,
xlim = c(-1, 1)
)
abline(v = 0.70, lwd = 3, col = "firebrick")
# Define threshold
threshold = 0.7
keep_indices = main_shifter$correlations <= threshold
# New data.frames with the proteins, that might be RNA-dependent
ctrl_under_threshold = ctrl_main_shift[keep_indices, ]
rnase_under_threshold = rnase_main_shift[keep_indices, ]
# New data.frames with the proteins, that are not RNA-dependent by arbitrary choice
ctrl_above_threshold = ctrl_main_shift[!keep_indices, ]
rnase_above_threshold = rnase_main_shift[!keep_indices, ]
#1
ctrl_selected = rbind(ctrl_COM_shift, ctrl_under_threshold)
rnase_selected = rbind(rnase_COM_shift, rnase_under_threshold)
#2
sum(rownames(ctrl_selected) != rownames(rnase_selected))
#3
ctrl_not_selected = rbind(ctrl_no_main_shift, ctrl_above_threshold)
rnase_not_selected = rbind(rnase_no_main_shift, rnase_above_threshold)
#4
sum(rownames(ctrl_not_selected) != rownames(rnase_not_selected))
#5
dim(ctrl_not_selected)[1] + dim(ctrl_selected)[1] == dim(ctrl_norm_mean)[1]
# Read the two data sets from the website RBP2GO, among other things they contain protein names for RBPs and not RBPs, as well as the values for their isoelectric points
rbp_pos <- read.delim("Daten/RBP2GO Table RBPs.txt", skip = 6, sep = "\t", stringsAsFactors = FALSE)
rbp_neg <- read.delim("Daten/RBP2GO Table Non-RBPs.txt", skip = 6, sep = "\t", stringsAsFactors = FALSE)
# Create a new dataframe, that only contains those proteins from our selected group, that were also listed in the external data rbp_pos & rbp_neg, as well as the respective isoelectric points for these proteins.
# Protein names of all selected proteins
protein_names = rownames(ctrl_selected)
# Extract the protein names from rbp_pos and rbp_neg
rbp_pos_proteins = rbp_pos$Entry_Name
rbp_neg_proteins = rbp_neg$Entry_Name
# Get indices of the matching proteins
indices_pos = which(protein_names %in% rbp_pos_proteins)
indices_neg = which(protein_names %in% rbp_neg_proteins)
# Get the subsets for the included proteins
df_pos = ctrl_selected[indices_pos, ]
df_neg = ctrl_selected[indices_neg, ]
# Get the matching protein names
matched_pos_names = rownames(df_pos)
matched_neg_names = rownames(df_neg)
# Get the values for the isoelectric points
df_pos_pI = rbp_pos$pI[match(matched_pos_names, rbp_pos$Entry_Name)]
df_neg_pI = rbp_neg$pI[match(matched_neg_names, rbp_pos$Entry_Name)]
# Combine to new dataframes, with Protein Names and their isoelectric point
df_pos_combined_selected = data.frame(protein = matched_pos_names, isoelectric_point = df_pos_pI)
df_neg_combined_selected = data.frame(protein = matched_neg_names, isoelectric_point = df_neg_pI)
# Merge those two dataframes together
final_df_combined_selected = rbind(df_pos_combined_selected, df_neg_combined_selected)
# How many proteins were not listed in either rbp_pos or rbp_neg, but still used in our data set - 39
# dim(ctrl_selected)[1] - dim(final_df_combined_selected)[1]
# Perform the first t-test
t.test(final_df_combined_selected$isoelectric_point, mu = 7.0, alternative = "greater")
# Create a new dataframe, that only contains all initial proteins, that were also listed in the external data rbp_pos & rbp_neg, as well as their respective isoelectric points for these proteins.
# Protein names of all inital proteins
protein_names = rownames(ctrl_norm_mean)
# Extract the protein names from rbp_pos and rbp_neg
rbp_pos_proteins = rbp_pos$Entry_Name
rbp_neg_proteins = rbp_neg$Entry_Name
# Get indices of the matching proteins
indices_pos = which(protein_names %in% rbp_pos_proteins)
indices_neg = which(protein_names %in% rbp_neg_proteins)
# Get the subsets for the included proteins
df_pos = ctrl_norm_mean[indices_pos, ]
df_neg = ctrl_norm_mean[indices_neg, ]
# Get the matching protein names
matched_pos_names = rownames(df_pos)
matched_neg_names = rownames(df_neg)
# Get the values for the isoelectric points
df_pos_pI = rbp_pos$pI[match(matched_pos_names, rbp_pos$Entry_Name)]
df_neg_pI = rbp_neg$pI[match(matched_neg_names, rbp_pos$Entry_Name)]
# Combine to new dataframes, with Protein Names and their isoelectric point
df_pos_combined_all_proteins = data.frame(protein = matched_pos_names, isoelectric_point = df_pos_pI)
df_neg_combined_all_proteins = data.frame(protein = matched_neg_names, isoelectric_point = df_neg_pI)
# Merge those two dataframes together
final_df_combined_all_proteins = rbind(df_pos_combined_all_proteins, df_neg_combined_all_proteins)
# How many proteins were not listed in either rbp_pos or rbp_neg, but still used in our data set - 274
# dim(ctrl_norm_mean)[1] - dim(final_df_combined_all_proteins)[1]
# Perform the second t-test
t.test(final_df_combined_all_proteins$isoelectric_point, mu = 7.0, alternative = "two.sided")
par(mfrow = c(1, 2))
hist(
final_df_combined_selected$isoelectric_point,
main = "Isoelectric points of the selected proteins",
xlab = "Isoelectric point",
ylab = "Frequency",
breaks = 30,
col = "midnightblue",
border = "white",
xlim = c(0, 14)
)
# ablines
abline(v = 7, col = "seagreen3", lwd = 2, lty = 2)
abline(v = mean(final_df_combined_selected$isoelectric_point, na.rm = TRUE),
col = "yellow", lwd = 2)
hist(
final_df_combined_all_proteins$isoelectric_point,
main = "Isoelectric points for all proteins",
xlab = "Isoelectric point",
ylab = "Frequency",
breaks = 30,
col = "firebrick",
border = "white",
xlim = c(0, 14)
)
#ablines
abline(v = 7, col = "seagreen3", lwd = 2, lty = 2)
abline(v = mean(final_df_combined_all_proteins$isoelectric_point, na.rm = TRUE),
col = "yellow", lwd = 2)
par(mfrow = c(1, 1))
par(mfrow = c(1, 2))
plot(
ctrl_COM_shift$COM, rnase_COM_shift$COM,
xlab = "COM from ctrl_selected",
ylab = "COM from rnase_selected",
main = "COM: selected proteins",
pch = 19,
col = "steelblue"
)
points(
ctrl_under_threshold$COM, rnase_under_threshold$COM,
pch = 19,
col = "firebrick"
)
abline(a = 0, b = 1, col = "black", lwd = 3, lty = 3)
plot(
ctrl_no_COM_shift$COM, rnase_no_COM_shift$COM,
xlab = "COM from ctrl_not_selected",
ylab = "COM from rnase_not_selected",
main = "COM: not selected proteins",
pch = 19,
col = "midnightblue"
)
points(
ctrl_above_threshold$COM, rnase_above_threshold$COM,
pch = 19,
col = "seagreen3"
)
abline(a = 0, b = 1, col = "black", lwd = 3, lty = 3)
par(mfrow = c(1, 1))
