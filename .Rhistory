xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL")
plot(pca_result_rnase$x[,1:2], col = "blue", pch = 16,
xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE")
#plot PC2 with PC3
plot(pca_result_ctrl$x[,1:2], col = "blue", pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
plot(pca_result_rnase$x[,1:2], col = "blue", pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE")
#plot PC1 with PC3
plot(pca_result_ctrl$x[,c(1, 3)], col = "blue", pch = 16,
xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL")
plot(pca_result_rnase$x[,c(1, 3)], col = "blue", pch = 16,
xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE")
#plot PC2 with PC3
plot(pca_result_ctrl$x[,2:3], col = "blue", pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL")
plot(pca_result_rnase$x[,2:3], col = "blue", pch = 16,
xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE")
plot(pca_result_ctrl, type = "l", main = "Elbow-Plot CTRL")
plot(pca_result_rnase, type = "l", main = "Elbow-Plot RNASE")
#chech which PCs have the most variance
summary(pca_result_ctrl[,1:5])
#chech which PCs have the most variance
summary(pca_result_ctrl[1:5,])
#chech which PCs have the most variance
summary(pca_result_ctrl)
plot(pca_result_ctrl, type = "l", main = "Elbow-Plot CTRL", methode = "silhouette methode")
plot(pca_result_rnase, type = "l", main = "Elbow-Plot RNASE")
plot(pca_result_ctrl, type = "l", main = "Elbow-Plot CTRL")
plot(pca_result_rnase, type = "l", main = "Elbow-Plot RNASE")
#k-means
set.seed(42)
k <- 3
km_result <- kmeans(pca_df, centers = k)
#k-means
set.seed(42)
k <- 3
km_result <- kmeans(pca_df, centers = k)
plot(km_result)
#k-means
set.seed(42)
k <- 3
km_result <- kmeans(pca_df, centers = k)
pca_ctrl_pc1_pc2 <- as.data.frame(pca_result_ctrl$x[, 1:2])
pca_ctrl_pc1_pc3 <- as.data.frame(pca_result_ctrl$x[, c(1,3)])
pca_ctrl_pc2_pc3 <- as.data.frame(pca_result_ctrl$x[, 2:3])
pca_ctrl_pc1_pc2 <- as.data.frame(pca_result_rnase$x[, 1:2])
pca_ctrl_pc1_pc2 <- as.data.frame(pca_result_rnase$x[, c(1,3)])
pca_ctrl_pc1_pc2 <- as.data.frame(pca_result_rnase$x[, 2:3])
pca_ctrl_pc1_pc2 <- as.data.frame(pca_result_ctrl$x[, 1:2])
pca_ctrl_pc1_pc3 <- as.data.frame(pca_result_ctrl$x[, c(1,3)])
pca_ctrl_pc2_pc3 <- as.data.frame(pca_result_ctrl$x[, 2:3])
pca_rnase_pc1_pc2 <- as.data.frame(pca_result_rnase$x[, 1:2])
pca_rnase_pc1_pc3 <- as.data.frame(pca_result_rnase$x[, c(1,3)])
pca_rnase_pc2_pc3 <- as.data.frame(pca_result_rnase$x[, 2:3])
library(factoextra)
instarll(factoextra)
install(factoextra)
install.packages("factoextra")
library(factoextra)
fviz_nbclust(pca_ctrl_pc1_pc2, kmeans, method = "silhouette") +
labs(title = "Optimale Clusteranzahl (Silhouette-Methode)") +
theme_minimal()
library(factoextra)
fviz_nbclust(pca_ctrl_pc1_pc2, kmeans, method = "silhouette") +
labs(title = "Optimale Clusteranzahl (Silhouette-Methode)") +
theme_minimal()
fviz_nbclust(pca_ctrl_pc1_pc3, kmeans, method = "silhouette") +
labs(title = "Optimale Clusteranzahl (Silhouette-Methode)") +
theme_minimal()
fviz_nbclust(pca_ctrl_pc2_pc3, kmeans, method = "silhouette") +
labs(title = "Optimale Clusteranzahl (Silhouette-Methode)") +
theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc2, kmeans, method = "silhouette") +
labs(title = "Optimale Clusteranzahl (Silhouette-Methode)") +
theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc3, kmeans, method = "silhouette") +
labs(title = "Optimale Clusteranzahl (Silhouette-Methode)") +
theme_minimal()
fviz_nbclust(pca_rnase_pc2_pc3, kmeans, method = "silhouette") +
labs(title = "Optimale Clusteranzahl (Silhouette-Methode)") +
theme_minimal()
library(factoextra)
fviz_nbclust(pca_ctrl_pc1_pc2, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode CTRL PC1/PC2") +
theme_minimal()
fviz_nbclust(pca_ctrl_pc1_pc3, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode CTRL PC1/PC2") +
theme_minimal()
fviz_nbclust(pca_ctrl_pc2_pc3, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode CTRL PC2/PC3") +
theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc2, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode RNASE PC1/PC2") +
theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc3, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode RNASE PC1/PC3") +
theme_minimal()
fviz_nbclust(pca_rnase_pc2_pc3, kmeans, method = "silhouette") +
labs(title = "Silhouette-Methode RNASE PC2/PC3") +
theme_minimal()
set.seed(42)
k <- 3
km_result <- kmeans(pca_ctrl_pc1_pc2, centers = k)
set.seed(42)
k <- 3
km_result_ctrl_pc1_pc <- kmeans(pca_ctrl_pc1_pc2, centers = k)
set.seed(42)
k <- 3
km_result_ctrl_pc1_pc <- kmeans(pca_ctrl_pc1_pc2, centers = k)
plot(km_result_ctrl_pc1_pc)
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl_pc1_pc, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster auf PCA-Daten")
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl_pc1_pc2, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
set.seed(42)
k <- 3
km_result_ctrl_pc1_pc2 <- kmeans(pca_ctrl_pc1_pc2, centers = k)
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl_pc1_pc2, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl_pc1_pc2, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl_pc1_pc2, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
set.seed(42)
k <- 3
km_result_ctrl<- kmeans(pca_ctrl_pc1_pc2, centers = k)
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
k <- 3
km_result_ctrl<- kmeans(pca_ctrl_pc1_pc2, centers = k)
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
k_ctrl <- 3
km_result_ctrl<- kmeans(pca_ctrl_pc1_pc2, centers = k_ctrl)
k_rnase <- 5
km_result_ctrl<- kmeans(pca_ctrl_pc1_pc2, centers = k_rnase)
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
k_ctrl <- 3
km_result_ctrl<- kmeans(pca_ctrl_pc1_pc2, centers = k_ctrl)
k_rnase <- 5
km_result_rnase<- kmeans(pca_ctrl_pc1_pc2, centers = k_rnase)
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
nrow(pca_rnase_pc1_pc2)
nrow(pca_rnase_pc1_pc3)
nrow(pca_rnase_pc2_pc3)
length(km_result_rnase$cluster)
nrow(pca_ctrl_pc1_pc2)
nrow(pca_ctrl_pc1_pc3)
nrow(pca_ctrl_pc2_pc3)
length(km_result_ctrl$cluster)
k_ctrl <- 3
km_result_ctrl<- kmeans(pca_ctrl_pc1_pc2, centers = k_ctrl)
k_rnase <- 3
km_result_rnase<- kmeans(pca_ctrl_pc1_pc2, centers = k_rnase)
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
km_result_ctrl<- kmeans(pca_ctrl_pc1_pc2, centers = 3)
km_result_rnase<- kmeans(pca_ctrl_pc1_pc2, centers = 5)
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
length(km_result_ctrl)
km_result_ctrl<- kmeans(pca_ctrl_pc1_pc2, centers = 3)
km_result_rnase<- kmeans(pca_rnase_pc1_pc2, centers = 5)
library(factoextra)
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_ctrl, data = pca_ctrl_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der CTRL")
fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc2,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
fviz_cluster(km_result_rnase, data = pca_rnase_pc1_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
fviz_cluster(km_result_rnase, data = pca_rnase_pc2_pc3,
geom = "point", ellipse.type = "norm",
palette = "jco", ggtheme = theme_minimal(),
main = "k-Means Cluster der RNASE")
View(ctrl_mean_filtert_final)
View(ctrl_mean_filtert_final)
#Proportion test: Noch nicht angewannd auf Code. Nur für generellen Aufbau
#Ein Proportionstest prüft, ob ein oder mehrere beobachtete Anteile (Proportionen) von Erfolgen bzw. bestimmten Ereignissen signifikant von einer erwarteten oder einer anderen Proportion abweichen
# Ergebnisliste
prop_tests <- lapply(seq_len(nrow(ctrl_mean_filtert_final)), function(i) {
x <- c(ctrl_mean_filtert_final$maxima[i], rnase_mean_filtert_final$maxima[i])     # Erfolge aus beiden Gruppen
n <- c(ctrl_mean_filtert_final$nb_max[i], rnase_mean_filtert_final$nb_max[i])       # Versuchszahlen aus beiden Gruppen
test <- prop.test(x, n)
data.frame(
zeile = i,
p_wert = test$p.value,
anteil_gruppe1 = x[1] / n[1],
anteil_gruppe2 = x[2] / n[2],
chi_squared = test$statistic,
df = test$parameter
)
})
length(x)
length(ctrl_mean_filtert_final$maxima[i])
length(ctrl_mean_filtert_final$maxima)
length(rnase_mean_filtert_final$maxima)
length(ctrl_mean_filtert_final$nb_max)
length(rnase_mean_filtert_final$nb_max)
#Proportion test: Noch nicht angewannd auf Code. Nur für generellen Aufbau
#Ein Proportionstest prüft, ob ein oder mehrere beobachtete Anteile (Proportionen) von Erfolgen bzw. bestimmten Ereignissen signifikant von einer erwarteten oder einer anderen Proportion abweichen
# Ergebnisliste
prop_tests <- lapply(seq_len(nrow(ctrl_mean_filtert_final)), function(i) {
x <- c(ctrl_mean_filtert_final$maxima[i], rnase_mean_filtert_final$maxima[i])     # Erfolge aus beiden Gruppen
n <- c(ctrl_mean_filtert_final$nb_max[i], rnase_mean_filtert_final$nb_max[i])       # Versuchszahlen aus beiden Gruppen
x1 <- as.numeric(ctrl_mean_filtert_final$maxima[i])
x2 <- as.numeric(rnase_mean_filtert_final$maxima[i])
n1 <- as.numeric(ctrl_mean_filtert_final$nb_max[i])
n2 <- as.numeric(rnase_mean_filtert_final$nb_max[i])
test <- prop.test(x, n)
data.frame(
zeile = i,
p_wert = test$p.value,
anteil_gruppe1 = x1 / n1,
anteil_gruppe2 = x2 / n2,
chi_squared = test$statistic,
df = test$parameter
)
})
anyNA(x1)
anyNA(as.numeric(ctrl_mean_filtert_final$maxima))
#chech which PCs have the most variance
summary(pca_result_ctrl)
summary(pca_result_rnase)
#chech which PCs have the most variance
#summary(pca_result_ctrl)
#summary(pca_result_rnase)
#Proportion test: Noch nicht angewannd auf Code. Nur für generellen Aufbau
#Ein Proportionstest prüft, ob ein oder mehrere beobachtete Anteile (Proportionen) von Erfolgen bzw. bestimmten Ereignissen signifikant von einer erwarteten oder einer anderen Proportion abweichen
pca_ctrl_numeric <- ctrl_mean_filtert_final[1:251, sapply(ctrl_mean_filtert_final, is.numeric)]
# Ergebnisliste
prop_tests <- lapply(seq_len(ncol(ctrl_mean_filtert_final)), function(i) {
x <- c(ctrl_mean_filtert_final$maxima[i], rnase_mean_filtert_final$maxima[i])     # Erfolge aus beiden Gruppen
n <- c(ctrl_mean_filtert_final$nb_max[i], rnase_mean_filtert_final$nb_max[i])       # Versuchszahlen aus beiden Gruppen
test <- prop.test(x, n)
data.frame(
zeile = i,
p_wert = test$p.value,
anteil_gruppe1 = x[i] / n[i],
anteil_gruppe2 = x[i] / n[i],
chi_squared = test$statistic,
df = test$parameter
)
})
#Proportion test: Noch nicht angewannd auf Code. Nur für generellen Aufbau
#Ein Proportionstest prüft, ob ein oder mehrere beobachtete Anteile (Proportionen) von Erfolgen bzw. bestimmten Ereignissen signifikant von einer erwarteten oder einer anderen Proportion abweichen
pca_ctrl_numeric <- ctrl_mean_filtert_final[1:251, sapply(ctrl_mean_filtert_final, is.numeric)]
# Ergebnisliste
prop_tests <- lapply(seq_len(nrow(ctrl_mean_filtert_final)), function(i) {
x <- c(ctrl_mean_filtert_final$maxima[i], rnase_mean_filtert_final$maxima[i])     # Erfolge aus beiden Gruppen
n <- c(ctrl_mean_filtert_final$nb_max[i], rnase_mean_filtert_final$nb_max[i])       # Versuchszahlen aus beiden Gruppen
test <- prop.test(x, n)
data.frame(
zeile = i,
p_wert = test$p.value,
anteil_gruppe1 = x[i] / n[i],
anteil_gruppe2 = x[i] / n[i],
chi_squared = test$statistic,
df = test$parameter
)
})
#Proportion test: Noch nicht angewannd auf Code. Nur für generellen Aufbau
#Ein Proportionstest prüft, ob ein oder mehrere beobachtete Anteile (Proportionen) von Erfolgen bzw. bestimmten Ereignissen signifikant von einer erwarteten oder einer anderen Proportion abweichen
# Ergebnisliste
prop_tests <- lapply(seq_len(nrow(ctrl_mean_filtert_final)), function(i) {
x <- c(ctrl_mean_filtert_final$maxima[i], rnase_mean_filtert_final$maxima[i])     # Erfolge aus beiden Gruppen
n <- c(ctrl_mean_filtert_final$ctrl_max[i], rnase_mean_filtert_final$ctrl_max[i])       # Versuchszahlen aus beiden Gruppen
test <- prop.test(x, n)
data.frame(
zeile = i,
p_wert = test$p.value,
anteil_gruppe1 = x[i] / n[i],
anteil_gruppe2 = x[i] / n[i],
chi_squared = test$statistic,
df = test$parameter
)
})
#Proportion test: Noch nicht angewannd auf Code. Nur für generellen Aufbau
#Ein Proportionstest prüft, ob ein oder mehrere beobachtete Anteile (Proportionen) von Erfolgen bzw. bestimmten Ereignissen signifikant von einer erwarteten oder einer anderen Proportion abweichen
# Ergebnisliste
prop_tests <- lapply(seq_len(nrow(ctrl_mean_filtert_final)),
x1 <- ctrl_mean_filtert_final$maxima,    # Erfolge aus beiden Gruppen
n1 <- ctrl_mean_filtert_final$ctrl_max,      # Versuchszahlen aus beiden Gruppen
x2 <- rnase_mean_filtert_final$maxima,     # Erfolge aus beiden Gruppen
n2 <- rnase_mean_filtert_final$ctrl_max,
test <- prop.test(x, n),
data.frame(
p_wert = test$p.value,
anteil_gruppe1 = x1 / n1,
anteil_gruppe2 = x2 / n2,
chi_squared = test$statistic,
df = test$parameter
)
)
#Proportion test: Noch nicht angewannd auf Code. Nur für generellen Aufbau
#Ein Proportionstest prüft, ob ein oder mehrere beobachtete Anteile (Proportionen) von Erfolgen bzw. bestimmten Ereignissen signifikant von einer erwarteten oder einer anderen Proportion abweichen
# Ergebnisliste
prop_tests <- lapply(seq_len(nrow(ctrl_mean_filtert_final)), function(i) {
x1 <- ctrl_mean_filtert_final$maxima[i]     # Erfolge aus beiden Gruppen
n1 <- ctrl_mean_filtert_final$ctrl_max[i]         # Versuchszahlen aus beiden Gruppen
x2 <- rnase_mean_filtert_final$maxima[i]       # Erfolge aus beiden Gruppen
n2 <- rnase_mean_filtert_final$ctrl_max[i]
test <- prop.test(x, n)
data.frame(
zeile = i,
p_wert = test$p.value,
anteil_gruppe1 = x1 / n1,
anteil_gruppe2 = x2 / n2,
chi_squared = test$statistic,
df = test$parameter
)
})
# Angenommen, df1 und df2 sind deine beiden DataFrames
# Und sie enthalten z. B. die Spalten: "maxima" (Erfolge), "nb_max" (Gesamtanzahl)
prop_tests <- lapply(seq_len(nrow(ctrl_mean_filtert_final)), function(i) {
# Hole Werte aus beiden DataFrames
x1 <- as.numeric(ctrl_mean_filtert_final$maxima[i])
x2 <- as.numeric(rnase_mean_filtert_final$maxima[i])
n1 <- as.numeric(ctrl_mean_filtert_final$nb_max[i])
n2 <- as.numeric(rnase_mean_filtert_final$nb_max[i])
# Gültigkeit prüfen
if (any(is.na(c(x1, x2, n1, n2))) || any(c(x1, x2, n1, n2) < 0)) {
return(data.frame(
zeile = i,
p_wert = NA,
anteil_df1 = NA,
anteil_df2 = NA,
chi_squared = NA,
df = NA
))
}
# Proportionstest durchführen
test <- prop.test(x = c(x1, x2), n = c(n1, n2))
# Ergebnis als DataFrame-Zeile zurückgeben
data.frame(
zeile = i,
p_wert = test$p.value,
anteil_df1 = x1 / n1,
anteil_df2 = x2 / n2,
chi_squared = test$statistic,
df = test$parameter
)
})
# Angenommen, df1 und df2 sind deine beiden DataFrames
# Und sie enthalten z. B. die Spalten: "maxima" (Erfolge), "nb_max" (Gesamtanzahl)
prop_tests <- lapply(seq_len(nrow(ctrl_mean_filtert_final)), function(i) {
# Hole Werte aus beiden DataFrames
x1 <- as.numeric(ctrl_mean_filtert_final$maxima[i])
x2 <- as.numeric(rnase_mean_filtert_final$maxima[i])
n1 <- as.numeric(ctrl_mean_filtert_final$nb_max[i])
n2 <- as.numeric(rnase_mean_filtert_final$nb_max[i])
# Gültigkeit prüfen
if (any(is.na(c(x1, x2, n1, n2))) || any(c(x1, x2, n1, n2) < 0)) {
return( c(x1, x2, n1, n2) <- 0)
}
# Proportionstest durchführen
test <- prop.test(x = c(x1, x2), n = c(n1, n2))
# Ergebnis als DataFrame-Zeile zurückgeben
data.frame(
zeile = i,
p_wert = test$p.value,
anteil_df1 = x1 / n1,
anteil_df2 = x2 / n2,
chi_squared = test$statistic,
df = test$parameter
)
})
