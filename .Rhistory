if (q > 1000) {
0
} else {
as.numeric(q)
}
} else {
0
}
table.ctrl1.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, ctrl_3, norm_tables.ctrl$ctrl1) })
table.ctrl2.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, ctrl_3, norm_tables.ctrl$ctrl2) })
table.ctrl3.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, ctrl_3, norm_tables.ctrl$ctrl3) })
table.rnase1.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, rnase_3, norm_tables.rnase$rnase1) })
table.rnase2.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, rnase_3, norm_tables.rnase$rnase2) })
table.rnase3.fit$fit_res <- apply(vect, 2, function(x) { gauss_fit_res(x, rnase_3, norm_tables.rnase$rnase3) })
# Normalize the fit to 100
table.ctrl1.fit.norm <- table.ctrl1.fit[1:25] * 100 / rowSums(table.ctrl1.fit[1:25])
table.ctrl2.fit.norm <- table.ctrl2.fit[1:25] * 100 / rowSums(table.ctrl2.fit[1:25])
table.ctrl3.fit.norm <- table.ctrl3.fit[1:25] * 100 / rowSums(table.ctrl3.fit[1:25])
table.rnase1.fit.norm <- table.rnase1.fit[1:25] * 100 / rowSums(table.rnase1.fit[1:25])
table.rnase2.fit.norm <- table.rnase2.fit[1:25] * 100 / rowSums(table.rnase2.fit[1:25])
table.rnase3.fit.norm <- table.rnase3.fit[1:25] * 100 / rowSums(table.rnase3.fit[1:25])
# Replace NA, NaN with 0
table.ctrl1.fit.norm <- rapply(table.ctrl1.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace")
table.ctrl2.fit.norm <- rapply(table.ctrl2.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.ctrl3.fit.norm <- rapply(table.ctrl3.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.rnase1.fit.norm <- rapply(table.rnase1.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.rnase2.fit.norm <- rapply(table.rnase2.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.rnase3.fit.norm <- rapply(table.rnase3.fit.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.ctrl1.fit.norm <- rapply(table.ctrl1.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace")
table.ctrl2.fit.norm <- rapply(table.ctrl2.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.ctrl3.fit.norm <- rapply(table.ctrl3.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.rnase1.fit.norm <- rapply(table.rnase1.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.rnase2.fit.norm <- rapply(table.rnase2.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.rnase3.fit.norm <- rapply(table.rnase3.fit.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
# Add columns to the tables with the fitted values:
# nb_max
table.ctrl1.fit.norm$nb_max <- ctrl_3$nb_max
table.ctrl2.fit.norm$nb_max <- ctrl_3$nb_max
table.ctrl3.fit.norm$nb_max <- ctrl_3$nb_max
table.rnase1.fit.norm$nb_max <- rnase_3$nb_max
table.rnase2.fit.norm$nb_max <- rnase_3$nb_max
table.rnase3.fit.norm$nb_max <- rnase_3$nb_max
# fit_param
table.ctrl1.fit.norm$fit_param <- table.ctrl1.fit$fit_param
table.ctrl2.fit.norm$fit_param <- table.ctrl2.fit$fit_param
table.ctrl3.fit.norm$fit_param <- table.ctrl3.fit$fit_param
table.rnase1.fit.norm$fit_param <- table.rnase1.fit$fit_param
table.rnase2.fit.norm$fit_param <- table.rnase2.fit$fit_param
table.rnase3.fit.norm$fit_param <- table.rnase3.fit$fit_param
# fit_res
table.ctrl1.fit.norm$fit_res <- table.ctrl1.fit$fit_res
table.ctrl2.fit.norm$fit_res <- table.ctrl2.fit$fit_res
table.ctrl3.fit.norm$fit_res <- table.ctrl3.fit$fit_res
table.rnase1.fit.norm$fit_res <- table.rnase1.fit$fit_res
table.rnase2.fit.norm$fit_res <- table.rnase2.fit$fit_res
table.rnase3.fit.norm$fit_res <- table.rnase3.fit$fit_res
# check_sum
table.ctrl1.fit.norm$check_sum <- table.ctrl1.fit$check_sum
table.ctrl2.fit.norm$check_sum <- table.ctrl2.fit$check_sum
table.ctrl3.fit.norm$check_sum <- table.ctrl3.fit$check_sum
table.rnase1.fit.norm$check_sum <- table.rnase1.fit$check_sum
table.rnase2.fit.norm$check_sum <- table.rnase2.fit$check_sum
table.rnase3.fit.norm$check_sum <- table.rnase3.fit$check_sum
# general function to create the tables
fine_fit <- function(fit)			{
dffit <- data.frame(y=seq(0, 25, 0.1))
z <- round(seq(0, 25, 0.1), digits=1)
n <- length(fit)/3
if (n==0) {dffit$df.y <- rep(0,251)} else {
if (n==1) {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
dffit$df.y <- C1 * exp(-(z-mean1)**2/(2 * sigma1**2))
} else {
if (n==2) {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
C2 <- q[4]
mean2 <- q[5]
sigma2 <- q[6]
dffit$df.y <- ( C1 * exp(-(z-mean1)**2/(2 * sigma1**2)) + C2 * exp(-(z-mean2)**2/(2 * sigma2**2)) )
} else {
if (n==3) {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
C2 <- q[4]
mean2 <- q[5]
sigma2 <- q[6]
C3 <- q[7]
mean3 <- q[8]
sigma3 <- q[9]
dffit$df.y <- ( C1 * exp(-(z-mean1)**2/(2 * sigma1**2)) + C2 * exp(-(z-mean2)**2/(2 * sigma2**2)) + C3 * exp(-(z-mean3)**2/(2 * sigma3**2)) )
} else {
if (n==4) {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
C2 <- q[4]
mean2 <- q[5]
sigma2 <- q[6]
C3 <- q[7]
mean3 <- q[8]
sigma3 <- q[9]
C4 <- q[10]
mean4 <- q[11]
sigma4 <- q[12]
dffit$df.y <- ( C1 * exp(-(z-mean1)**2/(2 * sigma1**2)) + C2 * exp(-(z-mean2)**2/(2 * sigma2**2)) + C3 * exp(-(z-mean3)**2/(2 * sigma3**2)) + C4 * exp(-(z-mean4)**2/(2 * sigma4**2)) )
} else {
if (n==5) {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
C2 <- q[4]
mean2 <- q[5]
sigma2 <- q[6]
C3 <- q[7]
mean3 <- q[8]
sigma3 <- q[9]
C4 <- q[10]
mean4 <- q[11]
sigma4 <- q[12]
C5 <- q[13]
mean5 <- q[14]
sigma5 <- q[15]
dffit$df.y <- ( C1 * exp(-(z-mean1)**2/(2 * sigma1**2)) + C2 * exp(-(z-mean2)**2/(2 * sigma2**2)) + C3 * exp(-(z-mean3)**2/(2 * sigma3**2)) + C4 * exp(-(z-mean4)**2/(2 * sigma4**2)) + C5 * exp(-(z-mean5)**2/(2 * sigma5**2)) )
} else {
q <- fit
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
C2 <- q[4]
mean2 <- q[5]
sigma2 <- q[6]
C3 <- q[7]
mean3 <- q[8]
sigma3 <- q[9]
C4 <- q[10]
mean4 <- q[11]
sigma4 <- q[12]
C5 <- q[13]
mean5 <- q[14]
sigma5 <- q[15]
C6 <- q[16]
mean6 <- q[17]
sigma6 <- q[18]
dffit$df.y <- ( C1 * exp(-(z-mean1)**2/(2 * sigma1**2)) + C2 * exp(-(z-mean2)**2/(2 * sigma2**2)) + C3 * exp(-(z-mean3)**2/(2 * sigma3**2)) + C4 * exp(-(z-mean4)**2/(2 * sigma4**2)) + C5 * exp(-(z-mean5)**2/(2 * sigma5**2)) + C6 * exp(-(z-mean6)**2/(2 * sigma6**2)) )
}
}
}
}
}
}
return(dffit$df.y * 100 / (sum(dffit$df.y) * 0.1))
}
# *0.1 to scale the resulting curve at the level of the normalized raw data. The sum here is at the end 1000 and not 100, but the values fits to the raw data.
table.ctrl1.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl1.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.ctrl1.fit.fine) <- rownames(table.ctrl1.fit)
colnames(table.ctrl1.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.ctrl2.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl2.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.ctrl2.fit.fine) <- rownames(table.ctrl2.fit)
colnames(table.ctrl2.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.ctrl3.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl3.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.ctrl3.fit.fine) <- rownames(table.ctrl3.fit)
colnames(table.ctrl3.fit.fine) <- lapply(seq(0,25,0.1), as.character)
#Function to calculate the fit value at a given peak (with 0.1 instead of 1 fraction precision)
# The function will be used in the next step to evaluate the p-value at each maximum
# Return the amplitude of the fit curve at a given position
fine_fit_corr <- function(pos,vector,table_rep)	 {
df.y <- c(as.numeric(table_rep[pos,1:25]))
y <- c(1:25)
q <- vector
n <- length(vector)/3
gauss <- numeric(0)
value <- numeric(0)
fun_f1 <- function(q) {
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
res <- (C1 * exp(-(y-mean1)**2/(2 * sigma1**2))) - df.y
sum(res * res)
}
if (n==0) {df.z <- rep(0,251)}
else {
gauss <- tryCatch(round( (fit <- optim(vector, fun_f1, method="BFGS", control=list(reltol=1e-9)))$par,digits = 1 ),error=function(e) numeric(0))
z <- round(seq(0, 25, 0.1),digits=1)
if (length(gauss) == 0) {df.z <- rep(0,251)} else { df.z <- (gauss[1] * exp(-(z-gauss[2])**2/(2 * gauss[3]**2))) }
}
df.z <- df.z*100/sum(df.z)
value <- df.z[q[2]/0.1+1]
value
}
row_data1 <- as.numeric(table.ctrl1.fit["PRKDC_HUMAN", ])
row_data2 <- as.numeric(table.rnase1.fit["PRKDC_HUMAN", ])
# Plot
plot(row_data1,
type = "l",                # Linienplot
main = "Plot for AHNK_HUMAN",
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2)
lines(row_data2,
type = "l",
col = "red",
lwd = 2)
row_data3 <- as.numeric(table.ctrl1.fit.fine["PRKDC_HUMAN", ])
row_data4 <- as.numeric(table.rnase1.fit.fine["PRKDC_HUMAN", ])
# *0.1 to scale the resulting curve at the level of the normalized raw data. The sum here is at the end 1000 and not 100, but the values fits to the raw data.
table.ctrl1.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl1.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.ctrl1.fit.fine) <- rownames(table.ctrl1.fit)
colnames(table.ctrl1.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.ctrl2.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl2.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.ctrl2.fit.fine) <- rownames(table.ctrl2.fit)
colnames(table.ctrl2.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.ctrl3.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl3.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.ctrl3.fit.fine) <- rownames(table.ctrl3.fit)
colnames(table.ctrl3.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.rnase1.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.rnase1.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.rnase1.fit.fine) <- rownames(table.rnase1.fit)
colnames(table.rnase1.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.rnase2.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.rnase2.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.rnase2.fit.fine) <- rownames(table.rnase2.fit)
colnames(table.rnase2.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.rnase3.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.rnase3.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.rnase3.fit.fine) <- rownames(table.rnase3.fit)
colnames(tablernase3.fit.fine) <- lapply(seq(0,25,0.1), as.character)
# *0.1 to scale the resulting curve at the level of the normalized raw data. The sum here is at the end 1000 and not 100, but the values fits to the raw data.
table.ctrl1.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl1.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.ctrl1.fit.fine) <- rownames(table.ctrl1.fit)
colnames(table.ctrl1.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.ctrl2.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl2.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.ctrl2.fit.fine) <- rownames(table.ctrl2.fit)
colnames(table.ctrl2.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.ctrl3.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.ctrl3.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.ctrl3.fit.fine) <- rownames(table.ctrl3.fit)
colnames(table.ctrl3.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.rnase1.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.rnase1.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.rnase1.fit.fine) <- rownames(table.rnase1.fit)
colnames(table.rnase1.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.rnase2.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.rnase2.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.rnase2.fit.fine) <- rownames(table.rnase2.fit)
colnames(table.rnase2.fit.fine) <- lapply(seq(0,25,0.1), as.character)
table.rnase3.fit.fine <- t(apply(vect, 2, function(t) {
fit_param <- as.numeric(unlist(table.rnase3.fit[t,"fit_param"]))
fine_fit(fit_param)
}))
rownames(table.rnase3.fit.fine) <- rownames(table.rnase3.fit)
colnames(table.rnase3.fit.fine) <- lapply(seq(0,25,0.1), as.character)
#Function to calculate the fit value at a given peak (with 0.1 instead of 1 fraction precision)
# The function will be used in the next step to evaluate the p-value at each maximum
# Return the amplitude of the fit curve at a given position
fine_fit_corr <- function(pos,vector,table_rep)	 {
df.y <- c(as.numeric(table_rep[pos,1:25]))
y <- c(1:25)
q <- vector
n <- length(vector)/3
gauss <- numeric(0)
value <- numeric(0)
fun_f1 <- function(q) {
C1 <- q[1]
mean1 <- q[2]
sigma1 <- q[3]
res <- (C1 * exp(-(y-mean1)**2/(2 * sigma1**2))) - df.y
sum(res * res)
}
if (n==0) {df.z <- rep(0,251)}
else {
gauss <- tryCatch(round( (fit <- optim(vector, fun_f1, method="BFGS", control=list(reltol=1e-9)))$par,digits = 1 ),error=function(e) numeric(0))
z <- round(seq(0, 25, 0.1),digits=1)
if (length(gauss) == 0) {df.z <- rep(0,251)} else { df.z <- (gauss[1] * exp(-(z-gauss[2])**2/(2 * gauss[3]**2))) }
}
df.z <- df.z*100/sum(df.z)
value <- df.z[q[2]/0.1+1]
value
}
row_data1 <- as.numeric(table.ctrl1.fit["PRKDC_HUMAN", ])
row_data2 <- as.numeric(table.rnase1.fit["PRKDC_HUMAN", ])
# Plot
plot(row_data1,
type = "l",                # Linienplot
main = "Plot for AHNK_HUMAN",
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2)
lines(row_data2,
type = "l",
col = "red",
lwd = 2)
row_data3 <- as.numeric(table.ctrl1.fit.fine["PRKDC_HUMAN", ])
row_data4 <- as.numeric(table.rnase1.fit.fine["PRKDC_HUMAN", ])
# Plot
plot(row_data3,
type = "l",                # Linienplot
main = "Plot for AHNK_HUMAN",
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2)
lines(row_data4,
type = "l",
col = "red",
lwd = 2)
row_data1 <- as.numeric(table.ctrl1.fit["PRKDC_HUMAN", ])
row_data2 <- as.numeric(table.rnase1.fit["PRKDC_HUMAN", ])
# Plot
plot(row_data1,
type = "l",                # Linienplot
main = "Plot for AHNK_HUMAN",
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2)
lines(row_data2,
type = "l",
col = "red",
lwd = 2)
row_data3 <- as.numeric(table.ctrl1.fit.fine["PRKDC_HUMAN", ])
row_data4 <- as.numeric(table.rnase1.fit.fine["PRKDC_HUMAN", ])
# Plot
plot(row_data4,
type = "l",                # Linienplot
main = "Plot for AHNK_HUMAN",
xlab = "Fractions",
ylab = "Values",
col = "blue",
lwd = 2)
lines(row_data3,
type = "l",
col = "red",
lwd = 2)
# T-Test pro Zeilenpaar
t_test_ergebnisse <- lapply(seq_len(nrow(df_numeric1)), function(i) {
x <- as.numeric(df_numeric1[i, ])
y <- as.numeric(df_numeric2[i, ])
# Nur t-Test, wenn beide Gruppen mindestens 2 gültige Werte haben
if (sum(!is.na(x)) >= 2 && sum(!is.na(y)) >= 2) {
t_res <- t.test(x, y)
data.frame(
zeile = rownames(df_numeric1)[i],
p_wert = t_res$p.value,
mittelwert_df1 = mean(x, na.rm = TRUE),
mittelwert_df2 = mean(y, na.rm = TRUE),
t_wert = t_res$statistic,
df = t_res$parameter
)
} else {
NULL
}
})
# Entferne NULLs (wo T-Test nicht möglich war)
t_test_ergebnisse <- Filter(Negate(is.null), t_test_ergebnisse)
# Ergebnisse zusammenführen
t_test_ergebnisse_df <- do.call(rbind, t_test_ergebnisse)
# Optional: Nach p-Wert sortieren
t_test_ergebnisse_df <- t_test_ergebnisse_df[order(t_test_ergebnisse_df$p_wert), ]
# Ausgabe
print(t_test_ergebnisse_df)
# T-Test pro Zeilenpaar
t_test_ergebnisse1 <- lapply(seq_len(nrow(df_numeric1)), function(i) {
x <- as.numeric(df_numeric1[i, ])
y <- as.numeric(df_numeric2[i, ])
# Nur t-Test, wenn beide Gruppen mindestens 2 gültige Werte haben
if (sum(!is.na(x)) >= 2 && sum(!is.na(y)) >= 2) {
t_res <- t.test(x, y)
data.frame(
zeile = rownames(df_numeric1)[i],
p_wert = t_res$p.value,
mittelwert_df1 = mean(x, na.rm = TRUE),
mittelwert_df2 = mean(y, na.rm = TRUE),
t_wert = t_res$statistic,
df = t_res$parameter
)
} else {
NULL
}
})
# Entferne NULLs (wo T-Test nicht möglich war)
t_test_ergebnisse1 <- Filter(Negate(is.null), t_test_ergebnisse)
# Ergebnisse zusammenführen
t_test_ergebnisse_df <- do.call(rbind, t_test_ergebnisse)
# Optional: Nach p-Wert sortieren
t_test_ergebnisse_df <- t_test_ergebnisse_df[order(t_test_ergebnisse_df$p_wert), ]
# Ausgabe
print(t_test_ergebnisse_df)
df1 <- table.ctrl1.fit[1:25] # Gruppe A
df2 <- table.rnase1.fit[1:25] # Gruppe B
df_numeric1 <- as.data.frame(lapply(df1, function(x) as.numeric(as.character(x))))
df_numeric2 <- as.data.frame(lapply(df2, function(x) as.numeric(as.character(x))))
colnames(df_numeric1) <- colnames(table.ctrl1.fit[1:25])
colnames(df_numeric2) <- colnames(table.rnase1.fit[1:25])
rownames(df_numeric1) <- rownames(table.ctrl1.fit[1:25])
rownames(df_numeric2) <- rownames(table.rnase1.fit[1:25])
# T-Test pro Zeilenpaar
t_test_ergebnisse <- lapply(seq_len(nrow(df_numeric1)), function(i) {
x <- as.numeric(df_numeric1[i, ])
y <- as.numeric(df_numeric2[i, ])
# Nur t-Test, wenn beide Gruppen mindestens 2 gültige Werte haben
if (sum(!is.na(x)) >= 2 && sum(!is.na(y)) >= 2) {
t_res <- t.test(x, y)
data.frame(
zeile = rownames(df_numeric1)[i],
p_wert = t_res$p.value,
mittelwert_df1 = mean(x, na.rm = TRUE),
mittelwert_df2 = mean(y, na.rm = TRUE),
t_wert = t_res$statistic,
df = t_res$parameter
)
} else {
NULL
}
})
# Entferne NULLs (wo T-Test nicht möglich war)
t_test_ergebnisse <- Filter(Negate(is.null), t_test_ergebnisse)
# Ergebnisse zusammenführen
t_test_ergebnisse_df <- do.call(rbind, t_test_ergebnisse)
# Optional: Nach p-Wert sortieren
t_test_ergebnisse_df <- t_test_ergebnisse_df[order(t_test_ergebnisse_df$p_wert), ]
# Ausgabe
print(t_test_ergebnisse_df)
df3 <- table.ctrl1.fit.fine # Gruppe A
df4 <- table.rnase1.fit.fine[1:25] # Gruppe B
df_numeric3 <- as.data.frame(lapply(df3, function(x) as.numeric(as.character(x))))
df_numeric4 <- as.data.frame(lapply(df4, function(x) as.numeric(as.character(x))))
colnames(df_numeric3) <- colnames(table.ctrl1.fit.fine[1:25])
colnames(df_numeric4) <- colnames(table.rnase1.fit.fine[1:25])
rownames(df_numeric3) <- rownames(table.ctrl1.fit[1:25])
df3 <- table.ctrl1.fit.fine # Gruppe A
df4 <- table.rnase1.fit.fine[1:25] # Gruppe B
df_numeric3 <- as.data.frame(lapply(df3, function(x) as.numeric(as.character(x))))
df_numeric4 <- as.data.frame(lapply(df4, function(x) as.numeric(as.character(x))))
colnames(df_numeric3) <- colnames(table.ctrl1.fit.fine[1:25])
colnames(df_numeric4) <- colnames(table.rnase1.fit.fine[1:25])
rownames(df_numeric3) <- rownames(table.ctrl1.fit.fine[1:25])
rownames(df_numeric4) <- rownames(table.rnase1.fit.fine[1:25])
# T-Test pro Zeilenpaar
t_test_ergebnisse2 <- lapply(seq_len(nrow(df_numeric3)), function(i) {
x <- as.numeric(df_numeric3[i, ])
y <- as.numeric(df_numeric4[i, ])
# Nur t-Test, wenn beide Gruppen mindestens 2 gültige Werte haben
if (sum(!is.na(x)) >= 2 && sum(!is.na(y)) >= 2) {
t_res2 <- t.test(x, y)
data.frame(
zeile = rownames(df_numeric3)[i],
p_wert = t_res2$p.value,
mittelwert_df3 = mean(x, na.rm = TRUE),
mittelwert_df4 = mean(y, na.rm = TRUE),
t_wert = t_res2$statistic,
df = t_res2$parameter
)
} else {
NULL
}
})
# Entferne NULLs (wo T-Test nicht möglich war)
t_test_ergebnisse2 <- Filter(Negate(is.null), t_test_ergebnisse2)
# Ergebnisse zusammenführen
t_test_ergebnisse_df2 <- do.call(rbind, t_test_ergebnisse2)
# Optional: Nach p-Wert sortieren
t_test_ergebnisse_df2 <- t_test_ergebnisse_df2[order(t_test_ergebnisse_df2$p_wert), ]
# Ausgabe
print(t_test_ergebnisse_df2)
