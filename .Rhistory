ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
View(ctrl_norm_mean)
ctrl_norm_mean1 <- Reduce("+", norm_tables.ctrl) / length(norm_tables.ctrl)
rnase_norm_mean <- Reduce("+", norm_tables.rnase) / length(norm_tables.rnase)
View(ctrl_norm_mean1)
# Funktion zum Ersetzen von NA und NaN durch 0
clean_table <- function(tbl) {
tbl <- rapply(tbl, function(x) ifelse(is.na(x), 0, x), how = "replace")
tbl <- rapply(tbl, function(x) ifelse(is.nan(x), 0, x), how = "replace")
return(tbl)
}
# Liste der Tabellen
tables.norm.ctrl <- list(
ctrl1 = table.ctrl1.SW.norm,
ctrl2 = table.ctrl2.SW.norm,
ctrl3 = table.ctrl3.SW.norm)
tables.norm.rnase <- list(
rnase1 = table.rnase1.SW.norm,
rnase2 = table.rnase2.SW.norm,
rnase3 = table.rnase3.SW.norm)
# Bereinigen
tables.norm.ctrl <- lapply(tables.norm.ctrl, clean_table)
tables.norm.rnase <- lapply(tables.norm.rnase, clean_table)
View(tables.norm.ctrl$ctrl1)
# Replace NA, NaN with 0 if any
table.ctrl1.SW.norm <- rapply(table.ctrl1.SW.norm, f=function(x) ifelse(is.na(x),0,x), how="replace")
table.ctrl2.SW.norm <- rapply(table.ctrl2.SW.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.ctrl3.SW.norm <- rapply(table.ctrl3.SW.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.rnase1.SW.norm <- rapply(table.rnase1.SW.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.rnase2.SW.norm <- rapply(table.rnase2.SW.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.rnase3.SW.norm <- rapply(table.rnase3.SW.norm, f=function(x) ifelse(is.na(x),0,x), how="replace" )
table.ctrl1.SW.norm <- rapply(table.ctrl1.SW.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace")
table.ctrl2.SW.norm <- rapply(table.ctrl2.SW.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.ctrl3.SW.norm <- rapply(table.ctrl3.SW.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.rnase1.SW.norm <- rapply(table.rnase1.SW.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.rnase2.SW.norm <- rapply(table.rnase2.SW.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
table.rnase3.SW.norm <- rapply(table.rnase3.SW.norm, f=function(x) ifelse(is.nan(x),0,x), how="replace" )
View(table.ctrl1.SW.norm)
# Average value for normalization of CTRL and RNASE samples to 100
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)
ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
print(ctrl_norm_mean)
# Average value for normalization of CTRL and RNASE samples to 100
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)
ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
View(ctrl_norm_mean)
# Average value for normalization of CTRL and RNASE samples to 100
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)
ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
print(ctrl_norm_mean)
# Change names of the columns: from "fraction1" to "fraction25"
col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
# Normalization to 100 for each protein (= the sum of the amount of protein from fraction1 to fraction25 is 100)
ctrl_norm_mean <- ctrl_norm_mean*100/rowSums(ctrl_norm_mean)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)
replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")
ctrl_norm_mean <- replace_na_nan(ctrl_norm_mean)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
# Change names of the columns: from "fraction1" to "fraction25"
col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean1) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
# Normalization to 100 for each protein (= the sum of the amount of protein from fraction1 to fraction25 is 100)
ctrl_norm_mean1 <- ctrl_norm_mean1*100/rowSums(ctrl_norm_mean1)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)
replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")
ctrl_norm_mean1 <- replace_na_nan(ctrl_norm_mean1)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
ctrl_norm_mean1[rowSums(rnase_norm_mean1[1:25])==0,] <- 0
# Change names of the columns: from "fraction1" to "fraction25"
col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean1) <- col_fractions
colnames(rnase_norm_mean1) <- col_fractions
# Change names of the columns: from "fraction1" to "fraction25"
col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
# Change names of the columns: from "fraction1" to "fraction25"
col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
# Normalization to 100 for each protein (= the sum of the amount of protein from fraction1 to fraction25 is 100)
ctrl_norm_mean <- ctrl_norm_mean*100/rowSums(ctrl_norm_mean)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)
replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")
ctrl_norm_mean <- replace_na_nan(ctrl_norm_mean)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
View(ctrl_norm_mean)
# If one of the curve is 0 over all the fractions of one condition, the other condition will be set to 0 to take it out of the analysis
ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
View()
# Change names of the columns: from "fraction1" to "fraction25"
col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_nor_mean) <- col_fractions
# Average value for normalization of CTRL and RNASE samples to 100
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)
ctrl_nor_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_nor_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
print(ctrl_norm_mean)
# Change names of the columns: from "fraction1" to "fraction25"
col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_nor_mean) <- col_fractions
colnames(rnase_nor_mean) <- col_fractions
# Normalization to 100 for each protein (= the sum of the amount of protein from fraction1 to fraction25 is 100)
ctrl_nor_mean <- ctrl_nor_mean*100/rowSums(ctrl_nor_mean)
rnase_nor_mean <- rnase_nor_mean*100/rowSums(rnase_nor_mean)
# Replace the NaN and NA values by 0 if any
ctrl_nor_mean <- rapply(ctrl_nor_mean, f=function(x) ifelse(is.nan(x),0,x), how="replace")
rnase_nor_mean <- rapply(rnase_nor_mean, f=function(x) ifelse(is.nan(x),0,x), how="replace")
ctrl_nor_mean <- rapply(ctrl_nor_mean, f=function(x) ifelse(is.na(x),0,x), how="replace")
rnase_nor_mean <- rapply(rnase_nor_mean, f=function(x) ifelse(is.na(x),0,x), how="replace")
# If one of the curve is 0 over all the fractions of one condition, the other condition will be set to 0 to take it out of the analysis
ctrl_nor_mean[rowSums(rnase_nor_mean[1:25])==0,] <- 0
rnase_nor_mean[rowSums(ctrl_nor_mean[1:25])==0,] <- 0
View()
# If one of the curve is 0 over all the fractions of one condition, the other condition will be set to 0 to take it out of the analysis
ctrl_nor_mean[rowSums(rnase_nor_mean[1:25])==0,] <- 0
rnase_nor_mean[rowSums(ctrl_nor_mean[1:25])==0,] <- 0
View(ctrl_nor_mean)
ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
View(ctrl_norm_mean)
# Average value for normalization of CTRL and RNASE samples to 100
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)
ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
# Average value for normalization of CTRL and RNASE samples to 100
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)
ctrl_nor_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_nor_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
#### Normaliztion over the amount to sum = 100 (%) ####
table.ctrl1.SW.norm <- table.ctrl1.SW * 100 / rowSums(table.ctrl1.SW)
table.ctrl2.SW.norm <- table.ctrl2.SW * 100 / rowSums(table.ctrl2.SW)
table.ctrl3.SW.norm <- table.ctrl3.SW * 100 / rowSums(table.ctrl3.SW)
table.rnase1.SW.norm <- table.rnase1.SW * 100 / rowSums(table.rnase1.SW)
table.rnase2.SW.norm <- table.rnase2.SW * 100 / rowSums(table.rnase2.SW)
table.rnase3.SW.norm <- table.rnase3.SW * 100 / rowSums(table.rnase3.SW)
# Funktion zur Zeilennormalisierung (auf 100 %)
normalize_table <- function(tbl) {
tbl * 100 / rowSums(tbl)
}
tables.ctrl <- list(
ctrl1 = table.ctrl1.SW,
ctrl2 = table.ctrl2.SW,
ctrl3 = table.ctrl3.SW)
tables.rnase <- list(
rnase1 = table.rnase1.SW,
rnase2 = table.rnase2.SW,
rnase3 = table.rnase3.SW)
norm_tables.ctrl <- lapply(tables.ctrl, normalize_table)
norm_tables.rnase <- lapply(tables.rnase, normalize_table)
norm_tables.rnase$rnase1
#### Apply a sliding window/moving average of 3 points to the data ####
smooth_table <- function(tbl) {
data.frame(tbl[1], (tbl[1:23] + tbl[2:24] + tbl[3:25]) / 3, tbl[25])
}
table.ctrl1.SW <- smooth_table(table.ctrl1)
table.ctrl2.SW <- smooth_table(table.ctrl2)
table.ctrl3.SW <- smooth_table(table.ctrl3)
table.rnase1.SW <- smooth_table(table.rnase1)
table.rnase2.SW <- smooth_table(table.rnase2)
table.rnase3.SW <- smooth_table(table.rnase3)
# Get the proper rownames for the tables
colnames(table.ctrl1.SW) <- colnames(table.ctrl1)
colnames(table.ctrl2.SW) <- colnames(table.ctrl2)
colnames(table.ctrl3.SW) <- colnames(table.ctrl3)
colnames(table.rnase1.SW) <- colnames(table.rnase1)
colnames(table.rnase2.SW) <- colnames(table.rnase2)
colnames(table.rnase3.SW) <- colnames(table.rnase3)
View(table.ctrl1.SW)
#### Normaliztion over the amount to sum = 100 (%) ####
# Funktion zur Zeilennormalisierung (auf 100 %)
normalize_table <- function(tbl) {
tbl * 100 / rowSums(tbl)
}
tables.ctrl <- list(
ctrl1 = table.ctrl1.SW,
ctrl2 = table.ctrl2.SW,
ctrl3 = table.ctrl3.SW)
tables.rnase <- list(
rnase1 = table.rnase1.SW,
rnase2 = table.rnase2.SW,
rnase3 = table.rnase3.SW)
norm_tables.ctrl <- lapply(tables.ctrl, normalize_table)
norm_tables.rnase <- lapply(tables.rnase, normalize_table)
norm_tables.rnase$rnase1
# Replace NA, NaN with 0 if any
# Funktion zum Ersetzen von NA und NaN durch 0
clean_table <- function(tbl) {
tbl <- rapply(tbl, function(x) ifelse(is.na(x), 0, x), how = "replace")
tbl <- rapply(tbl, function(x) ifelse(is.nan(x), 0, x), how = "replace")
return(tbl)
}
# Liste der Tabellen
tables.norm.ctrl <- list(
ctrl1 = table.ctrl1.SW.norm,
ctrl2 = table.ctrl2.SW.norm,
ctrl3 = table.ctrl3.SW.norm)
tables.norm.rnase <- list(
rnase1 = table.rnase1.SW.norm,
rnase2 = table.rnase2.SW.norm,
rnase3 = table.rnase3.SW.norm)
# Bereinigen
tables.norm.ctrl <- lapply(tables.norm.ctrl, clean_table)
tables.norm.rnase <- lapply(tables.norm.rnase, clean_table)
View(tables.norm.ctrl$ctrl1)
# Average value for normalization of CTRL and RNASE samples to 100
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)
ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
# Change names of the columns: from "fraction1" to "fraction25"
col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
# Normalization to 100 for each protein (= the sum of the amount of protein from fraction1 to fraction25 is 100)
ctrl_norm_mean <- ctrl_norm_mean*100/rowSums(ctrl_norm_mean)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)
# Replace the NaN and NA values by 0 if any
replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")
ctrl_norm_mean <- replace_na_nan(ctrl_norm_mean)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
# If one of the curve is 0 over all the fractions of one condition, the other condition will be set to 0 to take it out of the analysis
ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
View(ctrl_nor_mean)
# If one of the curve is 0 over all the fractions of one condition, the other condition will be set to 0 to take it out of the analysis
ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
View(ctrl_norm_mean)
# If one of the curve is 0 over all the fractions of one condition, the other condition will be set to 0 to take it out of the analysis
ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
View(ctrl_norm_mean)
# Get the proper rownames for the tables
rownames(table.ctrl1) <- row_names
rownames(table.ctrl2) <- row_names
rownames(table.ctrl3) <- row_names
rownames(table.rnase1) <- row_names
rownames(table.rnase2) <- row_names
rownames(table.rnase3) <- row_names
View(table.ctrl1)
# Get the proper rownames for the tables
colnames(table.ctrl1.SW) <- colnames(table.ctrl1)
colnames(table.ctrl2.SW) <- colnames(table.ctrl2)
colnames(table.ctrl3.SW) <- colnames(table.ctrl3)
colnames(table.rnase1.SW) <- colnames(table.rnase1)
colnames(table.rnase2.SW) <- colnames(table.rnase2)
colnames(table.rnase3.SW) <- colnames(table.rnase3)
View(table.ctrl1.SW)
#Reads table, by indicating path to directory where the dataset is stored, and stores it to variable NS_Table (NS for Non-synchronizied HeLa-cells)
NS_Table <- read.table("Daten/Daten_Kommata_behoben.csv", header=TRUE, row.names=1, sep = ";")
#The first 12 titles of the table (NS_Table) rows/colums are read out
#Row names are protein names
head(rownames(NS_Table),12)
#Columns indicate the respective fractions from 1 to 25, and their replicated
head(colnames(NS_Table),12)
#A vector consists of 2 variables (CTRL, RNASE) --> c("CTRL", "RNASE")
#The factor() function encodes a vector as a factor. The 2 variables CTRL and RNASE are ordered into 2 different levels (characters)
#rep(vector,75) repeats the factor() function 75 times, because we have 150 columns (75 times CTRL and RNASE)
#The factor is defined as the variable 'treatment'
levels_CR <- factor(rep(c("CTRL", "RNASE"),75))
#Every sample of every fraction gets its own level to disconnect them from each other -> 6 levels per fraction because we have 3 CTRLs and 3 RNASEs per fraction
levels_fraction <- factor(rep(c("Ctrl_Rep1","RNase_Rep1","Ctrl_Rep2","RNase_Rep2","Ctrl_Rep3","RNase_Rep3"),25))
View(levels_fraction)
# Creation of a matrix with 6 rows and 25 columns. The matrix is filled by row from fraction1 to fraction25 so every column has one single fraction.
# sep="" compares the word fraction with the numbers 1 to 25 without a blank space.
# paste("fraction",1:25,sep="") creates a vector with the strings fraction1 to fraction25
# as.vector changes the created matrix into a vector with 150 elements sorted from 6 times fraction1 to 6 times fraction25
fraction_names <- as.vector(matrix(rep(paste("fraction",1:25,sep=""),6), nrow = 6, ncol=25, byrow = TRUE))
View(matrix(rep(paste("fraction",1:25,sep=""),6), nrow = 6, ncol=25, byrow = TRUE))
# The number of rows are stored in a variable
n_row <- nrow(NS_Table)
# The row names (protein names) are stored in a variable
row_names <- rownames(NS_Table)
# Creation of a data frame with levels_CR, levels_fraction and fraction_names. This assigns every replicate of the factions (levels_fraction) to their fraction (fraction_names) and their kind of treatment, CRTL or RNASE (levels_CR).
colmns_sorted <- data.frame(row.names = colnames(NS_Table), levels_CR = levels_CR, levels_fraction = levels_fraction, fraction_names = fraction_names)
View(colmns_sorted)
#Check for missing values, there are none
anyNA(NS_Table)
# lapply executes for every with paste  created string (the fractions) a function fx
# colmns_sorted$fraction == fx: checks which columns are part of the fractions fx
# NS_Table[, ...] filters just these columns and assigns them to the list "fraction.tables"
# names(fraction.tables): the list "fraction.tables" gets names for its segments and assigns them to the variable selected_proteins
fraction.tables <- lapply(paste("fraction", 1:25, sep = ""), function(fx) {NS_Table[, colmns_sorted$fraction == fx]})
names(fraction.tables) <- paste("fraction", 1:25, sep = "")
selected_proteins <- names(fraction.tables)
# List with just CTRL/RNASE columns for each fraction
# subset filters just the fractions that fulfill the conditions: fraction_names == fx --> fraction name is part of the funtion fx, levels_CR == "CTRL" --> protein was treated as a CTRL
# rownames() takes the rownames of the filtert fractions and asigns them to the variable col
# NS_Table[, cols, drop = FALSE] the names that are part of NS_Table are filterd out and drop = FALSE makes sure that fraction.tables.CTRL will be a dataframe
# Liste mit nur CTRL-Spalten für jede Fraktion
fraction.tables.CTRL <- lapply(selected_proteins, function(fx) {
cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "CTRL"))
NS_Table[, cols, drop = FALSE]
})
# Liste mit nur RNASE-Spalten für jede Fraktion
fraction.tables.RNASE <- lapply(selected_proteins, function(fx) {
cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "RNASE"))
NS_Table[, cols, drop = FALSE]})
names(fraction.tables.CTRL) <- selected_proteins
names(fraction.tables.RNASE) <- selected_proteins
View(fraction.tables.CTRL[["fraction3"]])
# sapply(df, mean) calculates the mean of every column of the dataframe fraction.tables.CTRL
avg.tables.CTRL <- lapply(fraction.tables.CTRL, function(df) {
sapply(df, mean)
})
avg.tables.RNASE <- lapply(fraction.tables.RNASE, function(df) {
sapply(df, mean)
})
avg.tables.CTRL[["fraction1"]]
avg.tables.RNASE[["fraction1"]]
#--> prinzpiell wird mit diesem Code gesagt, dass mindestens 1 Wert immer ein Messfehler sein muss, müssen wir uns überlegen, ob wir das genauso machen wollen oder ob wir alle 3 Messwerte mit einbeziehen.
# Determine normalization factor for each condition (i.e. sample), as the mean of the 2 most similar replicates.
# Create a function norm_fact for this step:
norm_fact <- function(x) {
if( (abs(x[1]-x[2])<abs(x[1]-x[3])) && (abs(x[1]-x[2])<abs(x[2]-x[3])) )
{mean(c(x[1],x[2]))} else if( (abs(x[1]-x[3])<abs(x[1]-x[2])) && (abs(x[1]-x[3])<abs(x[2]-x[3])) )
{mean(c(x[1],x[3]))} else {mean(c(x[2],x[3]))}
}
print(norm_fact(avg.tables.CTRL[["fraction1"]]))
# normalization of the mean value vectors - inversely proportional to the size of the values
# norm_factor / vec: gives a new vector indicating how strong each element is relative to the norm factor (mean)
norm_mean_frxn_CTRL <- lapply(avg.tables.CTRL, function(vec) {
norm_factor <- norm_fact(vec)
norm_factor / vec
})
norm_mean_frxn_RNASE <- lapply(avg.tables.RNASE, function(vec) {
norm_factor <- norm_fact(vec)
norm_factor / vec
})
print(norm_mean_frxn_CTRL[[1]])
# Correction factor for the overall protein quantity
# Normalization vectors for replicates 1-3
# function(x) x[1]: extracts the first element of each vector in the list
# norm.ctrl1 is a numeric vector consisting of the 1st element of each normalized CTRL vector
norm.ctrl1 <- sapply(norm_mean_frxn_CTRL, function(x) x[1])
norm.ctrl2 <- sapply(norm_mean_frxn_CTRL, function(x) x[2])
norm.ctrl3 <- sapply(norm_mean_frxn_CTRL, function(x) x[3])
norm.rnase1 <- sapply(norm_mean_frxn_RNASE, function(x) x[1])
norm.rnase2 <- sapply(norm_mean_frxn_RNASE, function(x) x[2])
norm.rnase3 <- sapply(norm_mean_frxn_RNASE, function(x) x[3])
# Defines logical vectors (TRUE, FALSE), which are later used to create subtables - separately for treatment (Ctrl vs. RNase) and replica (Rep1, Rep2, Rep3)
# colmns_sorted$levels_fraction =="Ctrl_Rep1": checks at which position exactly in the columns_sorted Ctrl_Rep1 can be found (marks it with TRUE)
data.ctrl1 <- colmns_sorted$levels_fraction =="Ctrl_Rep1"
data.ctrl2 <- colmns_sorted$levels_fraction =="Ctrl_Rep2"
data.ctrl3 <- colmns_sorted$levels_fraction =="Ctrl_Rep3"
data.rnase1 <- colmns_sorted$levels_fraction =="RNase_Rep1"
data.rnase2 <- colmns_sorted$levels_fraction =="RNase_Rep2"
data.rnase3 <- colmns_sorted$levels_fraction =="RNase_Rep3"
# Normalization step, fraction-wise
# takes specific columns from the protein intensity table and scales each row according to a normalization factor to compensate for measurement differences between replicates
# mask: A logical vector (TRUE/FALSE) that specifies which columns of NS_Table are selected
# selected <- NS_Table[, mask]: from NS_Table only the columns marked with TRUE in mask are selected
# (`*`, selected, norm_vec, SIMPLIFY = FALSE): Multiplication of colums of selected and the vector norm_vec saved as a list
normalize_group <- function(mask, norm_vec) {
selected <- NS_Table[, mask]
as.data.frame(mapply(`*`, selected, norm_vec, SIMPLIFY = FALSE))
}
# logical vectors (data.ctrl1) and vectors with normalization-factors (norm.ctrl1) form groups
# normalize_group(): multiplication of the vectors with their normalization-factor
table.ctrl1  <- normalize_group(data.ctrl1,  norm.ctrl1)
table.ctrl2  <- normalize_group(data.ctrl2,  norm.ctrl2)
table.ctrl3  <- normalize_group(data.ctrl3,  norm.ctrl3)
table.rnase1 <- normalize_group(data.rnase1, norm.rnase1)
table.rnase2 <- normalize_group(data.rnase2, norm.rnase2)
table.rnase3 <- normalize_group(data.rnase3, norm.rnase3)
# Get the proper rownames for the tables
rownames(table.ctrl1) <- row_names
rownames(table.ctrl2) <- row_names
rownames(table.ctrl3) <- row_names
rownames(table.rnase1) <- row_names
rownames(table.rnase2) <- row_names
rownames(table.rnase3) <- row_names
View(table.ctrl1)
# Apply a sliding window/moving average of 3 points to the data to reduce noise in the data and obtain smoother curves (not possible for fraction 1 and 25)
smooth_table <- function(tbl) {
data.frame(tbl[1], (tbl[1:23] + tbl[2:24] + tbl[3:25]) / 3, tbl[25])
}
table.ctrl1.SW <- smooth_table(table.ctrl1)
table.ctrl2.SW <- smooth_table(table.ctrl2)
table.ctrl3.SW <- smooth_table(table.ctrl3)
table.rnase1.SW <- smooth_table(table.rnase1)
table.rnase2.SW <- smooth_table(table.rnase2)
table.rnase3.SW <- smooth_table(table.rnase3)
# Get the proper rownames for the tables
colnames(table.ctrl1.SW) <- colnames(table.ctrl1)
colnames(table.ctrl2.SW) <- colnames(table.ctrl2)
colnames(table.ctrl3.SW) <- colnames(table.ctrl3)
colnames(table.rnase1.SW) <- colnames(table.rnase1)
colnames(table.rnase2.SW) <- colnames(table.rnase2)
colnames(table.rnase3.SW) <- colnames(table.rnase3)
View(table.ctrl1.SW)
# Normalization of the fractions: Sum of all fraction values equals 100 (%)
normalize_table <- function(tbl) {
tbl * 100 / rowSums(tbl)
}
tables.ctrl <- list(
ctrl1 = table.ctrl1.SW,
ctrl2 = table.ctrl2.SW,
ctrl3 = table.ctrl3.SW)
tables.rnase <- list(
rnase1 = table.rnase1.SW,
rnase2 = table.rnase2.SW,
rnase3 = table.rnase3.SW)
# Calculation of the percentages of the fractions in the normalized table (table.ctrl1.SW)
norm_tables.ctrl <- lapply(tables.ctrl, normalize_table)
norm_tables.rnase <- lapply(tables.rnase, normalize_table)
norm_tables.rnase$rnase1
# Function for replacing NA and NaN with 0
clean_table <- function(tbl) {
tbl <- rapply(tbl, function(x) ifelse(is.na(x), 0, x), how = "replace")
tbl <- rapply(tbl, function(x) ifelse(is.nan(x), 0, x), how = "replace")
return(tbl)
}
tables.norm.ctrl <- list(
ctrl1 = table.ctrl1.SW.norm,
ctrl2 = table.ctrl2.SW.norm,
ctrl3 = table.ctrl3.SW.norm)
tables.norm.rnase <- list(
rnase1 = table.rnase1.SW.norm,
rnase2 = table.rnase2.SW.norm,
rnase3 = table.rnase3.SW.norm)
# Getting the clean table
tables.norm.ctrl <- lapply(tables.norm.ctrl, clean_table)
tables.norm.rnase <- lapply(tables.norm.rnase, clean_table)
View(tables.norm.ctrl$ctrl1)
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)
# Addition of all data-frames in the list my.list.ctrl.norm (element-wise) and Division of the Sum with 3 to get the mean of all 3 replicates
ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
# Change names of the columns: from "fraction1" to "fraction25"
col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
# second normalization of the fractions (mean destroyed first normalization): Sum of all fraction values equals 100 (%)
ctrl_norm_mean <- ctrl_norm_mean*100/rowSums(ctrl_norm_mean)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)
# Function for replacing NA and NaN with 0
replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")
ctrl_norm_mean <- replace_na_nan(ctrl_norm_mean)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
# If a curve is 0 in all fractions, the other fraction is also set to 0 and is excluded from the analysis
ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
View(ctrl_norm_mean)
# Define the function find_peaks
# A "peak" is defined as a local maxima with m points either side of it being smaller than it.
# Hence, the bigger the parameter m, the more stringent the peak finding procedure
# m set to 2
find_peaks <- function (x, m = 2){
shape <- diff(sign(diff(x, na.pad = FALSE)))
pks <- sapply(which(shape < 0), FUN = function(i){
z <- i - m + 1
z <- ifelse(z > 0, z, 1)
w <- i + m + 1
w <- ifelse(w < length(x), w, length(x))
if(all(x[c(z : i, (i + 2) : w)] <= x[i + 1])) return(i + 1) else return(numeric(0))
})
pks <- unlist(pks)
# If a curve is 0 in all fractions, the other fraction is also set to 0 and is excluded from the analysis
ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
View(ctrl_norm_mean)
View(rnase_norm_mean)
# If a curve is 0 in all fractions, the other fraction is also set to 0 and is excluded from the analysis
ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
View(ctrl_norm_mean)
View(rnase_norm_mean)
View(table.frxn16)
#Reads table, by indicating path to directory where the dataset is stored, and stores it to variable NS_Table (NS for Non-synchronizied HeLa-cells)
NS_Table <- read.table("Daten/Daten_Kommata_behoben.csv", header=TRUE, row.names=1, sep = ";")
View(NS_Table)
#Reads table, by indicating path to directory where the dataset is stored, and stores it to variable NS_Table (NS for Non-synchronizied HeLa-cells)
NS_Table <- read.table("Daten/Daten_Kommata_behoben.csv", header=TRUE, row.names=1, sep = ";")
#Reads table, by indicating path to directory where the dataset is stored, and stores it to variable NS_Table (NS for Non-synchronizied HeLa-cells)
NS_Table <- read.table("Daten/Daten_Kommata_behoben.csv", header=TRUE, row.names=1, sep = ";")
View(NS_Table)
#Reads table, by indicating path to directory where the dataset is stored, and stores it to variable NS_Table (NS for Non-synchronizied HeLa-cells)
NS_Table <- read.table("Daten/Data, copy but dont open.csv", header=TRUE, row.names=1, sep = ";")
View(NS_Table)
#The first 12 titles of the table (NS_Table) rows/colums are read out
#Row names are protein names
head(rownames(NS_Table),12)
#Columns indicate the respective fractions from 1 to 25, and their replicated
head(colnames(NS_Table),12)
#A vector consists of 2 variables (CTRL, RNASE) --> c("CTRL", "RNASE")
#The factor() function encodes a vector as a factor. The 2 variables CTRL and RNASE are ordered into 2 different levels (characters)
#rep(vector,75) repeats the factor() function 75 times, because we have 150 columns (75 times CTRL and RNASE)
#The factor is defined as the variable 'treatment'
levels_CR <- factor(rep(c("CTRL", "RNASE"),75))
levels_CR
#Every sample of every fraction gets its own level to disconnect them from each other -> 6 levels per fraction because we have 3 CTRLs and 3 RNASEs per fraction
levels_fraction <- factor(rep(c("Ctrl_Rep1","RNase_Rep1","Ctrl_Rep2","RNase_Rep2","Ctrl_Rep3","RNase_Rep3"),25))
View(levels_fraction)
