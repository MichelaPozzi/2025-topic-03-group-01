**************************************************************************************************************

Proteome-wide screen for RNA-dependent proteins in non-synchronized HeLa cells
Molecular Biotechnology - Data science project summer term 2025
Julian Baureis, Julia Ferdin, Benjamin Nicklas, Luisa Wintel
Supervisors: Maïwen Caudron-Herger and Michela Pozzi 

**************************************************************************************************************

1. Load dataset
2. Data cleanup
3. Normalization
3. Identification of local maxima as fit parameters
4. Identification of shoulders
5. Total count of maxima (peaks and shoulders) per protein
6. Identification of proteins with different maxima amount in ctrl vs rnase
7. Criteria for selecting RNA-dependent proteins
8. Wilcoxon rank-sum test
9. Principle component analysis
10. k-means clustering
11. Linear regression analysis


**************************************************************************************************************
1. Load dataset and inspect row/column names 
  by Julia Ferdin
**************************************************************************************************************

```{r}
#Reads table by indicating path to directory where the dataset is stored, and stores it to variable NS_Table (NS for Non-synchronizied HeLa-cells)

NS_Table <- read.table("Daten/Data, copy but dont open.csv", header=TRUE, row.names=1, sep = ";")
```

```{r}
#The first 12 titles of the table (NS_Table) rows/colums are read out

#Row names are protein names
head(rownames(NS_Table),12)

#Columns indicate the respective fractions from 1 to 25, and their replicates
head(colnames(NS_Table),12)
```

**************************************************************************************************************
2. Data cleanup - Rearrange and reorder the columns to their treatment, replicate and fraction
  by Julia Ferdin
**************************************************************************************************************

Define sample by using vectors for different conditions (treatment, replicates, fractions):
  levels_CR → was sample treated with CTRL or RNASE
  levels_fraction → labels the column with the replicate number (1–3) for either CTRL or RNASE
  fraction_names → creates the variables fraction1 to fraction25 to assign the replicates to each fraction

```{r}
#A vector consists of 2 variables (CTRL, RNASE) --> c("CTRL", "RNASE")
#The factor() function encodes a vector as a factor. The 2 variables CTRL and RNASE are ordered into 2 different levels (characters)
#rep(vector,75) repeats the factor() function 75 times, because we have 150 columns (75 times CTRL and RNASE)
#The factor is defined as the variable 'treatment'

levels_CR <- factor(rep(c("CTRL", "RNASE"),75))
```

```{r}
#Every sample of every fraction gets its own level to disconnect them from each other -> 6 levels per fraction because we have 3 CTRLs and 3 RNASEs per fraction

levels_fraction <- factor(rep(c("Ctrl_Rep1","RNase_Rep1","Ctrl_Rep2","RNase_Rep2","Ctrl_Rep3","RNase_Rep3"),25))
```

```{r}
# Creation of a matrix with 6 rows and 25 columns. The matrix is filled by row from fraction1 to fraction25 so every column has one single fraction.
# sep="" compares the word fraction with the numbers 1 to 25 without a blank space.
# paste("fraction",1:25,sep="") creates a vector with the strings fraction1 to fraction25
# as.vector changes the created matrix into a vector with 150 elements sorted from 6 times fraction1 to 6 times fraction25

fraction_names <- as.vector(matrix(rep(paste("fraction",1:25,sep=""),6), nrow = 6, ncol=25, byrow = TRUE))
```

**************************************************************************************************************
Create Metadata Data Frame and Check for Missing Values

```{r}
# The number of rows are stored in a variable
n_row <- nrow(NS_Table)

# The row names (protein names) are stored in a variable
row_names <- rownames(NS_Table)
```

```{r}
# Creation of a data frame with levels_CR, levels_fraction and fraction_names. This assigns every replicate of the factions (levels_fraction) to their fraction (fraction_names) and their kind of treatment, CRTL or RNASE (levels_CR).

colmns_sorted <- data.frame(row.names = colnames(NS_Table), levels_CR = levels_CR, levels_fraction = levels_fraction, fraction_names = fraction_names)

#Check for missing values, there are none 
anyNA(NS_Table)
```

**************************************************************************************************************
3. Normalization step between the replicates in each fraction and for each treatment using the mean value method
  by Benjamin Nicklas influenced by ChatGPT
**************************************************************************************************************

Split data by fractions and treatment (CTRL vs RNASE)

```{r}
# lapply executes for every with paste created string (the fractions) a function fx
# colmns_sorted$fraction == fx: checks which columns are part of the fractions fx
# NS_Table[, ...] filters just these columns and assigns them to the list "fraction.tables"
# names(fraction.tables): the list "fraction.tables" gets names for its segments and assigns them to the variable selected_proteins 

fraction.tables <- lapply(paste("fraction", 1:25, sep = ""), function(fx) {NS_Table[, colmns_sorted$fraction_names == fx]})

names(fraction.tables) <- paste("fraction", 1:25, sep = "")

selected_proteins <- names(fraction.tables)
```

```{r}
# List with just CTRL/RNASE columns for each fraction
# subset filters just the fractions that fulfill the conditions: fraction_names == fx --> fraction name is part of the function fx, levels_CR == "CTRL" --> protein was treated as a CTRL
# rownames() takes the rownames of the filtered fractions and assigns them to the variable col
# NS_Table[, cols, drop = FALSE] the names that are part of NS_Table are filtered out and drop = FALSE makes sure that fraction.tables.CTRL will be a dataframe

# List with only CTRL columns for each fraction
fraction.tables.CTRL <- lapply(selected_proteins, function(fx) {
  cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "CTRL")) 
  NS_Table[, cols, drop = FALSE]
  })

# List with only CTRL rows for each fraction
fraction.tables.RNASE <- lapply(selected_proteins, function(fx) {
  cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "RNASE"))
  NS_Table[, cols, drop = FALSE]})

names(fraction.tables.CTRL) <- selected_proteins
names(fraction.tables.RNASE) <- selected_proteins
```

**************************************************************************************************************

Calculate Mean Protein Intensities per Fraction and Treatment

```{r}
# sapply(df, mean) calculates the mean of every column of the dataframe fraction.tables.CTRL
# For every condition (e.g. fraction 1, Ctrl, Rep 1) the mean over the proteins is taken which is a single value per condition

avg.tables.CTRL <- lapply(fraction.tables.CTRL, function(df) {
  sapply(df, mean)
})

avg.tables.RNASE <- lapply(fraction.tables.RNASE, function(df) {
  sapply(df, mean)
})
```

Calculate Normalization Factors Based on Most Similar Replicates

```{r}
# Determine normalization factor for each condition (i.e. sample), as the mean of the 2 most similar replicates.
# Create a function norm_fact for this step:

norm_fact <- function(x) {
				if( (abs(x[1]-x[2])<abs(x[1]-x[3])) && (abs(x[1]-x[2])<abs(x[2]-x[3])) ) 
					{mean(c(x[1],x[2]))} else if( (abs(x[1]-x[3])<abs(x[1]-x[2])) && (abs(x[1]-x[3])<abs(x[2]-x[3])) )
												  {mean(c(x[1],x[3]))} else {mean(c(x[2],x[3]))} 
}
```

Normalize Mean Intensities for Each Fraction and Treatment

```{r}
# Normalization of the mean vectors
# norm_factor <- norm_fact(vec): The function norm_fact is applied to every vector in the list avg.tables.CTRL (length 3)
# norm_factor / vec: Results in new vector of length 3 and represents a correcting factor for the single replicates in order to align the amount of protein of the replicates

norm_mean_frxn_CTRL <- lapply(avg.tables.CTRL, function(vec) {
  norm_factor <- norm_fact(vec)
  norm_factor / vec 
})

norm_mean_frxn_RNASE <- lapply(avg.tables.RNASE, function(vec) {
  norm_factor <- norm_fact(vec)
  norm_factor / vec 
})
```

Extract Normalization Factors for Each Replicate and Treatment

```{r}
# Correction factor for the overall protein quantity
# Normalization vectors for replicates 1-3
# function(x) x[1]: extracts the first element of each vector in the list
# norm.ctrl1 is a numeric vector consisting of the 1st element of each normalized CTRL vector

norm.ctrl1 <- sapply(norm_mean_frxn_CTRL, function(x) x[1])
norm.ctrl2 <- sapply(norm_mean_frxn_CTRL, function(x) x[2])
norm.ctrl3 <- sapply(norm_mean_frxn_CTRL, function(x) x[3])

norm.rnase1 <- sapply(norm_mean_frxn_RNASE, function(x) x[1])
norm.rnase2 <- sapply(norm_mean_frxn_RNASE, function(x) x[2])
norm.rnase3 <- sapply(norm_mean_frxn_RNASE, function(x) x[3])
```

```{r}
# Defines logical vectors (TRUE, FALSE), which are later used to create subtables - separately for treatment (Ctrl vs. RNase) and replica (Rep1, Rep2, Rep3)
# colmns_sorted$levels_fraction =="Ctrl_Rep1": checks at which position exactly in the columns_sorted Ctrl_Rep1 can be found (marks it with TRUE)

data.ctrl1 <- colmns_sorted$levels_fraction =="Ctrl_Rep1"
data.ctrl2 <- colmns_sorted$levels_fraction =="Ctrl_Rep2"
data.ctrl3 <- colmns_sorted$levels_fraction =="Ctrl_Rep3"
data.rnase1 <- colmns_sorted$levels_fraction =="RNase_Rep1"
data.rnase2 <- colmns_sorted$levels_fraction =="RNase_Rep2"
data.rnase3 <- colmns_sorted$levels_fraction =="RNase_Rep3"
```

Normalize Protein Intensity Data

```{r}
# Normalization step, fraction-wise
# takes specific columns from the protein intensity table and scales each row according to a normalization factor to compensate for measurement differences between replicates
# mask: A logical vector (TRUE/FALSE) that specifies which columns of NS_Table are selected
# selected <- NS_Table[, mask]: from NS_Table only the columns marked with TRUE in mask are selected
# (`*`, selected, norm_vec, SIMPLIFY = FALSE): Multiplication of colums of selected and the vector norm_vec saved as a list

normalize_group <- function(mask, norm_vec) {
  selected <- NS_Table[, mask]                  
  as.data.frame(mapply(`*`, selected, norm_vec, SIMPLIFY = FALSE))
}

# logical vectors (data.ctrl1) and vectors with normalization-factors (norm.ctrl1) form groups
# normalize_group(): multiplication of the vectors with their normalization-factor

table.ctrl1  <- normalize_group(data.ctrl1,  norm.ctrl1)
table.ctrl2  <- normalize_group(data.ctrl2,  norm.ctrl2)
table.ctrl3  <- normalize_group(data.ctrl3,  norm.ctrl3)
table.rnase1 <- normalize_group(data.rnase1, norm.rnase1)
table.rnase2 <- normalize_group(data.rnase2, norm.rnase2)
table.rnase3 <- normalize_group(data.rnase3, norm.rnase3)
```

```{r}
# Get the proper rownames for the tables

rownames(table.ctrl1) <- row_names
rownames(table.ctrl2) <- row_names
rownames(table.ctrl3) <- row_names
rownames(table.rnase1) <- row_names
rownames(table.rnase2) <- row_names
rownames(table.rnase3) <- row_names
```

Smooth Data with Sliding Window (Moving Average of 3 Fractions)

```{r}
# Apply a sliding window/moving average of 3 points to the data to reduce noise in the data and obtain smoother curves (not possible for fraction 1 and 25)

smooth_table <- function(tbl) {
  data.frame(tbl[1], (tbl[1:23] + tbl[2:24] + tbl[3:25]) / 3, tbl[25])
}

table.ctrl1.SW <- smooth_table(table.ctrl1)
table.ctrl2.SW <- smooth_table(table.ctrl2)
table.ctrl3.SW <- smooth_table(table.ctrl3)
table.rnase1.SW <- smooth_table(table.rnase1)
table.rnase2.SW <- smooth_table(table.rnase2)
table.rnase3.SW <- smooth_table(table.rnase3)
```

```{r}
# Get the proper rownames for the tables

colnames(table.ctrl1.SW) <- colnames(table.ctrl1)
colnames(table.ctrl2.SW) <- colnames(table.ctrl2)
colnames(table.ctrl3.SW) <- colnames(table.ctrl3)
colnames(table.rnase1.SW) <- colnames(table.rnase1)
colnames(table.rnase2.SW) <- colnames(table.rnase2)
colnames(table.rnase3.SW) <- colnames(table.rnase3)
```

Normalize Fraction Intensities to Percentages (Sum to 100%)

```{r}
# Normalization of the fractions: Sum of all fraction values equals 100 (%)

normalize_table <- function(tbl) {
  tbl * 100 / rowSums(tbl)
}


tables.ctrl <- list(
  ctrl1 = table.ctrl1.SW,
  ctrl2 = table.ctrl2.SW,
  ctrl3 = table.ctrl3.SW)

tables.rnase <- list(
  rnase1 = table.rnase1.SW,
  rnase2 = table.rnase2.SW,
  rnase3 = table.rnase3.SW)

# Calculation of the percentages of the fractions in the normalized tables (table.ctrl1.SW)

norm_tables.ctrl <- lapply(tables.ctrl, normalize_table)
norm_tables.rnase <- lapply(tables.rnase, normalize_table)
```

Replace NA and NaN Values with 0

```{r}
# Function for replacing NA and NaN with 0

clean_table <- function(tbl) {
  tbl <- rapply(tbl, function(x) ifelse(is.na(x), 0, x), how = "replace")
  tbl <- rapply(tbl, function(x) ifelse(is.nan(x), 0, x), how = "replace")
  return(tbl)
}

# Getting the clean table

tables.norm.ctrl <- lapply(norm_tables.ctrl, clean_table)
tables.norm.rnase <- lapply(norm_tables.rnase, clean_table)
```

Calculate Mean Across Replicates

```{r}
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)

# Addition of all data-frames in the list my.list.ctrl.norm (element-wise) and Division of the Sum with 3 to get the mean of all 3 replicates

ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
```

```{r}
# Change names of the columns: from "fraction1" to "fraction25"

col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
```

```{r}
# second normalization of the fractions (mean destroyed first normalization): Sum of all fraction values equals 100 (%)

ctrl_norm_mean <- ctrl_norm_mean*100/rowSums(ctrl_norm_mean)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)

```

Filter Proteins with Zero Values Across All Fractions

```{r}
# Function for replacing NA and NaN with 0

replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")

ctrl_norm_mean <- replace_na_nan(ctrl_norm_mean)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
```

```{r}
# If a curve is 0 in all fractions, the other fraction is also set to 0 and is excluded from the analysis

ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
```

Plot Example Protein Fractionation Profiles

```{r}
row_data1 <- as.numeric(ctrl_norm_mean["NUCL_HUMAN", 1:25])
row_data2 <- as.numeric(rnase_norm_mean["NUCL_HUMAN", 1:25])


# Plot
plot(row_data1,
     type = "l",        
     main = "Plot for NUCL_HUMAN",
     xlab = "Fractions",
     ylab = "Values",
     col = "blue",
     lwd = 2)
     
lines(row_data2,
      type = "l",
      col = "red",
      lwd = 2)

```





**************************************************************************************************************
4. Find local maxima
**************************************************************************************************************

- Local maxima are peaks, that are higher than the two surrounding values 
- In order to get rid of the noise, only values above 2 are considered.
- Find shoulders that were not discovered previously.

```{r}
# In case the original data is advantageous for later analysis
ctrl_norm_mean_original = ctrl_norm_mean
rnase_norm_mean_original = rnase_norm_mean
```

Define Peak Finding Function

```{r}
# Function find_local_maxima
# Peak is local maximum with a certain amount (=window) of smaller points on each side
# Bigger window => more stringent peak finding procedure 

find_local_maxima <- function(x, window = 2) {
  n <- length(x)
  peaks <- c()

  for (i in 1:n) {
    left <- max(1, i - window)
    right <- min(n, i + window)
    neighbors <- x[left:right][-which((left:right) == i)]

    if (all(neighbors <= x[i])) {
      peaks <- c(peaks, i)
    }
  }

  return(peaks)
}
```

```{r}
# Apply the function to the data set 
# Restriction to values above an absolute threshold of 2%
# New column: "local_maxima" (column 26)

ctrl_norm_mean$local_maxima <- apply(ctrl_norm_mean, 1, function(x) {
															   peak_indices <- find_local_maxima(x)
															   filtered <- peak_indices[x[peak_indices] > 2] 
															   local_maxima <- unlist(filtered)
															   local_maxima
															   })
															   
rnase_norm_mean$local_maxima <- apply(rnase_norm_mean, 1, function(x) {
															   peak_indices <- find_local_maxima(x)
															   filtered <- peak_indices[x[peak_indices] > 2] 
															   local_maxima <- unlist(filtered)
															   local_maxima
															   })
```

```{r}
# Out of the local maxima, extract the global (greatest) maximum, and save it in a new column "global_maximum" (column 27)

ctrl_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
  x <- as.numeric(ctrl_norm_mean[i, 1:25])
  peaks <- ctrl_norm_mean$local_maxima[[i]]

  if (length(peaks) == 0) {
    return(NA)
  } else {
    peak_values <- x[peaks]
    return(peaks[which.max(peak_values)])
  }
})


rnase_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
  x <- as.numeric(rnase_norm_mean[i, 1:25])
  peaks <- rnase_norm_mean$local_maxima[[i]]

  if (length(peaks) == 0) {
    return(NA)
  } else {
    peak_values <- x[peaks]
    return(peaks[which.max(peak_values)])
  }
})
```


****************************************************************************************************************
5. Identify shoulders
****************************************************************************************************************

- Shoulders are regions that are not recognized as peaks, even though they have a high signal intensity.
- Create Binary Data Frames Indicating Signal > 2%

```{r}
# Identify the RNAse fractions with signal intensity > 2%. 
# Create a new data frame containing 0 (= this fraction value was ≤2% ) and 1 (= this fraction value was >2%.), as well as the intensity maxima.
# The two new data frames are created, rnase_3 and ctrl_3, as copies of the previously calculated, normalized mean tables (*_norm_mean).

rnase_3 <- rnase_norm_mean
# Compare each value in columns 1 to 25 (the fractions) of the rnase_norm_mean dataframe with the threshold of 2%.
# Convert TRUE to 1 and FALSE to 0. 
rnase_3[1:25] <- (rnase_norm_mean[1:25] > 2)*1

# Identify the CTRL fractions with signal intensity > 2%. 
# Create a new data frames containing 0 / 1, as well as the intensity maxima.
ctrl_3 <- ctrl_norm_mean
ctrl_3[1:25] <- (ctrl_norm_mean[1:25] > 2)*1
```

Mask Regions Around Detected Peaks to Exclude Them from Shoulder Search

```{r}
# Remove and exclude 3 fractions left and right of each peak (7 in total) from the shoulder search.

th_max_reg_simple <- function(x) {
  peaks <- as.numeric(unlist(x$local_maxima)) 
  mask <- rep(1, 25)
  
  for (peak in peaks) { # peak = current peak value, peaks = detected maxima (column 26)
    if (peak > 0) { 
      left <- max(1, peak - 3)
      right <- min(25, peak + 3) 
      mask[left:right] <- 0 # For each peak, the range from peak–3 to peak+3 is calculated and set to 0 in the mask
      
    }
  }

  x_values <- as.numeric(x[1:25])  
  x_values <- x_values * mask # Fractions with mask = 1 are retained. Fractions with mask = 0 are set to 0.
  return(x_values)
}

# Apply the function row by row to the entire rnase_3 or ctrl_3 DataFrame.
rnase_3[1:25] <- t(apply(rnase_3, 1, th_max_reg_simple))
ctrl_3[1:25]  <- t(apply(ctrl_3, 1, th_max_reg_simple))
```

Identify Shoulder Regions: Consecutive Fractions > 2% Without Peaks

```{r}
# Detect "shoulder regions"
# Define a function that identifies signal regions where there are at least 4 consecutive fractions with an intensity above 2% using the data frames rnase_3 and ctrl_3.
# select the middle of this region as shoulder

peaks_regions = function(x) {
  rle_result = rle(as.numeric(x[1:25])) # rle() finds all consecutive equal values -> $lengths and $values
  
  #Find positions of all blocks consisting of 1s with length ≥4. These blocks are considered “shoulder regions”.
  peak_blocks = which(rle_result$values == 1 & rle_result$lengths >= 4)
  
  #If there are no such blocks of length >4, return an empty vector
  if (length(peak_blocks) == 0) {
    return(numeric(0))
  }
  
  #Calculate estimate middle for the peak blocks
  peak_positions = numeric(length(peak_blocks))
  
  for(i in seq_along(peak_blocks)) {
    
    #Position of the end of the respective block 
    end_of_block = sum(rle_result$lengths[1:peak_blocks[i]])
    
    #Calculate half length of the block
    half_length = floor(rle_result$lengths[peak_blocks[i]] /2)
    
    #Middle position of the shoulder 
    peak_positions[i] = end_of_block - half_length
  }
  
  return(peak_positions)
}
```

```{r}
# Calculate the positions of the "shoulders" for each row for the data.frames ctrl/rnase_3 and ctrl/rnase_norm_mean
# New column: "shoulders" (column 28)

rnase_3$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_3$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )


rnase_norm_mean$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_norm_mean$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )
```

Combine Peak and Shoulder Positions for Each Protein

```{r}
# Calculate the total of all relevant signal maxima (real peaks and shoulders) for each protein row in the data.frames
# New column: "combined_max_ctrl" and "combined_max_rnase" (column 29) respectively

						   						
rnase_3$combined_max_rnase <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima)) # ls_max = numerical vector with the peak positions of this protein
												 ls_shoulder <- as.numeric(unlist(x$shoulders))
												 
												 combined_max_rnase <- c(ls_max, ls_shoulder) # Combine to common vector.
												 combined_max_rnase <- unlist(combined_max_rnase)
												 combined_max_rnase <- combined_max_rnase[combined_max_rnase!=0] # Remove all 0 entries from the result vector, as these do not represent real signals.
												 combined_max_rnase <- sort(combined_max_rnase, decreasing = FALSE) # Sort all peak and shoulder positions in ascending order (1 → 25)
												 if (length(combined_max_rnase) == 0) {0} else {combined_max_rnase} # If there are no peaks or shoulders, 0 (as a placeholder) is stored.
												 })

ctrl_3$combined_max_ctrl <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 ls_shoulder <- as.numeric(unlist(x$shoulders))
												 
												 combined_max_ctrl <- c(ls_max, ls_shoulder)
												 combined_max_ctrl <- unlist(combined_max_ctrl)
												 combined_max_ctrl <- combined_max_ctrl[combined_max_ctrl!=0]
												 combined_max_ctrl <- sort(combined_max_ctrl, decreasing = FALSE)
												 if (length(combined_max_ctrl) == 0) {0} else {combined_max_ctrl} 
												 })


# Add new column of the combined maxima to ctrl/rnase_nrom_mean, to continue working with it

ctrl_norm_mean$combined_max_ctrl = ctrl_3[, "combined_max_ctrl"]
rnase_norm_mean$combined_max_rnase = rnase_3[, "combined_max_rnase"]
```

***********************************************************************************************************
6. Count Total Number of Maxima (Peaks + Shoulders) per Protein
***********************************************************************************************************

```{r}
# Determine the number of combined maxima (peaks + shoulders) per protein
# New column: "n_max_comb" (column 30)

rnase_3$n_max_comb <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$combined_max_rnase))
												 n = length(ls_max) # determines how many peaks (maxima and shoulders) the protein has
												 if (sum(ls_max) == 0) {0} else {n}  
												 })
												 
ctrl_3$n_max_comb <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$combined_max_ctrl))
												 n = length(ls_max)
												 if (sum(ls_max) == 0) {0} else {n} 
												 })


# Same for ctrl/rnase_norm_mean

ctrl_norm_mean$n_max_comb = ctrl_3[, "n_max_comb"]
rnase_norm_mean$n_max_comb = rnase_3[, "n_max_comb"] 
```


***********************************************************************************************************
7. Identification of proteins with a different number of peaks in CTRL vs. RNASE
***********************************************************************************************************

```{r}
# Determine the number of only peak maxima ("local_maxima") per protein
# New column: "n_local_maxima" (column 31)

rnase_3$n_local_maxima <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 n = length(ls_max) 
												 if (sum(ls_max) == 0) {0} else {n}  
												 })
												 
ctrl_3$n_local_maxima <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 n = length(ls_max)
												 if (sum(ls_max) == 0) {0} else {n} 
												 })

# Same for ctrl/rnase_norm_mean

ctrl_norm_mean$n_local_maxima = ctrl_3[, "n_local_maxima"]
rnase_norm_mean$n_local_maxima = rnase_3[, "n_local_maxima"]  
```


***********************************************************************************************************
8. Add COM (center of mass) values 
***********************************************************************************************************

```{r}
# Calculate the center of mass for each row 
# x is the vector with the intensities of a protein across all 25 fractions for which the COM is currently being calculated
# * means element-wise multiplication

ctrl_norm_mean$COM <- apply(ctrl_norm_mean[, 1:25], 1, function(x) {
  sum((1:25) * x, na.rm = TRUE) / sum(x, na.rm = TRUE)
})

rnase_norm_mean$COM <- apply(rnase_norm_mean[, 1:25], 1, function(x) {
  sum((1:25) * x, na.rm = TRUE) / sum(x, na.rm = TRUE)
})
```







***********************************************************************************************************
1. Criterion for data set purification:
The main peak of the respective protein is shifted by at least two peaks in its position
***********************************************************************************************************


Create new data.frames, in which the main peak (=global maximum) of the proteins is shifted, names: ctrl_main_shift, rnase_main_shift
```{r}
# Calculate the absolute difference of the position of the global maximum between ctrl and rnase 
diff_main_maxima <- abs(ctrl_norm_mean$global_maximum - rnase_norm_mean$global_maximum)

# Indices of proteins with deviation ≥ 3 fractions
deviating_main_maxima <- which(diff_main_maxima >= 3)

# Apply on the data.frames
ctrl_main_shift = ctrl_norm_mean[deviating_main_maxima, ]
rnase_main_shift = rnase_norm_mean[deviating_main_maxima, ]

# ctrl/rnase_main_shift contain 1075 proteins 
```


Create the complementary data.frame that contains all proteins whose main maximum does not shift by at least 2 fractions
```{r}
ctrl_no_main_shift = ctrl_norm_mean[!rownames(ctrl_norm_mean) %in% rownames(ctrl_main_shift), ]
rnase_no_main_shift = rnase_norm_mean[!rownames(rnase_norm_mean) %in% rownames(rnase_main_shift), ]
```



***********************************************************************************************************
Hypothesis: Correlation of ctrl_main_shift with rnase_main_shift is lower than that of ctrl_no_main_shift with rnase_no_main_shift
***********************************************************************************************************

```{r}
# Function to calculate the row-wise correlation, assumption: cor of ctrl_main_shift is lower than of ctrl_no_main_shift

correlations <- function(df1, df2, methode = "pearson") {
  
  # Check whether both data frames have the same dimensions
  if (!all(dim(df1) == dim(df2))) {
    stop("Die beiden Dataframes müssen die gleiche Dimension haben")
  }

  # Number of rows
  n <- nrow(df1)

  # Vector for storing the correlation values
  correlations <- numeric(n)

  # Loop over all rows
  for (i in 1:n) {
    v1 <- as.numeric(df1[i, 1:25])
    v2 <- as.numeric(df2[i, 1:25])

    # Calculate correlation only if both vectors have variance
    if (sd(v1, na.rm = TRUE) != 0 && sd(v2, na.rm = TRUE) != 0) {
      correlations[i] <- cor(v1, v2, method = methode, use = "complete.obs")
    } else {
      correlations[i] <- NA
    }
  }

  abs_correlations = abs(correlations)
  
  mean_abs_correlation = mean(abs_correlations, na.rm = TRUE)
  
  return(list(
    correlations = correlations, mean_abs_correlation = mean_abs_correlation
  ))
}
```



***********************************************************************************************************
Evaluation of the hypothesis
***********************************************************************************************************

```{r}
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is shifted by at least 2 fractions
testing_cor_shifter = correlations(ctrl_main_shift, rnase_main_shift)
testing_cor_shifter$mean_abs_correlation

# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is not shifted by at least 2 fractions
testing_cor_no_shifter = correlations(ctrl_no_main_shift, rnase_no_main_shift)
testing_cor_no_shifter$mean_abs_correlation

# If the hypothesis is correct, is the mean of the correlations of the shifters smaller than that of the no_shifters?
# testing_cor_shifter$mean_abs_correlation < testing_cor_no_shifter$mean_abs_correlation
```

Our hypothesis was confirmed. The mean correlation between ctrl and rnase is smaller for proteins whose main peak was shifted by at least two fractions. Here, it is 0.34. For proteins without a large shift of the main peak, it is 0.92.


```{r}
cor_all_proteins = correlations(ctrl_norm_mean, rnase_norm_mean)
cor_all_proteins$mean_abs_correlation
```

The mean correlation for all proteins is 0.79. This is less than 0.92 and greater than 0.34.
This initially suggests that purification of RNA-dependent proteins based on the criterion of a significant shift in the main peak appears to be reasonable. Our goal was to select less similar curves and separate them from similar ones.


Plotting the correlations as a histogram
```{r}
par(mfrow = c(1, 2)) 

hist(
  testing_cor_shifter$correlations,
  main = "Correlation values main shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "skyblue",
  border = "white",
  xlim = c(-1, 1) 
)

hist(
  testing_cor_no_shifter$correlations,
  main = "Correlation values no main shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "salmon",
  border = "white",
  xlim = c(-1, 1)
)

par(mfrow = c(1, 1))
```

It is shown, that by just selecting proteins that exhibit a shift in their main/global maximum, the correlation values are distributed more in the direction of 0, which implies less similar curves between ctrl and rnase for the respective proteins. It should be noted, that the sole criterium of shifting global maximum is not enough, because there are still high correlation proteins existent, even though there is a global maximum shift. 
Additionally, most of the proteins, that do not show an global maximum shift have very high correlation values.

Visualization of the distribution of some proteins from ctrl/rnase_main_shift
```{r}
# Vector with indices of proteins, that show a near zero correlation between ctrl and rnase
near_zero_cors = which(abs(testing_cor_shifter$correlations) <= 0.01) 

indices = near_zero_cors[1:5]
                         
# Plotting some respective curves
for(i in indices) {
  cs <- as.numeric(ctrl_main_shift[i, 1:25])
  rs <- as.numeric(rnase_main_shift[i, 1:25])

# Plot
plot(cs,
     type = "l",        
     main = paste("Protein at index", i), 
     xlab = "Fractions",
     ylab = "Values",
     col = "blue",
     lwd = 2,
     ylim = range(c(cs, rs)))
  
lines(rs,
      type = "l",
      col = "red",
      lwd = 2)
}
```
These plotted proteins seem RNA-dependent, their curves look not very similar. 



Visualization of the distribution of some proteins from ctrl/rnase_no_main_shift
```{r}
# Vector with indices of proteins, that show a near one correlation between ctrl and rnase
near_one_cors = which(abs(testing_cor_no_shifter$correlations) >0.99) 

indices = near_one_cors[1:5]
                         
# Plotting some respective curves
for(i in indices) {
  cs <- as.numeric(ctrl_no_main_shift[i, 1:25])
  rs <- as.numeric(rnase_no_main_shift[i, 1:25])

# Plot
plot(cs,
     type = "l",        
     main = paste("Protein at index", i), 
     xlab = "Fractions",
     ylab = "Values",
     col = "blue",
     lwd = 2,
     ylim = range(c(cs, rs)))
  
lines(rs,
      type = "l",
      col = "red",
      lwd = 2)
}
```
The curves seem very similar/almost identical. Therefore, the plotted proteins do not seem RNA-dependent.


This is as expected so far. Now the question rises, how the plots would look for those proteins, that exhibit a global maximum shift, but still show a high correlation value. Are they really candidates for RNA-dependent proteins?



Visualization of the distribution of those proteins from ctrl/rnase_main_shift, that still show a high correlation value
```{r}
# Vector with indices of proteins, that show a near one correlation between ctrl and rnase
near_one_cors_question = which(abs(testing_cor_shifter$correlations) >0.95) 

indices = near_one_cors_question[1:5]
                         
# Plotting a respective curves
for(i in indices) {
  cs <- as.numeric(ctrl_main_shift[i, 1:25])
  rs <- as.numeric(rnase_main_shift[i, 1:25])

# Plot
plot(cs,
     type = "l",        
     main = paste("Protein at index", i), 
     xlab = "Fractions",
     ylab = "Values",
     col = "blue",
     lwd = 2,
     ylim = range(c(cs, rs)))
  
lines(rs,
      type = "l",
      col = "red",
      lwd = 2)
}
```

The curves seem very similar. On paper, there is a shift in the global maximum, still the general appearance is very similar. Therefore, these proteins do not seem RNA-dependent.


We need an additional purification criterion for those proteins. Here, we use the center of mass. When a protein shifts in its global maximum, but retains a very similar curve like for the examples above, then the overall center of mass is not changed. Plot 5 (Index 818 for ctrl/rnase_main_shift) is a great example. It shows two very similar peak areas at the same locations. However, ctrl shows its global maximum at one of them, rnase shows its global maximum at the other one. Despite this on-paper shift, its center of mass is not changed, which makes the center of mass a suitable criterion to filter for those proteins.  




Create new data.frames out of ctrl/rnase_main_shift to select those proteins, that exhibit a shift in the global maximum AND a shift regarding their overall center of mass
```{r}
# Calculate the absolute difference of the positions of the COM values between ctrl and rnase 
diff_COM <- abs(ctrl_main_shift$COM - rnase_main_shift$COM)

# Indices of proteins with deviation ≥ 3 fractions
deviating_COM <- which(diff_COM >= 3)

# Apply on the data.frames
ctrl_COM_shift = ctrl_main_shift[deviating_COM, ]
rnase_COM_shift = rnase_main_shift[deviating_COM, ]

# ctrl/rnase_COM_shift contain 650 proteins 
```


Create the complementary data.frame that contains all proteins whose COM do not shift by at least 2 fractions
```{r}
ctrl_no_COM_shift = ctrl_main_shift[!rownames(ctrl_main_shift) %in% rownames(ctrl_COM_shift), ]
rnase_no_COM_shift = rnase_main_shift[!rownames(rnase_main_shift) %in% rownames(rnase_COM_shift), ]
```


Get the new variables for the correlation values 
```{r}
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is shifted by at least 2 fractions
COM_shifter = correlations(ctrl_COM_shift, rnase_COM_shift)
COM_shifter$mean_abs_correlation

# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is not shifted by at least 2 fractions
COM_no_shifter = correlations(ctrl_no_COM_shift, rnase_no_COM_shift)
COM_no_shifter$mean_abs_correlation
```




Plotting the correlations as a histogram
```{r}
par(mfrow = c(1, 2)) 

hist(
  COM_shifter$correlations,
  main = "Correlation values COM shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "skyblue",
  border = "white",
  xlim = c(-1, 1) 
)

# Zweiter Plot: testing_cor_no_shifter
hist(
  COM_no_shifter$correlations,
  main = "Correlation values no COM shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "salmon",
  border = "white",
  xlim = c(-1, 1)
)

par(mfrow = c(1, 1))
```
Both histograms contain a part of the proteins, that exhibited a shift in their global maximum. 
The proteins that additionally showed a change in their center of mass (data.frames ctrl/rnase_COM_shift) tend to have a lower correlation value. The highest frequency is around the correlation value 0. This is expected, because a protein with global maximum shift and a change in its center of mass and hence distribution is expected to look less similar when comparing ctrl and rnase intensity distribution. 


It is interesting, that there seems to be a few proteins, that exhibited a global maximum shift, but no COM shift, and still got a corrleation value around 0. How do they look?

Visualization of the distribution of some proteins from ctrl/rnase_no_COM_shift
```{r}
# Vector with indices of proteins, that show a near zero correlation between ctrl and rnase
near_zero_cors = which(abs(COM_no_shifter$correlations) <= 0.1) 

indices = near_zero_cors[1:5]
                         
# Plotting respective curves
for(i in indices) {
  cs <- as.numeric(ctrl_no_COM_shift[i, 1:25])
  rs <- as.numeric(rnase_no_COM_shift[i, 1:25])

# Plot
plot(cs,
     type = "l",        
     main = paste("Protein at index", i), 
     xlab = "Fractions",
     ylab = "Values",
     col = "blue",
     lwd = 2,
     ylim = range(c(cs, rs)))
  
lines(rs,
      type = "l",
      col = "red",
      lwd = 2)
}
```
Interesting trend: In order to show global maximum shift, but no center of mass shift, the overall distribution needs to balance out. However, if there is a shift of the global maximum to the one side, and most of the intensity is located there, there needs to be another shift of the remaining intensity to the other side to balance out this effect of the shiftet global maximum. This seems to often occur for partially precipitated proteins, that show a left shift due to RNA-degradation and losing of its natural cellular complex. On the other hand they precipitate through new interactions, leading to unchanges center of mass and the overall correlation value of 0. These proteins are still considered RNA-dependent.






```{r}
# Vector with indices of proteins, that show a near one correlation between ctrl and rnase
cors = which(abs(COM_no_shifter$correlations) <= 0.1) 

indices = cors[1:5]
                         
# Plotting a respective curves
for(i in indices) {
  cs <- as.numeric(ctrl_no_COM_shift[i, 1:25])
  rs <- as.numeric(rnase_no_COM_shift[i, 1:25])

# Plot
plot(cs,
     type = "l",        
     main = paste("Protein at index", i), 
     xlab = "Fractions",
     ylab = "Values",
     col = "blue",
     lwd = 2,
     ylim = range(c(cs, rs)))
  
lines(rs,
      type = "l",
      col = "red",
      lwd = 2)
}
```



As a last purification criterium, we analyze the proteins previously mentioned. Starting point is the data.frame ctrl_no_COM_shift and rnase_no_COM_shift. They contain proteins, that exhibit a shift ind the global maximum, but no shift in the overall COM. We already visualized some of the proteins, and noticed, that there are two possibilities. 
1. Global maximum shift + no COM shift + high correlation --> similar shape --> we classify as not RNA-dependent 
2. Global maximum shift + no COM shift + low correlation --> different shape (e.g precipated proteins) --> RNA-dependent 







***********************************************************************************************************
8. Wilcoxon rank-sum test
***********************************************************************************************************

Statistische Beurteilung, ob die Aufreinigung des Datensatzes dazu geführt hat, dass die selektierten Proteine signifikante Unterschiede zwischen ctrl und rnase aufweisen (z.B. bei COM), während die nicht selektierten Proteine diese Unterschiede nicht aufweisen


1: ctrl_unequal_max und ctrl_main_shift, sowie rnase_unequal_max und rnase_main_shift werden kombiniert
--> ctrl_selected und rnase_selected entstehen

2: Test rownames(ctrl_selected) == rownames(rnase_selected), um sicherzugehen,dass die Proteine in der gleichen Reihenfolge sind, und auch sicher diegleichen Proteine vergleichen werden

3: ctrl_equal_max und rnase_equal_max umbennen zu ctrl_not_selected und rnase_not_selected

4.1: Aus der Spalte "combined_max_ctrl" von ctrl_selected wird pro Zeile der Mittelwert der Peak-Positionen  gebildet und dann verglichen mit dem Mittelwert der Peak-Positionen von "combined_max_rnase" von rnase_selected 

4.2: Aus der Spalte "combined_max_ctrl" von control_not_selected wird pro Zeile der Mittelwert der Peak-Positionen gebildet und dann verglichen mit dem Mittelwert der Peak-Positionen von "combined_max_rnase" von rnase_not_selected

4.3: Jetzt wird der Wilcoxon-Tets angewendet, um die Differenzen zu untersuchen 
--> H0: Die Verteilung der Differenzen in beiden Gruppen haben keinen systematischen Unterschied 

5. Alternative: Mittels COM (center of mass) anstatt Differenzen der Mittelwerte arbeiten


1.Step
```{r}
ctrl_selected = rbind(ctrl_main_shift, ctrl_unequal_max)
rnase_selected = rbind(rnase_main_shift, rnase_unequal_max)
```


2.Step
```{r}
sum(rownames(ctrl_selected) != rownames(rnase_selected))
```


3.Step
```{r}
ctrl_not_selected = ctrl_equal_max
rnase_not_selected = rnase_equal_max

dim(ctrl_not_selected)[1] + dim(ctrl_selected)[1] == 4765
```


4.Step
```{r}
# Calculate mean values per row and form the difference
get_differences <- function(ctrl_df, rnase_df, ctrl_col, rnase_col) {
  ctrl_means <- sapply(ctrl_df[[ctrl_col]], mean)
  rnase_means <- sapply(rnase_df[[rnase_col]], mean)
  return(ctrl_means - rnase_means)
}

# Calculate the difference vectors for both groups
diff_selected <- get_differences(ctrl_selected, rnase_selected, "combined_max_ctrl", "combined_max_rnase")
diff_not_selected <- get_differences(ctrl_not_selected, rnase_not_selected, "combined_max_ctrl", "combined_max_rnase")

# Wilcoxon Rank-Sum Test (unpaired)
wilcox_test_result <- wilcox.test(diff_selected, diff_not_selected)

# Show result
print(wilcox_test_result)
```

Plots

```{r}
library(ggplot2)

# Vector with group membership
group <- c(rep("selected", length(diff_selected)), rep("not_selected", length(diff_not_selected)))
diffs <- c(diff_selected, diff_not_selected)

df_plot <- data.frame(Group = group, Difference = diffs)

ggplot(df_plot, aes(x = Group, y = Difference)) +
  geom_violin(trim = FALSE, fill = "lightblue") +
  geom_boxplot(width = 0.1, outlier.shape = NA) +
  theme_minimal() +
  labs(title = "Verteilung der Differenzen", y = "ctrl - rnase", x = "")
```

```{r}
ggplot(df_plot, aes(x = Difference, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Dichteverteilung der Differenzen", x = "Differenz (ctrl - rnase)")
```



5.Step

```{r}
# Comparison regarding COM
differences_COM <- function(ctrl_df, rnase_df) {
  ctrl_COM <- ctrl_df$COM
  rnase_COM <-rnase_df$COM
  return(ctrl_COM - rnase_COM)
}

# Calculate the difference vectors for both groups
diff_selected2 <- differences_COM(ctrl_selected, rnase_selected)
diff_not_selected2 <- differences_COM(ctrl_not_selected, rnase_not_selected)

# Wilcoxon Rank-Sum Test (unpaired)
wilcox_test_result2 <- wilcox.test(diff_selected2, diff_not_selected2)

# Show results
print(wilcox_test_result2)
```

***********************************************************************************************************
9. Principle Component Analysis (PCA)
  by Benjamin Nicklas influenced by ChatGPT
***********************************************************************************************************

```{r}
# Keep only numerical columns
pca_ctrl_numeric <- ctrl_selected[, sapply(ctrl_selected, is.numeric)][, 1:25]
pca_rnase_numeric <- rnase_selected[, sapply(rnase_selected, is.numeric)][, 1:25]

# Remove rows with NAs
pca_ctrl_clean <- pca_ctrl_numeric[complete.cases(pca_ctrl_numeric), ]
pca_rnase_clean <- pca_rnase_numeric[complete.cases(pca_rnase_numeric), ]

pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
```

```{r}
# Keep only numerical columns
pca_ctrl_numeric_not_selected <- ctrl_not_selected[,sapply(ctrl_not_selected, is.numeric)][, 1:25]
pca_rnase_numeric_not_selected <- rnase_not_selected[,sapply(rnase_not_selected, is.numeric)][, 1:25]

# Remove rows with NAs
pca_ctrl_clean_not_selected <- pca_ctrl_numeric_not_selected[complete.cases(pca_ctrl_numeric_not_selected), ]
pca_rnase_clean_not_selected <- pca_rnase_numeric_not_selected[complete.cases(pca_rnase_numeric_not_selected), ]

pca_result_ctrl_not_selected <- prcomp(pca_ctrl_clean_not_selected, center = TRUE, scale. = TRUE, )
pca_result_rnase_not_selected <- prcomp(pca_rnase_clean_not_selected, center = TRUE, scale. = TRUE)
```

```{r}
# Check which PCs have the most variance
summary(pca_result_ctrl)
summary(pca_result_rnase)
```

```{r}
#plot PC1 with PC2
plot(pca_result_ctrl$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL (SHIFT)")

plot(pca_result_rnase$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE (SHIFT)")

#plot PC1 with PC3
plot(pca_result_ctrl$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL (SHIFT)")

plot(pca_result_rnase$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE (SHIFT)")


#plot PC2 with PC3
plot(pca_result_ctrl$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL (SHIFT)")

plot(pca_result_rnase$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE (SHIFT)")



# Simple 2D PCA-Plot
plot(pca_result_ctrl_not_selected$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE (NO SHIFT)")

#plot PC1 with PC3
plot(pca_result_ctrl_not_selected$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE (NO SHIFT)")


#plot PC2 with PC3
plot(pca_result_ctrl_not_selected$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE (NO SHIFT)")
```
```{r}
#Recognize centers for k-means clustering -> 3 centers
plot(pca_result_ctrl, type = "l", main = "Elbow-Plot CTRL (SHIFT)")
plot(pca_result_rnase, type = "l", main = "Elbow-Plot RNASE (SHIFT)")

#Recognize centers for k-means clustering -> 2 centers
plot(pca_result_ctrl_not_selected, type = "l", main = "Elbow-Plot CTRL (NO SHIFT)")
plot(pca_result_rnase_not_selected, type = "l", main = "Elbow-Plot RNASE (NO SHIFT)")
```
```{r}
pca_ctrl_pc1_pc2 <- as.data.frame(pca_result_ctrl$x[, 1:2])
pca_ctrl_pc1_pc3 <- as.data.frame(pca_result_ctrl$x[, c(1,3)])
pca_ctrl_pc2_pc3 <- as.data.frame(pca_result_ctrl$x[, 2:3])

pca_rnase_pc1_pc2 <- as.data.frame(pca_result_rnase$x[, 1:2])
pca_rnase_pc1_pc3 <- as.data.frame(pca_result_rnase$x[, c(1,3)])
pca_rnase_pc2_pc3 <- as.data.frame(pca_result_rnase$x[, 2:3])
```

```{r}
pca_ctrl_pc1_pc2_not_selected <- as.data.frame(pca_result_ctrl_not_selected$x[, 1:2])
pca_ctrl_pc1_pc3_not_selected <- as.data.frame(pca_result_ctrl_not_selected$x[, c(1,3)])
pca_ctrl_pc2_pc3_not_selected <- as.data.frame(pca_result_ctrl_not_selected$x[, 2:3])

pca_rnase_pc1_pc2_not_selected <- as.data.frame(pca_result_rnase_not_selected$x[, 1:2])
pca_rnase_pc1_pc3_not_selected <- as.data.frame(pca_result_rnase_not_selected$x[, c(1,3)])
pca_rnase_pc2_pc3_not_selected <- as.data.frame(pca_result_rnase_not_selected$x[, 2:3])
```

```{r}
library(factoextra)

fviz_nbclust(pca_ctrl_pc1_pc2, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc1_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc2_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC2/PC3") +
  theme_minimal()

fviz_nbclust(pca_rnase_pc1_pc2, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC3") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc2_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC2/PC3") +
  theme_minimal()



fviz_nbclust(pca_ctrl_pc1_pc2_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc1_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc2_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC2/PC3") +
  theme_minimal()

fviz_nbclust(pca_rnase_pc1_pc2_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC3") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc2_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC2/PC3") +
  theme_minimal()
```




***********************************************************************************************************
10. K-means clustering 
  by Benjamin Nicklas influenced by ChatGPT
***********************************************************************************************************

```{r}
#kmeans is executed with 3 centers --> see elbow-Plot and silhouette plot
km_result_ctrl_pc1_pc2<- kmeans(pca_ctrl_pc1_pc2, centers = 3)
km_result_ctrl_pc1_pc3<- kmeans(pca_ctrl_pc1_pc3, centers = 3)
km_result_ctrl_pc2_pc3<- kmeans(pca_ctrl_pc2_pc3, centers = 3)

km_result_rnase_pc1_pc2<- kmeans(pca_rnase_pc1_pc2, centers = 3)
km_result_rnase_pc1_pc3<- kmeans(pca_rnase_pc1_pc3, centers = 3)
km_result_rnase_pc2_pc3<- kmeans(pca_rnase_pc2_pc3, centers = 3)
```

```{r}
#kmeans is executed with 2 centers
km_result_ctrl_pc1_pc2_not_selected<- kmeans(pca_ctrl_pc1_pc2_not_selected, centers = 3)
km_result_ctrl_pc1_pc3_not_selected<- kmeans(pca_ctrl_pc1_pc3_not_selected, centers = 3)
km_result_ctrl_pc2_pc3_not_selected<- kmeans(pca_ctrl_pc2_pc3_not_selected, centers = 3)

km_result_rnase_pc1_pc2_not_selected<- kmeans(pca_rnase_pc1_pc2_not_selected, centers = 3)
km_result_rnase_pc1_pc3_not_selected<- kmeans(pca_rnase_pc1_pc3_not_selected, centers = 3)
km_result_rnase_pc2_pc3_not_selected<- kmeans(pca_rnase_pc2_pc3_not_selected, centers = 3)
```

```{r}
library(factoextra)

# pca_df contains the data, e.g. PC1 and PC2
fviz_cluster(km_result_ctrl_pc1_pc2, data = pca_ctrl_pc1_pc2,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 CTRL (SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc2, data = pca_rnase_pc1_pc2,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 RNASE (SHIFT)")

fviz_cluster(km_result_ctrl_pc1_pc3, data = pca_ctrl_pc1_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 CTRL (SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc3, data = pca_rnase_pc1_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 RNASE (SHIFT)")

fviz_cluster(km_result_ctrl_pc2_pc3, data = pca_ctrl_pc2_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 CTRL (SHIFT)")
fviz_cluster(km_result_rnase_pc2_pc3, data = pca_rnase_pc2_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 RNASE (SHIFT)")



# pca_df contains the data, e.g. PC1 and PC2
fviz_cluster(km_result_ctrl_pc1_pc2_not_selected, data = pca_ctrl_pc1_pc2_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL (NO SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc2_not_selected, data = pca_rnase_pc1_pc2_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 RNASE (NO SHIFT)")

fviz_cluster(km_result_ctrl_pc1_pc3_not_selected, data = pca_ctrl_pc1_pc3_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL (NO SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc3_not_selected, data = pca_rnase_pc1_pc3_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 RNASE (NO SHIFT)")

fviz_cluster(km_result_ctrl_pc2_pc3_not_selected, data = pca_ctrl_pc2_pc3_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL (NO SHIFT)")
fviz_cluster(km_result_rnase_pc2_pc3_not_selected, data = pca_rnase_pc2_pc3_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 RNASE (NO SHIFT)")
```

**************************************************************************************************************
11. Linear regression analysis
  by Julia Ferdin influenced by ChatGPT
**************************************************************************************************************

```{r}
#For ctrl and selected
#Generates plot with PCA datapoints and draws a trendline through it
plot(pca_ctrl_pc1_pc2$PC1,pca_ctrl_pc1_pc2$PC2,pch=20,col='blue', xlab='PC1',ylab='PC2');abline(0,1,col='red')
plot(pca_ctrl_pc1_pc3$PC1,pca_ctrl_pc1_pc3$PC3,pch=20,col='blue', xlab='PC1',ylab='PC3');abline(0,1,col='red')
plot(pca_ctrl_pc2_pc3$PC2,pca_ctrl_pc2_pc3$PC3,pch=20,col='blue', xlab='PC2',ylab='PC3');abline(0,1,col='red')

#Per PCA component a target variable is defined, so what should be predicted by the regression analysis
target_ctrl_pc1pc2 <- pca_ctrl_pc1_pc2$PC2
target_ctrl_pc1pc3 <- pca_ctrl_pc1_pc3$PC3
target_ctrl_pc2pc3 <- pca_ctrl_pc2_pc3$PC3

#Build combined data frame for regression analysis from target variable with two PCA components
df_regression_ctrl_1 <- cbind(target = target_ctrl_pc1pc2,
                       pca_ctrl_pc1_pc2)
df_regression_ctrl_2 <- cbind(target = target_ctrl_pc1pc3,
                       pca_ctrl_pc1_pc3)
df_regression_ctrl_3 <- cbind(target = target_ctrl_pc2pc3,
                       pca_ctrl_pc2_pc3)

#Multiple linear regression analysis
model_ctrl_pc1_pc2 <- lm(target ~ PC1 + PC2, data = df_regression_ctrl_1)
model_ctrl_pc1_pc3 <- lm(target ~ PC1 + PC3, data = df_regression_ctrl_2)
model_ctrl_pc2_pc3 <- lm(target ~ PC2 + PC3, data = df_regression_ctrl_3)

#Show results/summary
summary(model_ctrl_pc1_pc2)
summary(model_ctrl_pc1_pc3)
summary(model_ctrl_pc2_pc3)
```
**************************************************************************************************************
Explanation of regression analysis results:

[Perfect fit - perfect multicollinearity with same variable used as predictor and target]
  Residuals: Almost zero, model's prediction matches taget values almost perfectly
  Intercept: Essentially zero
  PC1: Essentially zero
  PC2: Exactly one
    --> PC2 is identical to target, PC1 and intercept contribute nothing
  R-squared: Model explains 100% of the variance in the target (too perfect, because target is PC2)

--> A target variable needs to be chosen that is none of the predictors. The PCS are used as predictors of that target, not vice versa.
**************************************************************************************************************
```{r}
#Same for rnase and selected
plot(pca_rnase_pc1_pc2$PC1,pca_rnase_pc1_pc2$PC2,pch=20,col='blue', xlab='PC1',ylab='PC2');abline(0,1,col='red')
plot(pca_rnase_pc1_pc3$PC1,pca_rnase_pc1_pc3$PC3,pch=20,col='blue', xlab='PC1',ylab='PC3');abline(0,1,col='red')
plot(pca_rnase_pc2_pc3$PC2,pca_rnase_pc2_pc3$PC3,pch=20,col='blue', xlab='PC2',ylab='PC3');abline(0,1,col='red')

target_rnase_pc1pc2 <- pca_rnase_pc1_pc2$PC2
target_rnase_pc1pc3 <- pca_rnase_pc1_pc3$PC3
target_rnase_pc2pc3 <- pca_rnase_pc2_pc3$PC3

df_regression_rnase_1 <- cbind(target = target_rnase_pc1pc2,
                       pca_rnase_pc1_pc2)
df_regression_rnase_2 <- cbind(target = target_rnase_pc1pc3,
                       pca_rnase_pc1_pc3)
df_regression_rnase_3 <- cbind(target = target_rnase_pc2pc3,
                       pca_rnase_pc2_pc3)

model_rnase_pc1_pc2 <- lm(target ~ PC1 + PC2, data = df_regression_rnase_1)
model_rnase_pc1_pc3 <- lm(target ~ PC1 + PC3, data = df_regression_rnase_2)
model_rnase_pc2_pc3 <- lm(target ~ PC2 + PC3, data = df_regression_rnase_3)

summary(model_rnase_pc1_pc2)
summary(model_rnase_pc1_pc3)
summary(model_rnase_pc2_pc3)
```
```{r}
#For ctrl and not selected
#Generates plot with PCA datapoints and draws a trendline through it
plot(pca_ctrl_pc1_pc2_not_selected$PC1,pca_ctrl_pc1_pc2_not_selected$PC2,pch=20,col='blue', xlab='PC1',ylab='PC2');abline(0,1,col='red')
plot(pca_ctrl_pc1_pc3_not_selected$PC1,pca_ctrl_pc1_pc3_not_selected$PC3,pch=20,col='blue', xlab='PC1',ylab='PC3');abline(0,1,col='red')
plot(pca_ctrl_pc2_pc3_not_selected$PC2,pca_ctrl_pc2_pc3_not_selected$PC3,pch=20,col='blue', xlab='PC2',ylab='PC3');abline(0,1,col='red')

#Per PCA component a target variable is defined, so what should be predicted by the regression analysis
target_ctrl_pc1pc2_not_selected <- pca_ctrl_pc1_pc2_not_selected$PC2
target_ctrl_pc1pc3_not_selected <- pca_ctrl_pc1_pc3_not_selected$PC3
target_ctrl_pc2pc3_not_selected <- pca_ctrl_pc2_pc3_not_selected$PC3

#Build combined data frame for regression analysis from target variable with two PCA components
df_regression_ctrl_1_not_selected <- cbind(target = target_ctrl_pc1pc2_not_selected,
                       pca_ctrl_pc1_pc2_not_selected)
df_regression_ctrl_2_not_selected <- cbind(target = target_ctrl_pc1pc3_not_selected,
                       pca_ctrl_pc1_pc3_not_selected)
df_regression_ctrl_3_not_selected <- cbind(target = target_ctrl_pc2pc3_not_selected,
                       pca_ctrl_pc2_pc3_not_selected)

#Multiple linear regression analysis
model_ctrl_pc1_pc2_not_selected <- lm(target ~ PC1 + PC2, data = df_regression_ctrl_1_not_selected)
model_ctrl_pc1_pc3_not_selected <- lm(target ~ PC1 + PC3, data = df_regression_ctrl_2_not_selected)
model_ctrl_pc2_pc3_not_selected <- lm(target ~ PC2 + PC3, data = df_regression_ctrl_3_not_selected)

#Show results/summary
summary(model_ctrl_pc1_pc2_not_selected)
summary(model_ctrl_pc1_pc3_not_selected)
summary(model_ctrl_pc2_pc3_not_selected)
```

```{r}
#Same for rnase and not selected
plot(pca_rnase_pc1_pc2_not_selected$PC1,pca_rnase_pc1_pc2_not_selected$PC2,pch=20,col='blue', xlab='PC1',ylab='PC2');abline(0,1,col='red')
plot(pca_rnase_pc1_pc3_not_selected$PC1,pca_rnase_pc1_pc3_not_selected$PC3,pch=20,col='blue', xlab='PC1',ylab='PC3');abline(0,1,col='red')
plot(pca_rnase_pc2_pc3_not_selected$PC2,pca_rnase_pc2_pc3_not_selected$PC3,pch=20,col='blue', xlab='PC2',ylab='PC3');abline(0,1,col='red')

target_rnase_pc1pc2_not_selected <- pca_rnase_pc1_pc2_not_selected$PC2
target_rnase_pc1pc3_not_selected <- pca_rnase_pc1_pc3_not_selected$PC3
target_rnase_pc2pc3_not_selected <- pca_rnase_pc2_pc3_not_selected$PC3

df_regression_rnase_1_not_selected <- cbind(target = target_rnase_pc1pc2_not_selected,
                       pca_rnase_pc1_pc2_not_selected)
df_regression_rnase_2_not_selected <- cbind(target = target_rnase_pc1pc3_not_selected,
                       pca_rnase_pc1_pc3_not_selected)
df_regression_rnase_3_not_selected <- cbind(target = target_rnase_pc2pc3_not_selected,
                       pca_rnase_pc2_pc3_not_selected)

model_rnase_pc1_pc2_not_selected <- lm(target ~ PC1 + PC2, data = df_regression_rnase_1_not_selected)
model_rnase_pc1_pc3_not_selected <- lm(target ~ PC1 + PC3, data = df_regression_rnase_2_not_selected)
model_rnase_pc2_pc3_not_selected <- lm(target ~ PC2 + PC3, data = df_regression_rnase_3_not_selected)

summary(model_rnase_pc1_pc2_not_selected)
summary(model_rnase_pc1_pc3_not_selected)
summary(model_rnase_pc2_pc3_not_selected)
```

**************************************************************************************************************
**************************************************************************************************************
Alternative for regression analysis, in which each principle component in ctrl gets compared to its equivalent in rnase instead of to the other principle components in its category.
But why do some not work and how can I change my target variable so there isn't a perfect fit?
```{r}
#For ctrl selected vs rnase selected
#Generates plot with PCA datapoints and draws a trendline through it
plot(pca_ctrl_pc1_pc2$PC1,pca_rnase_pc1_pc2$PC1,pch=20,col='blue', xlab='Ctrl PC1',ylab='Rnase PC1');abline(0,1,col='red')
plot(pca_ctrl_pc1_pc2$PC1,pca_rnase_pc1_pc2$PC2,pch=20,col='blue', xlab='Ctrl PC1',ylab='Rnase PC2');abline(0,1,col='red')
plot(pca_ctrl_pc1_pc2$PC1,pca_rnase_pc1_pc3$PC3,pch=20,col='blue', xlab='Ctrl PC1',ylab='Rnase PC3');abline(0,1,col='red')

plot(pca_ctrl_pc1_pc2$PC2,pca_rnase_pc1_pc2$PC1,pch=20,col='blue', xlab='Ctrl PC2',ylab='Rnase PC1');abline(0,1,col='red')
plot(pca_ctrl_pc1_pc2$PC2,pca_rnase_pc1_pc2$PC2,pch=20,col='blue', xlab='Ctrl PC2',ylab='Rnase PC2');abline(0,1,col='red')
plot(pca_ctrl_pc1_pc2$PC2,pca_rnase_pc1_pc3$PC3,pch=20,col='blue', xlab='Ctrl PC2',ylab='Rnase PC3');abline(0,1,col='red')

plot(pca_ctrl_pc1_pc3$PC3,pca_rnase_pc1_pc2$PC2,pch=20,col='blue', xlab='Ctrl PC3',ylab='Rnase PC1');abline(0,1,col='red')
plot(pca_ctrl_pc1_pc3$PC3,pca_rnase_pc1_pc2$PC2,pch=20,col='blue', xlab='Ctrl PC3',ylab='Rnase PC2');abline(0,1,col='red')
plot(pca_ctrl_pc1_pc3$PC3,pca_rnase_pc1_pc3$PC3,pch=20,col='blue', xlab='Ctrl PC3',ylab='Rnase PC3');abline(0,1,col='red')


#Per PCA component a target variable is defined, so what should be predicted by the regression analysis
target_selected_pc1_1 <- ctrl_selected$global_maximum
target_selected_pc1_2 <- pca_ctrl_pc1_pc2$PC1
target_selected_pc1_3 <- pca_ctrl_pc1_pc2$PC1

target_selected_pc2_1 <- pca_ctrl_pc1_pc2$PC2
target_selected_pc2_2 <- pca_ctrl_pc1_pc2$PC2
target_selected_pc2_3 <- pca_ctrl_pc1_pc2$PC2

target_selected_pc3_1 <- pca_ctrl_pc1_pc3$PC3
target_selected_pc3_2 <- pca_ctrl_pc1_pc3$PC3
target_selected_pc3_3 <- pca_ctrl_pc1_pc3$PC3

#Build combined data frame for regression analysis from target variable with two PCA components
df_regression_selected_11 <- cbind(target = target_selected_pc1_1 ,
                       ctrl_selected$global_maximum)
df_regression_selected_12 <- cbind(target =target_selected_pc1_2 ,
                       pca_ctrl_pc1_pc2)
df_regression_selected_13 <- cbind(target = target_selected_pc1_3 ,
                       pca_ctrl_pc1_pc2)

df_regression_selected_21 <- cbind(target = target_selected_pc2_1 ,
                       pca_ctrl_pc1_pc2)
df_regression_selected_22 <- cbind(target =target_selected_pc2_2 ,
                       pca_ctrl_pc1_pc2)
df_regression_selected_23 <- cbind(target = target_selected_pc2_3 ,
                       pca_ctrl_pc1_pc2)

df_regression_selected_31 <- cbind(target = target_selected_pc3_1 ,
                       pca_ctrl_pc1_pc3)
df_regression_selected_32 <- cbind(target =target_selected_pc3_2 ,
                       pca_ctrl_pc1_pc3)
df_regression_selected_33 <- cbind(target = target_selected_pc3_3 ,
                       pca_ctrl_pc1_pc3)


#Multiple linear regression analysis
model_selected_pc1_1<- lm(target ~ PC1 + PC1, data = df_regression_selected_11) #WIE ANDERS FORMULIEREN, at this point just redundant. Muss ich die Sachen nochmal umbenennen?
model_selected_pc1_2<- lm(target ~ PC1 + PC2, data = df_regression_selected_12)
#model_selected_pc1_3<- lm(target ~ PC1 + PC3, data = df_regression_selected_13)

model_selected_pc2_1<- lm(target ~ PC2 + PC1, data = df_regression_selected_21)
model_selected_pc2_2<- lm(target ~ PC2 + PC2, data = df_regression_selected_22) #WIE ANDERS FORMULIEREN
#model_selected_pc2_3<- lm(target ~ PC2 + PC3, data = df_regression_selected_23)

model_selected_pc3_1<- lm(target ~ PC3 + PC1, data = df_regression_selected_31)
#model_selected_pc3_2<- lm(target ~ PC3 + PC2, data = df_regression_selected_32)
#model_selected_pc3_3<- lm(target ~ PC3 + PC3, data = df_regression_selected_33) #WIE ANDERS PC3 + PC3 FORMULIEREN


#Show results/summary
summary(model_selected_pc1_1)
summary(model_selected_pc1_2)
#summary(model_selected_pc1_3)

summary(model_selected_pc2_1)
summary(model_selected_pc2_2)
#summary(model_selected_pc2_3)

summary(model_selected_pc3_1)
#summary(model_selected_pc3_2)
#summary(model_selected_pc3_3)
```


**************************************************************************************************************
**************************************************************************************************************
Question Ben:

```{r}
#plot PC1 with PC2
plot(pca_result_ctrl$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL (SHIFT)")
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl_pc1_pc2, data = pca_ctrl_pc1_pc2,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 CTRL (SHIFT)")

plot(pca_result_rnase$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE (SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc2, data = pca_rnase_pc1_pc2,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 RNASE (SHIFT)")

#plot PC1 with PC3
plot(pca_result_ctrl$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL (SHIFT)")
fviz_cluster(km_result_ctrl_pc1_pc3, data = pca_ctrl_pc1_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 CTRL (SHIFT)")

plot(pca_result_rnase$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE (SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc3, data = pca_rnase_pc1_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 RNASE (SHIFT)")

#plot PC2 with PC3
plot(pca_result_ctrl$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL (SHIFT)")
fviz_cluster(km_result_ctrl_pc2_pc3, data = pca_ctrl_pc2_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 CTRL (SHIFT)")

plot(pca_result_rnase$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE (SHIFT)")
fviz_cluster(km_result_rnase_pc2_pc3, data = pca_rnase_pc2_pc3,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 RNASE (SHIFT)")



# Einfaches 2D PCA-Plot
plot(pca_result_ctrl_not_selected$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL (NO SHIFT)")
# pca_df enthält deine Daten, z. B. PC1 und PC2
fviz_cluster(km_result_ctrl_pc1_pc2_not_selected, data = pca_ctrl_pc1_pc2_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,1:2], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE (NO SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc2_not_selected, data = pca_rnase_pc1_pc2_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 RNASE (NO SHIFT)")

#plot PC1 with PC3
plot(pca_result_ctrl_not_selected$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL (NO SHIFT)")
fviz_cluster(km_result_ctrl_pc1_pc3_not_selected, data = pca_ctrl_pc1_pc3_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,c(1, 3)], col = "blue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE (NO SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc3_not_selected, data = pca_rnase_pc1_pc3_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 RNASE (NO SHIFT)")


#plot PC2 with PC3
plot(pca_result_ctrl_not_selected$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL (NO SHIFT)")
fviz_cluster(km_result_ctrl_pc2_pc3_not_selected, data = pca_ctrl_pc2_pc3_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster der CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,2:3], col = "blue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE (NO SHIFT)")
fviz_cluster(km_result_rnase_pc2_pc3_not_selected, data = pca_rnase_pc2_pc3_not_selected,
             geom = "point", ellipse.type = "norm",
             palette = "jco", ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 RNASE (NO SHIFT)")
```
