**************************************************************************************************************

Proteome-wide screen for RNA-dependent proteins in non-synchronized HeLa cells
Molecular Biotechnology - Data science project summer term 2025
Julian Baureis, Julia Ferdin, Benjamin Nicklas, Luisa Wintel
Supervisors: Maïwen Caudron-Herger and Michela Pozzi 

**************************************************************************************************************

1. Load dataset
2. Data cleanup
3. Normalization
3. Identification of local maxima as fit parameters
4. Identification of shoulders
5. Total count of maxima (peaks and shoulders) per protein
6. Identification of proteins with different maxima amount in ctrl vs rnase
7. Criteria for selecting RNA-dependent proteins
8. Wilcoxon rank-sum test
9. Principle component analysis
10. k-means clustering
11. Linear regression analysis


**************************************************************************************************************
1. Load dataset and inspect row/column names 
  by Julia Ferdin
**************************************************************************************************************

```{r}
#Reads table by indicating path to directory where the dataset is stored, and stores it to variable NS_Table (NS for Non-synchronizied HeLa-cells)

NS_Table <- read.table("Daten/Data, copy but dont open.csv", header=TRUE, row.names=1, sep = ";")
```

```{r}
#The first 12 titles of the table (NS_Table) rows/colums are read out

#Row names are protein names
head(rownames(NS_Table),12)

#Columns indicate the respective fractions from 1 to 25, and their replicates
head(colnames(NS_Table),12)
```

**************************************************************************************************************
2. Data cleanup - Rearrange and reorder the columns to their treatment, replicate and fraction
  by Julia Ferdin
**************************************************************************************************************

Define sample by using vectors for different conditions (treatment, replicates, fractions):
  levels_CR → was sample treated with CTRL or RNASE
  levels_fraction → labels the column with the replicate number (1–3) for either CTRL or RNASE
  fraction_names → creates the variables fraction1 to fraction25 to assign the replicates to each fraction

```{r}
#A vector consists of 2 variables (CTRL, RNASE) --> c("CTRL", "RNASE")
#The factor() function encodes a vector as a factor. The 2 variables CTRL and RNASE are ordered into 2 different levels (characters)
#rep(vector,75) repeats the factor() function 75 times, because we have 150 columns (75 times CTRL and RNASE)
#The factor is defined as the variable 'treatment'

levels_CR <- factor(rep(c("CTRL", "RNASE"),75))
```

```{r}
#Every sample of every fraction gets its own level to disconnect them from each other -> 6 levels per fraction because we have 3 CTRLs and 3 RNASEs per fraction

levels_fraction <- factor(rep(c("Ctrl_Rep1","RNase_Rep1","Ctrl_Rep2","RNase_Rep2","Ctrl_Rep3","RNase_Rep3"),25))
```

```{r}
# Creation of a matrix with 6 rows and 25 columns. The matrix is filled by row from fraction1 to fraction25 so every column has one single fraction.
# sep="" compares the word fraction with the numbers 1 to 25 without a blank space.
# paste("fraction",1:25,sep="") creates a vector with the strings fraction1 to fraction25
# as.vector changes the created matrix into a vector with 150 elements sorted from 6 times fraction1 to 6 times fraction25

fraction_names <- as.vector(matrix(rep(paste("fraction",1:25,sep=""),6), nrow = 6, ncol=25, byrow = TRUE))
```

**************************************************************************************************************
Create Metadata Data Frame and Check for Missing Values

```{r}
# The number of rows are stored in a variable
n_row <- nrow(NS_Table)

# The row names (protein names) are stored in a variable
row_names <- rownames(NS_Table)
```

```{r}
# Creation of a data frame with levels_CR, levels_fraction and fraction_names. This assigns every replicate of the factions (levels_fraction) to their fraction (fraction_names) and their kind of treatment, CRTL or RNASE (levels_CR).

colmns_sorted <- data.frame(row.names = colnames(NS_Table), levels_CR = levels_CR, levels_fraction = levels_fraction, fraction_names = fraction_names)

#Check for missing values, there are none 
anyNA(NS_Table)
```

**************************************************************************************************************
3. Normalization step between the replicates in each fraction and for each treatment using the mean value method
  by Benjamin Nicklas influenced by ChatGPT
**************************************************************************************************************

Split data by fractions and treatment (CTRL vs RNASE)

```{r}
# lapply executes for every with paste created string (the fractions) a function fx
# colmns_sorted$fraction == fx: checks which columns are part of the fractions fx
# NS_Table[, ...] filters just these columns and assigns them to the list "fraction.tables"
# names(fraction.tables): the list "fraction.tables" gets names for its segments and assigns them to the variable selected_proteins 

fraction.tables <- lapply(paste("fraction", 1:25, sep = ""), function(fx) {NS_Table[, colmns_sorted$fraction_names == fx]})

names(fraction.tables) <- paste("fraction", 1:25, sep = "")

selected_proteins <- names(fraction.tables)
```

```{r}
# List with just CTRL/RNASE columns for each fraction
# subset filters just the fractions that fulfill the conditions: fraction_names == fx --> fraction name is part of the function fx, levels_CR == "CTRL" --> protein was treated as a CTRL
# rownames() takes the rownames of the filtered fractions and assigns them to the variable col
# NS_Table[, cols, drop = FALSE] the names that are part of NS_Table are filtered out and drop = FALSE makes sure that fraction.tables.CTRL will be a dataframe

# List with only CTRL columns for each fraction
fraction.tables.CTRL <- lapply(selected_proteins, function(fx) {
  cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "CTRL")) 
  NS_Table[, cols, drop = FALSE]
  })

# List with only CTRL rows for each fraction
fraction.tables.RNASE <- lapply(selected_proteins, function(fx) {
  cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "RNASE"))
  NS_Table[, cols, drop = FALSE]})

names(fraction.tables.CTRL) <- selected_proteins
names(fraction.tables.RNASE) <- selected_proteins
```

**************************************************************************************************************

Calculate Mean Protein Intensities per Fraction and Treatment

```{r}
# sapply(df, mean) calculates the mean of every column of the dataframe fraction.tables.CTRL
# For every condition (e.g. fraction 1, Ctrl, Rep 1) the mean over the proteins is taken which is a single value per condition

avg.tables.CTRL <- lapply(fraction.tables.CTRL, function(df) {
  sapply(df, mean)
})

avg.tables.RNASE <- lapply(fraction.tables.RNASE, function(df) {
  sapply(df, mean)
})
```

Calculate Normalization Factors Based on Most Similar Replicates

```{r}
# Determine normalization factor for each condition (i.e. sample), as the mean of the 2 most similar replicates.
# Create a function norm_fact for this step:

norm_fact <- function(x) {
				if( (abs(x[1]-x[2])<abs(x[1]-x[3])) && (abs(x[1]-x[2])<abs(x[2]-x[3])) ) 
					{mean(c(x[1],x[2]))} else if( (abs(x[1]-x[3])<abs(x[1]-x[2])) && (abs(x[1]-x[3])<abs(x[2]-x[3])) )
												  {mean(c(x[1],x[3]))} else {mean(c(x[2],x[3]))} 
}
```

Normalize Mean Intensities for Each Fraction and Treatment

```{r}
# Normalization of the mean vectors
# norm_factor <- norm_fact(vec): The function norm_fact is applied to every vector in the list avg.tables.CTRL (length 3)
# norm_factor / vec: Results in new vector of length 3 and represents a correcting factor for the single replicates in order to align the amount of protein of the replicates

norm_mean_frxn_CTRL <- lapply(avg.tables.CTRL, function(vec) {
  norm_factor <- norm_fact(vec)
  norm_factor / vec 
})

norm_mean_frxn_RNASE <- lapply(avg.tables.RNASE, function(vec) {
  norm_factor <- norm_fact(vec)
  norm_factor / vec 
})
```

Extract Normalization Factors for Each Replicate and Treatment

```{r}
# Correction factor for the overall protein quantity
# Normalization vectors for replicates 1-3
# function(x) x[1]: extracts the first element of each vector in the list
# norm.ctrl1 is a numeric vector consisting of the 1st element of each normalized CTRL vector

norm.ctrl1 <- sapply(norm_mean_frxn_CTRL, function(x) x[1])
norm.ctrl2 <- sapply(norm_mean_frxn_CTRL, function(x) x[2])
norm.ctrl3 <- sapply(norm_mean_frxn_CTRL, function(x) x[3])

norm.rnase1 <- sapply(norm_mean_frxn_RNASE, function(x) x[1])
norm.rnase2 <- sapply(norm_mean_frxn_RNASE, function(x) x[2])
norm.rnase3 <- sapply(norm_mean_frxn_RNASE, function(x) x[3])
```

```{r}
# Defines logical vectors (TRUE, FALSE), which are later used to create subtables - separately for treatment (Ctrl vs. RNase) and replica (Rep1, Rep2, Rep3)
# colmns_sorted$levels_fraction =="Ctrl_Rep1": checks at which position exactly in the columns_sorted Ctrl_Rep1 can be found (marks it with TRUE)

data.ctrl1 <- colmns_sorted$levels_fraction =="Ctrl_Rep1"
data.ctrl2 <- colmns_sorted$levels_fraction =="Ctrl_Rep2"
data.ctrl3 <- colmns_sorted$levels_fraction =="Ctrl_Rep3"
data.rnase1 <- colmns_sorted$levels_fraction =="RNase_Rep1"
data.rnase2 <- colmns_sorted$levels_fraction =="RNase_Rep2"
data.rnase3 <- colmns_sorted$levels_fraction =="RNase_Rep3"
```

Normalize Protein Intensity Data

```{r}
# Normalization step, fraction-wise
# takes specific columns from the protein intensity table and scales each row according to a normalization factor to compensate for measurement differences between replicates
# mask: A logical vector (TRUE/FALSE) that specifies which columns of NS_Table are selected
# selected <- NS_Table[, mask]: from NS_Table only the columns marked with TRUE in mask are selected
# (`*`, selected, norm_vec, SIMPLIFY = FALSE): Multiplication of colums of selected and the vector norm_vec saved as a list

normalize_group <- function(mask, norm_vec) {
  selected <- NS_Table[, mask]                  
  as.data.frame(mapply(`*`, selected, norm_vec, SIMPLIFY = FALSE))
}

# logical vectors (data.ctrl1) and vectors with normalization-factors (norm.ctrl1) form groups
# normalize_group(): multiplication of the vectors with their normalization-factor

table.ctrl1  <- normalize_group(data.ctrl1,  norm.ctrl1)
table.ctrl2  <- normalize_group(data.ctrl2,  norm.ctrl2)
table.ctrl3  <- normalize_group(data.ctrl3,  norm.ctrl3)
table.rnase1 <- normalize_group(data.rnase1, norm.rnase1)
table.rnase2 <- normalize_group(data.rnase2, norm.rnase2)
table.rnase3 <- normalize_group(data.rnase3, norm.rnase3)
```

```{r}
# Get the proper rownames for the tables

rownames(table.ctrl1) <- row_names
rownames(table.ctrl2) <- row_names
rownames(table.ctrl3) <- row_names
rownames(table.rnase1) <- row_names
rownames(table.rnase2) <- row_names
rownames(table.rnase3) <- row_names
```

Smooth Data with Sliding Window (Moving Average of 3 Fractions)

```{r}
# Apply a sliding window/moving average of 3 points to the data to reduce noise in the data and obtain smoother curves (not possible for fraction 1 and 25)

smooth_table <- function(tbl) {
  data.frame(tbl[1], (tbl[1:23] + tbl[2:24] + tbl[3:25]) / 3, tbl[25])
}

table.ctrl1.SW <- smooth_table(table.ctrl1)
table.ctrl2.SW <- smooth_table(table.ctrl2)
table.ctrl3.SW <- smooth_table(table.ctrl3)
table.rnase1.SW <- smooth_table(table.rnase1)
table.rnase2.SW <- smooth_table(table.rnase2)
table.rnase3.SW <- smooth_table(table.rnase3)
```

```{r}
# Get the proper rownames for the tables

colnames(table.ctrl1.SW) <- colnames(table.ctrl1)
colnames(table.ctrl2.SW) <- colnames(table.ctrl2)
colnames(table.ctrl3.SW) <- colnames(table.ctrl3)
colnames(table.rnase1.SW) <- colnames(table.rnase1)
colnames(table.rnase2.SW) <- colnames(table.rnase2)
colnames(table.rnase3.SW) <- colnames(table.rnase3)
```

Normalize Fraction Intensities to Percentages (Sum to 100%)

```{r}
# Normalization of the fractions: Sum of all fraction values equals 100 (%)

normalize_table <- function(tbl) {
  tbl * 100 / rowSums(tbl)
}


tables.ctrl <- list(
  ctrl1 = table.ctrl1.SW,
  ctrl2 = table.ctrl2.SW,
  ctrl3 = table.ctrl3.SW)

tables.rnase <- list(
  rnase1 = table.rnase1.SW,
  rnase2 = table.rnase2.SW,
  rnase3 = table.rnase3.SW)

# Calculation of the percentages of the fractions in the normalized tables (table.ctrl1.SW)

norm_tables.ctrl <- lapply(tables.ctrl, normalize_table)
norm_tables.rnase <- lapply(tables.rnase, normalize_table)
```

Replace NA and NaN Values with 0

```{r}
# Function for replacing NA and NaN with 0

clean_table <- function(tbl) {
  tbl <- rapply(tbl, function(x) ifelse(is.na(x), 0, x), how = "replace")
  tbl <- rapply(tbl, function(x) ifelse(is.nan(x), 0, x), how = "replace")
  return(tbl)
}

# Getting the clean table

tables.norm.ctrl <- lapply(norm_tables.ctrl, clean_table)
tables.norm.rnase <- lapply(norm_tables.rnase, clean_table)
```

Calculate Mean Across Replicates

```{r}
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)

# Addition of all data-frames in the list my.list.ctrl.norm (element-wise) and Division of the Sum with 3 to get the mean of all 3 replicates

ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
```

```{r}
# Change names of the columns: from "fraction1" to "fraction25"

col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
```

```{r}
# second normalization of the fractions (mean destroyed first normalization): Sum of all fraction values equals 100 (%)

ctrl_norm_mean <- ctrl_norm_mean*100/rowSums(ctrl_norm_mean)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)

```

Filter Proteins with Zero Values Across All Fractions

```{r}
# Function for replacing NA and NaN with 0

replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")

ctrl_norm_mean <- replace_na_nan(ctrl_norm_mean)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
```

```{r}
# If a curve is 0 in all fractions, the other fraction is also set to 0 and is excluded from the analysis

ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
```

Plot Example Protein Fractionation Profiles

```{r}
row_data1 <- as.numeric(ctrl_norm_mean["NUCL_HUMAN", 1:25])
row_data2 <- as.numeric(rnase_norm_mean["NUCL_HUMAN", 1:25])

# Plot
plot(row_data1,
     type = "l",        
     main = "Plot for NUCL_HUMAN",
     xlab = "Fractions",
     ylab = "Values",
     col = "midnightblue",
     lwd = 2)
     
lines(row_data2,
      type = "l",
      col = "firebrick3",
      lwd = 2)

```





**************************************************************************************************************
4. Find local maxima
**************************************************************************************************************

- Local maxima are peaks, that are higher than the two surrounding values 
- In order to get rid of the noise, only values above 2 are considered.
- Find shoulders that were not discovered previously.

```{r}
# In case the original data is advantageous for later analysis
ctrl_norm_mean_original = ctrl_norm_mean
rnase_norm_mean_original = rnase_norm_mean
```

Define Peak Finding Function

```{r}
# Function find_local_maxima
# Peak is local maximum with a certain amount (=window) of smaller points on each side
# Bigger window => more stringent peak finding procedure 

find_local_maxima <- function(x, window = 2) {
  n <- length(x)
  peaks <- c()

  for (i in 1:n) {
    left <- max(1, i - window)
    right <- min(n, i + window)
    neighbors <- x[left:right][-which((left:right) == i)]

    if (all(neighbors <= x[i])) {
      peaks <- c(peaks, i)
    }
  }

  return(peaks)
}
```

```{r}
# Apply the function to the data set 
# Restriction to values above an absolute threshold of 2%
# New column: "local_maxima" (column 26)

ctrl_norm_mean$local_maxima <- apply(ctrl_norm_mean, 1, function(x) {
															   peak_indices <- find_local_maxima(x)
															   filtered <- peak_indices[x[peak_indices] > 2] 
															   local_maxima <- unlist(filtered)
															   local_maxima
															   })
															   
rnase_norm_mean$local_maxima <- apply(rnase_norm_mean, 1, function(x) {
															   peak_indices <- find_local_maxima(x)
															   filtered <- peak_indices[x[peak_indices] > 2] 
															   local_maxima <- unlist(filtered)
															   local_maxima
															   })
```

```{r}
# Out of the local maxima, extract the global (greatest) maximum, and save it in a new column "global_maximum" (column 27)

ctrl_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
  x <- as.numeric(ctrl_norm_mean[i, 1:25])
  peaks <- ctrl_norm_mean$local_maxima[[i]]

  if (length(peaks) == 0) {
    return(NA)
  } else {
    peak_values <- x[peaks]
    return(peaks[which.max(peak_values)])
  }
})


rnase_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
  x <- as.numeric(rnase_norm_mean[i, 1:25])
  peaks <- rnase_norm_mean$local_maxima[[i]]

  if (length(peaks) == 0) {
    return(NA)
  } else {
    peak_values <- x[peaks]
    return(peaks[which.max(peak_values)])
  }
})
```


****************************************************************************************************************
5. Identify shoulders
****************************************************************************************************************

- Shoulders are regions that are not recognized as peaks, even though they have a high signal intensity.
- Create Binary Data Frames Indicating Signal > 2%

```{r}
# Identify the RNAse fractions with signal intensity > 2%. 
# Create a new data frame containing 0 (= this fraction value was ≤2% ) and 1 (= this fraction value was >2%.), as well as the intensity maxima.
# The two new data frames are created, rnase_3 and ctrl_3, as copies of the previously calculated, normalized mean tables (*_norm_mean).

rnase_3 <- rnase_norm_mean
# Compare each value in columns 1 to 25 (the fractions) of the rnase_norm_mean dataframe with the threshold of 2%.
# Convert TRUE to 1 and FALSE to 0. 
rnase_3[1:25] <- (rnase_norm_mean[1:25] > 2)*1

# Identify the CTRL fractions with signal intensity > 2%. 
# Create a new data frames containing 0 / 1, as well as the intensity maxima.
ctrl_3 <- ctrl_norm_mean
ctrl_3[1:25] <- (ctrl_norm_mean[1:25] > 2)*1
```

Mask Regions Around Detected Peaks to Exclude Them from Shoulder Search

```{r}
# Remove and exclude 3 fractions left and right of each peak (7 in total) from the shoulder search.

th_max_reg_simple <- function(x) {
  peaks <- as.numeric(unlist(x$local_maxima)) 
  mask <- rep(1, 25)
  
  for (peak in peaks) { # peak = current peak value, peaks = detected maxima (column 26)
    if (peak > 0) { 
      left <- max(1, peak - 3)
      right <- min(25, peak + 3) 
      mask[left:right] <- 0 # For each peak, the range from peak–3 to peak+3 is calculated and set to 0 in the mask
      
    }
  }

  x_values <- as.numeric(x[1:25])  
  x_values <- x_values * mask # Fractions with mask = 1 are retained. Fractions with mask = 0 are set to 0.
  return(x_values)
}

# Apply the function row by row to the entire rnase_3 or ctrl_3 DataFrame.
rnase_3[1:25] <- t(apply(rnase_3, 1, th_max_reg_simple))
ctrl_3[1:25]  <- t(apply(ctrl_3, 1, th_max_reg_simple))
```

Identify Shoulder Regions: Consecutive Fractions > 2% Without Peaks

```{r}
# Detect "shoulder regions"
# Define a function that identifies signal regions where there are at least 4 consecutive fractions with an intensity above 2% using the data frames rnase_3 and ctrl_3.
# select the middle of this region as shoulder

peaks_regions = function(x) {
  rle_result = rle(as.numeric(x[1:25])) # rle() finds all consecutive equal values -> $lengths and $values
  
  #Find positions of all blocks consisting of 1s with length ≥4. These blocks are considered “shoulder regions”.
  peak_blocks = which(rle_result$values == 1 & rle_result$lengths >= 4)
  
  #If there are no such blocks of length >4, return an empty vector
  if (length(peak_blocks) == 0) {
    return(numeric(0))
  }
  
  #Calculate estimate middle for the peak blocks
  peak_positions = numeric(length(peak_blocks))
  
  for(i in seq_along(peak_blocks)) {
    
    #Position of the end of the respective block 
    end_of_block = sum(rle_result$lengths[1:peak_blocks[i]])
    
    #Calculate half length of the block
    half_length = floor(rle_result$lengths[peak_blocks[i]] /2)
    
    #Middle position of the shoulder 
    peak_positions[i] = end_of_block - half_length
  }
  
  return(peak_positions)
}
```

```{r}
# Calculate the positions of the "shoulders" for each row for the data.frames ctrl/rnase_3 and ctrl/rnase_norm_mean
# New column: "shoulders" (column 28)

rnase_3$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_3$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )


rnase_norm_mean$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_norm_mean$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )
```

Combine Peak and Shoulder Positions for Each Protein

```{r}
# Calculate the total of all relevant signal maxima (real peaks and shoulders) for each protein row in the data.frames
# New column: "combined_max_ctrl" and "combined_max_rnase" (column 29) respectively

						   						
rnase_3$combined_max_rnase <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima)) # ls_max = numerical vector with the peak positions of this protein
												 ls_shoulder <- as.numeric(unlist(x$shoulders))
												 
												 combined_max_rnase <- c(ls_max, ls_shoulder) # Combine to common vector.
												 combined_max_rnase <- unlist(combined_max_rnase)
												 combined_max_rnase <- combined_max_rnase[combined_max_rnase!=0] # Remove all 0 entries from the result vector, as these do not represent real signals.
												 combined_max_rnase <- sort(combined_max_rnase, decreasing = FALSE) # Sort all peak and shoulder positions in ascending order (1 → 25)
												 if (length(combined_max_rnase) == 0) {0} else {combined_max_rnase} # If there are no peaks or shoulders, 0 (as a placeholder) is stored.
												 })

ctrl_3$combined_max_ctrl <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 ls_shoulder <- as.numeric(unlist(x$shoulders))
												 
												 combined_max_ctrl <- c(ls_max, ls_shoulder)
												 combined_max_ctrl <- unlist(combined_max_ctrl)
												 combined_max_ctrl <- combined_max_ctrl[combined_max_ctrl!=0]
												 combined_max_ctrl <- sort(combined_max_ctrl, decreasing = FALSE)
												 if (length(combined_max_ctrl) == 0) {0} else {combined_max_ctrl} 
												 })


# Add new column of the combined maxima to ctrl/rnase_nrom_mean, to continue working with it

ctrl_norm_mean$combined_max_ctrl = ctrl_3[, "combined_max_ctrl"]
rnase_norm_mean$combined_max_rnase = rnase_3[, "combined_max_rnase"]
```

***********************************************************************************************************
6. Count Total Number of Maxima (Peaks + Shoulders) per Protein
***********************************************************************************************************

```{r}
# Determine the number of combined maxima (peaks + shoulders) per protein
# New column: "n_max_comb" (column 30)

rnase_3$n_max_comb <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$combined_max_rnase))
												 n = length(ls_max) # determines how many peaks (maxima and shoulders) the protein has
												 if (sum(ls_max) == 0) {0} else {n}  
												 })
												 
ctrl_3$n_max_comb <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$combined_max_ctrl))
												 n = length(ls_max)
												 if (sum(ls_max) == 0) {0} else {n} 
												 })


# Same for ctrl/rnase_norm_mean

ctrl_norm_mean$n_max_comb = ctrl_3[, "n_max_comb"]
rnase_norm_mean$n_max_comb = rnase_3[, "n_max_comb"] 
```


***********************************************************************************************************
7. Identification of proteins with a different number of peaks in CTRL vs. RNASE
***********************************************************************************************************

```{r}
# Determine the number of only peak maxima ("local_maxima") per protein
# New column: "n_local_maxima" (column 31)

rnase_3$n_local_maxima <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 n = length(ls_max) 
												 if (sum(ls_max) == 0) {0} else {n}  
												 })
												 
ctrl_3$n_local_maxima <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 n = length(ls_max)
												 if (sum(ls_max) == 0) {0} else {n} 
												 })

# Same for ctrl/rnase_norm_mean

ctrl_norm_mean$n_local_maxima = ctrl_3[, "n_local_maxima"]
rnase_norm_mean$n_local_maxima = rnase_3[, "n_local_maxima"]  
```


***********************************************************************************************************
8. Add COM (center of mass) values 
***********************************************************************************************************

```{r}
# Calculate the center of mass for each row 
# x is the vector with the intensities of a protein across all 25 fractions for which the COM is currently being calculated
# * means element-wise multiplication

ctrl_norm_mean$COM <- apply(ctrl_norm_mean[, 1:25], 1, function(x) {
  sum((1:25) * x, na.rm = TRUE) / sum(x, na.rm = TRUE)
})

rnase_norm_mean$COM <- apply(rnase_norm_mean[, 1:25], 1, function(x) {
  sum((1:25) * x, na.rm = TRUE) / sum(x, na.rm = TRUE)
})
```



###########################################################################
Teil von Julian Baureis und Luisa Fee Wintel (Zeile 701 - 1218), Codewriting assisted by ChatGPT 
###########################################################################

***********************************************************************************************************
0. Useful functions, that will be used in this part 
***********************************************************************************************************

Correlation function 
Inputs: - df1: data.frame 1
        - df2: data.frame 2
Output: - List with 1. $correlations: the single correaltion values, 2. $mean_abs_correlation: the mean value of the abolute correaltion values
```{r}
# Function to calculate the row-wise correlation between the rows of two data.frames

correlations <- function(df1, df2, methode = "pearson") {
  
  # Check whether both data frames have the same dimensions
  if (!all(dim(df1) == dim(df2))) {
    stop("Both data frames need to have same dimension")
  }

  # Number of rows
  n <- nrow(df1)

  # Vector for storing the correlation values
  correlations <- numeric(n)

  # Loop over all rows
  for (i in 1:n) {
    v1 <- as.numeric(df1[i, 1:25])
    v2 <- as.numeric(df2[i, 1:25])

    # Calculate correlation only if both vectors have variance
    if (sd(v1, na.rm = TRUE) != 0 && sd(v2, na.rm = TRUE) != 0) {
      correlations[i] <- cor(v1, v2, method = methode, use = "complete.obs")
    } else {
      correlations[i] <- NA
    }
  }

  abs_correlations = abs(correlations)
  
  mean_abs_correlation = mean(abs_correlations, na.rm = TRUE)
  
  return(list(
    correlations = correlations, mean_abs_correlation = mean_abs_correlation
  ))
}
```


Plotting function
Inputs: - cor_vector: vector with the correlation values 
        - ctrl_data & rnase_data: the data.frames, that were used, to calculate the row-wise correlations
        - n: Number of example plots to be plotted
        - cor_threshold: threshold of correlation values, to only get certain entries of the cor_vector
        - direction: defines the conditions by which the cor_vector is compared with the threshold
Output: - n plots for the desired conditions
```{r}
# Function to plot a defined amount of protein curves (ctrl & rnase), based on a selected threshold and condition (= direction)
header_plotting <- function(cor_vector,
                             ctrl_data,
                             rnase_data,
                             n = 5,
                             cor_threshold = 0.6,
                             direction = "abs_lt") {
  # selecting the indices based on the direction 
  selected <- switch(direction,
                     lt      = which(cor_vector < cor_threshold),
                     gt      = which(cor_vector > cor_threshold),
                     abs_lt  = which(abs(cor_vector) < cor_threshold),
                     abs_gt  = which(abs(cor_vector) > cor_threshold),
                     stop("wrong value for direction used")
  )
  
  # Just use n plots
  selected_indices = head(selected, n)
  
  # Plotting
  for (i in selected_indices) {
    cs = as.numeric(ctrl_data[i, 1:25])
    rs = as.numeric(rnase_data[i, 1:25])
    
    plot(
      cs,
      type = "l",
      main = paste("Protein at index", i),
      xlab = "Fractions",
      ylab = "Values",
      col = "blue",
      lwd = 2,
      ylim = range(c(cs, rs), na.rm = TRUE)
    )
    
    lines(
      rs,
      type = "l",
      col = "red",
      lwd = 2
    )
  }
}
```





***********************************************************************************************************
1. Criterion for data set purification:
The center of mass for a (likely) RNA-dependent protein is shifted by at least two fractions
***********************************************************************************************************

Create new data.frames out of ctrl/rnase_norm_mean to select those proteins, that exhibit a shift in their overall center of mass
```{r}
# Calculate the absolute difference of the positions of the COM values between ctrl and rnase 
diff_COM <- abs(ctrl_norm_mean$COM - rnase_norm_mean$COM)

# Indices of proteins with deviation ≥ 2 fractions
deviating_COM <- which(diff_COM >= 2)

# Apply on the data.frames
ctrl_COM_shift = ctrl_norm_mean[deviating_COM, ]
rnase_COM_shift = rnase_norm_mean[deviating_COM, ]

# Create the complementary data.frame that contains all proteins whose COM do not shift by at least 2 fractions
ctrl_no_COM_shift = ctrl_norm_mean[!rownames(ctrl_norm_mean) %in% rownames(ctrl_COM_shift), ]
rnase_no_COM_shift = rnase_norm_mean[!rownames(rnase_norm_mean) %in% rownames(rnase_COM_shift), ]
```




***********************************************************************************************************
Hypothesis: Correlation of ctrl_COM_shift with rnase_COM_shift is lower than that of ctrl_no_COM_shift with rnase_no_COM_shift
***********************************************************************************************************

Define the variables for the correlation values, use the correlation function 
```{r}
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose COM is shifted by at least 2 fractions
COM_shifter = correlations(ctrl_COM_shift, rnase_COM_shift)
COM_shifter$mean_abs_correlation

# Mean of the correlation values (ctrl vs. rnase) for those proteins whose COM is not shifted by at least 2 fractions
COM_no_shifter = correlations(ctrl_no_COM_shift, rnase_no_COM_shift)
COM_no_shifter$mean_abs_correlation

# Calculate the mean correlation value among all proteins 
cor_all_proteins = correlations(ctrl_norm_mean, rnase_norm_mean)
cor_all_proteins$mean_abs_correlation
```

Our hypothesis was confirmed. The mean correlation between ctrl and rnase is smaller for proteins whose COM was shifted by at least two fractions. Here, it is 0.36. For proteins without a large shift of their COM, it is 0.91.
The mean correlation for all proteins is 0.79. This is less than 0.92 and greater than 0.36.This initially suggests that purification of RNA-dependent proteins based on the criterion of a significant shift in the center of mass appears to be reasonable.



Plotting the correlation values in a histogram
```{r}
par(mfrow = c(1, 2)) 

hist(
  COM_shifter$correlations,
  main = "Correlation values for COM shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "skyblue",
  border = "white",
  xlim = c(-1, 1) 
)


hist(
  COM_no_shifter$correlations,
  main = "Correlation values for not COM shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "salmon",
  border = "white",
  xlim = c(-1, 1)
)

par(mfrow = c(1, 1))
```
The correlation values for proteins with a shifted COM are much more located around 0. The correlation values for proteins with no COM shift show a clear tendency to high correlation values, most of them for correlation values between 0.9 and 1. 



Examine those proteins, that still show a high correlation value, despite showing a shift in their center of mass, use the plotting function
```{r}
header_plotting(COM_shifter$correlations, ctrl_COM_shift, rnase_COM_shift, n = 5, cor_threshold = 0.9, direction = "gt")
```
They show a high correlation, because the curves look very similar, only a small portion shifted.
Possible Interpretation: The proteins are partially RNA-dependent, and through RNase digestion in the experiment, they shifted to the much larger rest, that is normally not associated with RNA, and therefore not affected by RNAse digestion. Thats why blue (ctrl) and red (rnase) curve have a joined big peak, and the blue (ctrl) curve has an additional small peak, that is RNA-dependent. 



Examine the proteins with no big COM shift, that have a very high correlation value. 
```{r}
header_plotting(COM_no_shifter$correlations, ctrl_no_COM_shift, rnase_no_COM_shift, n = 5, cor_threshold = 0.9, direction = "gt")
```
As expected, these proteins have a very similar distribution. They should not be considered RNA-dependent. But what about the proteins, that show no big COM shift, but still a low correlation value. How do they look?



Examine the proteins with no big COM shift, that have a lower correlation value
```{r}
header_plotting(COM_no_shifter$correlations, ctrl_no_COM_shift, rnase_no_COM_shift, n = 5, cor_threshold = 0.7, direction = "lt")
```
The proteins did not show a COM shift. However, their overall distribution looks very different. Often, one curve shifts a bit to both sides at the same time, resulting in this effect. 





***********************************************************************************************************
2. Criterion for data set purification:
The shift of the global maximum between ctrl and rnase is used as a further purification criterion
***********************************************************************************************************

We use a shift in the global maximum as another criterion, to identify those proteins, that do not show a big shift in their COM, but still look very different, and therefore exhibit a shift, when only observing their greatest/global maximum. 
Therefore, from the data.frame "ctrl/rnase_no_COM_shift", we first separate the proteins, that actually show a shift in their global maxima. 

```{r}
# Calculate the absolute difference of the position of the global maximum between ctrl and rnase 
diff_main_maxima <- abs(ctrl_no_COM_shift$global_maximum - rnase_no_COM_shift$global_maximum)

# Indices of proteins with deviation ≥ 3 fractions
deviating_main_maxima <- which(diff_main_maxima >= 3)

# Apply on the data.frames
ctrl_main_shift = ctrl_no_COM_shift[deviating_main_maxima, ]
rnase_main_shift = rnase_no_COM_shift[deviating_main_maxima, ]

# Create the complementary data.frame that contains all proteins whose main maximum does not shift by at least 2 fractions
ctrl_no_main_shift = ctrl_no_COM_shift[!rownames(ctrl_no_COM_shift) %in% rownames(ctrl_main_shift), ]
rnase_no_main_shift = rnase_no_COM_shift[!rownames(rnase_no_COM_shift) %in% rownames(rnase_main_shift), ]
```



Define the variables for the correlation values, use again the correlation function
```{r}
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is shifted by at least 2 fractions
main_shifter = correlations(ctrl_main_shift, rnase_main_shift)
main_shifter$mean_abs_correlation

# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is not shifted by at least 2 fractions
main_no_shifter = correlations(ctrl_no_main_shift, rnase_no_main_shift)
main_no_shifter$mean_abs_correlation

# Calculate the mean correlation value among all proteins, that show no shift in their COM
cor_all_proteins_no_COM = correlations(ctrl_no_COM_shift, rnase_no_COM_shift)
cor_all_proteins_no_COM$mean_abs_correlation
```
The mean correlation value for the proteins with a COM shift AND an additional shift in their global maximum is much lower with 0.61 than the mean correlation value for those proteins with no COM shift and no global maximum shift with 0.93 The correlation values are separately plotted in a histogram. 




Plotting the correlation values in a histogram, remember: both histogramms are based on the proteins, that showed NO shift in their COM
```{r}
par(mfrow = c(1, 2)) 

hist(
  main_shifter$correlations,
  main = "Corr values for main shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "skyblue",
  border = "white",
  xlim = c(-1, 1) 
)


hist(
  main_no_shifter$correlations,
  main = "Corr values for not main shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "salmon",
  border = "white",
  xlim = c(-1, 1)
)

par(mfrow = c(1, 1))
```


Examine the proteins of the left histogram, that additional to no big COM shift, showed a main shift
```{r}
header_plotting(main_shifter$correlations, ctrl_main_shift, rnase_main_shift, n = 5, cor_threshold = 0.9, direction = "gt" )
```

These proteins do not seem RNA-dependent, the curves look very similar. This is because there is no COM shift, and the existent global maximum shift does not lead to a change in the overall curve, for example because there are two big maxima in each ctrl and rnase, and ctrl has the global maximum at one of them, rnase has its global maximum at the other one. On paper, this is a global maximum shift, but the overall curves still look very similar. 
In order to separate these proteins, an arbitrary threshold is used, to cut off those proteins, whose curves look to similar despite a global maximum shift. 




Plot the left histogram and the arbitrary threshold. On the right side of the threshold, the respective proteins will be consideres as not RNA-dependent for our analysis. 
```{r}
hist(
  main_shifter$correlations,
  main = "Corr values main shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "salmon",
  border = "white",
  breaks = 50, 
  xlim = c(-1, 1)
)
abline(v = 0.75)
```


```{r}
# Define threshold
threshold = 0.7

keep_indices = COM_no_shifter$correlations <= threshold

# New data.frames with the proteins, that might be RNA-dependent
ctrl_under_threshold = ctrl_no_COM_shift[keep_indices, ]
rnase_under_threshold = rnase_no_COM_shift[keep_indices, ]

# New data.frames with the proteins, that are not RNA-dependent by arbitrary choice
ctrl_above_threshold = ctrl_no_COM_shift[!keep_indices, ]
rnase_above_threshold = rnase_no_COM_shift[!keep_indices, ]

```





***********************************************************************************************************
8. Wilcoxon Rank-Sum Test
***********************************************************************************************************

Statistical assessment of whether the purification of the dataset has resulted in the selected proteins showing significant differences between ctrl and rnase (e.g., in COM), while the non-selected proteins do not show these differences


1: ctrl_COM_shift and ctrl_main_shift, as well as rnase_COM_shift and rnase_under_threshold are combined
--> ctrl_selected & rnase_selected

2: Test, if rownames(ctrl_selected) != rownames(rnase_selected), so that they contain the same proteins in the same order. If the result is 0, then everything worked.

3: ctrl_no_main_shift, as well as rnase_no_main_shift represent the not selected proteins of our criteria
--> ctrl_not_selected & rnase_not_selected

4: Test, if rownames(ctrl_not_selected) != rownames(rnase_not_selected), so that they contain the same proteins in the same order. If the result is 0, then everything worked. 

5: Check, if the combination of both data.frames would still consist of all the proteins from the start data.frames. If the result is TRUE, then everything worked. 

6.1: The mean value of the peak positions per row is calculated from the column "combined_max_ctrl" of ctrl_selected, and then compared with the mean value of the peak positions of "combined_max_rnase" of rnase_selected

6.2: The mean value of the peak positions per row is calculated from the column "combined_max_ctrl" of control_not_selected  and then compared with the mean value of the peak positions of "combined_max_rnase" of rnase_not_selected

6.3: Wilcoxon Rank Sum Test is performed, to compare the differences of the mean values of the peak positions
--> H0: There is no systematic difference in the distribution of these differences


```{r}
#1
ctrl_selected = rbind(ctrl_COM_shift, ctrl_main_shift)
rnase_selected = rbind(rnase_COM_shift, rnase_main_shift)

#2
sum(rownames(ctrl_selected) != rownames(rnase_selected))

#3
ctrl_not_selected = ctrl_no_main_shift
rnase_not_selected = rnase_no_main_shift

#4
sum(rownames(ctrl_not_selected) != rownames(rnase_not_selected))

#5 
dim(ctrl_not_selected)[1] + dim(ctrl_selected)[1] == dim(ctrl_norm_mean)[1]
```

```{r}
#6
# Calculate mean values per row and form the difference
get_differences <- function(ctrl_df, rnase_df, ctrl_col, rnase_col) {
  ctrl_means <- sapply(ctrl_df[[ctrl_col]], mean)
  rnase_means <- sapply(rnase_df[[rnase_col]], mean)
  return(ctrl_means - rnase_means)
}

# Calculate the difference vectors for both groups
diff_selected <- get_differences(ctrl_selected, rnase_selected, "combined_max_ctrl", "combined_max_rnase")
diff_not_selected <- get_differences(ctrl_not_selected, rnase_not_selected, "combined_max_ctrl", "combined_max_rnase")

# Wilcoxon Rank-Sum Test (unpaired)
wilcox_test_result <- wilcox.test(diff_selected, diff_not_selected)

# Show result
print(wilcox_test_result)
```



Plots
```{r}
library(ggplot2)

# Vector with group membership
group <- c(rep("selected", length(diff_selected)), rep("not_selected", length(diff_not_selected)))
diffs <- c(diff_selected, diff_not_selected)

df_plot <- data.frame(Group = group, Difference = diffs)

ggplot(df_plot, aes(x = Difference, fill = Group)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "density distribution of the differnces", x = "difference (ctrl - rnase)")
```
What can you see on this plot?
The density for the differences for "not_selected" are concentrated around 0. This is expected, because our criteria aimed to separate the not RNA-dependent proteins, that show very similar curves for ctrl and rnase, and therefore no real difference between their local maxima and shoulder regions. 
The density for the differences for "selected" is more even distributed, but reaches far greater values, which is expected, because, under our criteria, these proteins should be not similar between theri ctrl and rnase curves. 
The density is also mostly around positive values. Therefore, the following largely seems to hold: The mean values of the control maxima are larger than the mean values of the RNase maxima, which may indicate an increased left shift of the RNase fractions.



Scatter plots for visualization of how the COM values and global_maximum values behave for the selected and not_selected proteins between ctrl and rnase 
```{r}
par(mfrow = c(1, 2)) 

plot(
  ctrl_selected$COM, rnase_selected$COM,
  xlab = "COM from ctrl_selected",
  ylab = "COM from rnase_selected",
  main = "Scatter Plot of the COM values",
  pch = 19,       
  col = "blue"    
)
abline(a = 0, b = 1, col = "red", lwd = 3, lty = 3)


plot(
  ctrl_not_selected$COM, rnase_not_selected$COM,
  xlab = "COM from ctrl_not_selected",
  ylab = "COM from rnase_not_selected",
  main = "Scatter Plot of the COM values",
  pch = 19,       
  col = "blue"    
)
abline(a = 0, b = 1, col = "red", lwd = 3, lty = 3)



par(mfrow = c(1, 1)) 
```


```{r}
par(mfrow = c(1, 2)) 

plot(
  ctrl_selected$global_maximum, rnase_selected$global_maximum,
  xlab = "global_maximum from ctrl_selected",
  ylab = "global_maximum from rnase_selected",
  main = "Scatter Plot global_maximum values",
  pch = 19,       
  col = "blue"    
)
abline(a = 0, b = 1, col = "red", lwd = 3, lty = 3)


plot(
  ctrl_not_selected$global_maximum, rnase_not_selected$global_maximum,
  xlab = "global_maximum from ctrl_not_selected",
  ylab = "global_maximum from rnase_not_selected",
  main = "Scatter Plot global_maximum values",
  pch = 19,       
  col = "blue"    
)
abline(a = 0, b = 1, col = "red", lwd = 3, lty = 3)



par(mfrow = c(1, 1)) 
```


Wichtig für die Conclusion:

correlation ist nicht alleine aussagekräftig, man kann auch hoch korrelieren und trotzdem vollkommen unterschiedlich sein, aber zusammen mit COM ist es geeignet zum finden. 



***********************************************************************************************************
9. Principle Component Analysis (PCA)
  by Benjamin Nicklas influenced by ChatGPT
***********************************************************************************************************

```{r}
# Keep only numerical columns
pca_ctrl_numeric <- ctrl_selected[, sapply(ctrl_selected, is.numeric)][, 1:25]
pca_rnase_numeric <- rnase_selected[, sapply(rnase_selected, is.numeric)][, 1:25]

# Remove rows with NAs
pca_ctrl_clean <- pca_ctrl_numeric[complete.cases(pca_ctrl_numeric), ]
pca_rnase_clean <- pca_rnase_numeric[complete.cases(pca_rnase_numeric), ]

pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
```

```{r}
# Keep only numerical columns
pca_ctrl_numeric_not_selected <- ctrl_not_selected[,sapply(ctrl_not_selected, is.numeric)][, 1:25]
pca_rnase_numeric_not_selected <- rnase_not_selected[,sapply(rnase_not_selected, is.numeric)][, 1:25]

# Remove rows with NAs
pca_ctrl_clean_not_selected <- pca_ctrl_numeric_not_selected[complete.cases(pca_ctrl_numeric_not_selected), ]
pca_rnase_clean_not_selected <- pca_rnase_numeric_not_selected[complete.cases(pca_rnase_numeric_not_selected), ]

pca_result_ctrl_not_selected <- prcomp(pca_ctrl_clean_not_selected, center = TRUE, scale. = TRUE, )
pca_result_rnase_not_selected <- prcomp(pca_rnase_clean_not_selected, center = TRUE, scale. = TRUE)
```

```{r}
# Check which PCs have the most variance
summary(pca_result_ctrl)
summary(pca_result_rnase)

summary(pca_result_ctrl_not_selected)
summary(pca_result_rnase_not_selected)
```

```{r}
#plot PC1 with PC2
plot(pca_result_ctrl$x[,1:2], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL (SHIFT)")

plot(pca_result_rnase$x[,1:2], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE (SHIFT)")

#plot PC1 with PC3
plot(pca_result_ctrl$x[,c(1, 3)], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL (SHIFT)")

plot(pca_result_rnase$x[,c(1, 3)], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE (SHIFT)")


#plot PC2 with PC3
plot(pca_result_ctrl$x[,2:3], col = "midnightblue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL (SHIFT)")

plot(pca_result_rnase$x[,2:3], col = "midnightblue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE (SHIFT)")



# Simple 2D PCA-Plot
plot(pca_result_ctrl_not_selected$x[,1:2], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,1:2], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE (NO SHIFT)")

#plot PC1 with PC3
plot(pca_result_ctrl_not_selected$x[,c(1, 3)], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,c(1, 3)], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE (NO SHIFT)")


#plot PC2 with PC3
plot(pca_result_ctrl_not_selected$x[,2:3], col = "midnightblue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,2:3], col = "midnightblue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE (NO SHIFT)")
```

```{r}
#Recognize centers for k-means clustering -> 3 centers
plot(pca_result_ctrl, type = "l", main = "Elbow-Plot CTRL (SHIFT)")
plot(pca_result_rnase, type = "l", main = "Elbow-Plot RNASE (SHIFT)")

#Recognize centers for k-means clustering -> 2 centers
plot(pca_result_ctrl_not_selected, type = "l", main = "Elbow-Plot CTRL (NO SHIFT)")
plot(pca_result_rnase_not_selected, type = "l", main = "Elbow-Plot RNASE (NO SHIFT)")
```
```{r}
pca_ctrl_pc1_pc2 <- as.data.frame(pca_result_ctrl$x[, 1:2])
pca_ctrl_pc1_pc3 <- as.data.frame(pca_result_ctrl$x[, c(1,3)])
pca_ctrl_pc2_pc3 <- as.data.frame(pca_result_ctrl$x[, 2:3])

pca_rnase_pc1_pc2 <- as.data.frame(pca_result_rnase$x[, 1:2])
pca_rnase_pc1_pc3 <- as.data.frame(pca_result_rnase$x[, c(1,3)])
pca_rnase_pc2_pc3 <- as.data.frame(pca_result_rnase$x[, 2:3])
```

```{r}
pca_ctrl_pc1_pc2_not_selected <- as.data.frame(pca_result_ctrl_not_selected$x[, 1:2])
pca_ctrl_pc1_pc3_not_selected <- as.data.frame(pca_result_ctrl_not_selected$x[, c(1,3)])
pca_ctrl_pc2_pc3_not_selected <- as.data.frame(pca_result_ctrl_not_selected$x[, 2:3])

pca_rnase_pc1_pc2_not_selected <- as.data.frame(pca_result_rnase_not_selected$x[, 1:2])
pca_rnase_pc1_pc3_not_selected <- as.data.frame(pca_result_rnase_not_selected$x[, c(1,3)])
pca_rnase_pc2_pc3_not_selected <- as.data.frame(pca_result_rnase_not_selected$x[, 2:3])
```

```{r}
library(factoextra)

fviz_nbclust(pca_ctrl_pc1_pc2, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc1_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc2_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC2/PC3") +
  theme_minimal()

fviz_nbclust(pca_rnase_pc1_pc2, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC3") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc2_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC2/PC3") +
  theme_minimal()



fviz_nbclust(pca_ctrl_pc1_pc2_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc1_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc2_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC2/PC3") +
  theme_minimal()

fviz_nbclust(pca_rnase_pc1_pc2_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC3") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc2_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC2/PC3") +
  theme_minimal()
```




***********************************************************************************************************
10. K-means clustering 
  by Benjamin Nicklas influenced by ChatGPT
***********************************************************************************************************

```{r}
#kmeans is executed with 3 centers --> see elbow-Plot and silhouette plot
km_result_ctrl_pc1_pc2<- kmeans(pca_ctrl_pc1_pc2, centers = 3)
km_result_ctrl_pc1_pc3<- kmeans(pca_ctrl_pc1_pc3, centers = 3)
km_result_ctrl_pc2_pc3<- kmeans(pca_ctrl_pc2_pc3, centers = 3)

km_result_rnase_pc1_pc2<- kmeans(pca_rnase_pc1_pc2, centers = 3)
km_result_rnase_pc1_pc3<- kmeans(pca_rnase_pc1_pc3, centers = 3)
km_result_rnase_pc2_pc3<- kmeans(pca_rnase_pc2_pc3, centers = 3)
```

```{r}
#kmeans is executed with 2 centers
km_result_ctrl_pc1_pc2_not_selected<- kmeans(pca_ctrl_pc1_pc2_not_selected, centers = 3)
km_result_ctrl_pc1_pc3_not_selected<- kmeans(pca_ctrl_pc1_pc3_not_selected, centers = 3)
km_result_ctrl_pc2_pc3_not_selected<- kmeans(pca_ctrl_pc2_pc3_not_selected, centers = 3)

km_result_rnase_pc1_pc2_not_selected<- kmeans(pca_rnase_pc1_pc2_not_selected, centers = 3)
km_result_rnase_pc1_pc3_not_selected<- kmeans(pca_rnase_pc1_pc3_not_selected, centers = 3)
km_result_rnase_pc2_pc3_not_selected<- kmeans(pca_rnase_pc2_pc3_not_selected, centers = 3)
```

```{r}
library(factoextra)

# pca_df contains the data, e.g. PC1 and PC2
fviz_cluster(km_result_ctrl_pc1_pc2, data = pca_ctrl_pc1_pc2,
             geom = "point", ellipse.type = "norm", stand = FALSE, 
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 CTRL (SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc2, data = pca_rnase_pc1_pc2,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("firebrick3", "violetred4", "midnightblue"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 RNASE (SHIFT)")

fviz_cluster(km_result_ctrl_pc1_pc3, data = pca_ctrl_pc1_pc3,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 CTRL (SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc3, data = pca_rnase_pc1_pc3,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("violetred4", "midnightblue", "firebrick3"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 RNASE (SHIFT)")

fviz_cluster(km_result_ctrl_pc2_pc3, data = pca_ctrl_pc2_pc3,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 CTRL (SHIFT)")
fviz_cluster(km_result_rnase_pc2_pc3, data = pca_rnase_pc2_pc3,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 RNASE (SHIFT)")



# pca_df contains the data, e.g. PC1 and PC2
fviz_cluster(km_result_ctrl_pc1_pc2_not_selected, data = pca_ctrl_pc1_pc2_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 CTRL (NO SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc2_not_selected, data = pca_rnase_pc1_pc2_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 RNASE (NO SHIFT)")

fviz_cluster(km_result_ctrl_pc1_pc3_not_selected, data = pca_ctrl_pc1_pc3_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 CTRL (NO SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc3_not_selected, data = pca_rnase_pc1_pc3_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("firebrick3", "midnightblue", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 RNASE (NO SHIFT)")

fviz_cluster(km_result_ctrl_pc2_pc3_not_selected, data = pca_ctrl_pc2_pc3_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 CTRL (NO SHIFT)")
fviz_cluster(km_result_rnase_pc2_pc3_not_selected, data = pca_rnase_pc2_pc3_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 RNASE (SHIFT)")
```
```{r}
# JPEG-Datei öffnen
jpeg("k-Means Cluster PC1 vs PC2 RNASE (NO SHIFT).jpeg", width = 800, height = 600)

fviz_cluster(km_result_rnase_pc1_pc2_not_selected, data = pca_rnase_pc1_pc2_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 RNASE (NO SHIFT)")


# Grafikgerät schließen
dev.off()

```

**************************************************************************************************************
11. Linear regression analysis
  by Julia Ferdin influenced by ChatGPT
**************************************************************************************************************

```{r}
#For ctrl selected vs rnase selected 
#Rename relevant variables to avoid PC name redundance later on
ctrl_1 <- pca_ctrl_pc1_pc2$PC1
ctrl_2 <- pca_ctrl_pc1_pc2$PC2
ctrl_3 <- pca_ctrl_pc1_pc3$PC3

rnase_1 <- pca_rnase_pc1_pc2$PC1
rnase_2 <- pca_rnase_pc1_pc2$PC2
rnase_3 <- pca_rnase_pc1_pc3$PC3


#Generates plot with PCA datapoints and draws a trendline through it
plot(ctrl_1,rnase_1,pch=20,col='blue', xlab='Ctrl selected PC1',ylab='Rnase selected PC1', main = "Ctrl selected PC1 vs Rnase selected PC1");abline(0,1,col='red')
plot(ctrl_1,rnase_2,pch=20,col='blue', xlab='Ctrl selected PC1',ylab='Rnase selected PC2', main = "Ctrl selected PC1 vs Rnase selected PC2");abline(0,1,col='red')
plot(ctrl_1,rnase_3,pch=20,col='blue', xlab='Ctrl selected PC1',ylab='Rnase selected PC3', main = "Ctrl selected PC1 vs Rnase selected PC3");abline(0,1,col='red')

plot(ctrl_2,rnase_1,pch=20,col='blue', xlab='Ctrl selected PC2',ylab='Rnase selected PC1', main = "Ctrl selected PC2 vs Rnase selected PC1");abline(0,1,col='red')
plot(ctrl_2,rnase_2,pch=20,col='blue', xlab='Ctrl selected PC2',ylab='Rnase selected PC2', main = "Ctrl selected PC2 vs Rnase selected PC2");abline(0,1,col='red')
plot(ctrl_2,rnase_3,pch=20,col='blue', xlab='Ctrl selected PC2',ylab='Rnase selected PC3', main = "Ctrl selected PC2 vs Rnase selected PC3");abline(0,1,col='red')

plot(ctrl_3,rnase_1,pch=20,col='blue', xlab='Ctrl selected PC3',ylab='Rnase selected PC1', main = "Ctrl selected PC3 vs Rnase selected PC1");abline(0,1,col='red')
plot(ctrl_3,rnase_2,pch=20,col='blue', xlab='Ctrl selected PC3',ylab='Rnase selected PC2', main = "Ctrl selected PC3 vs Rnase selected PC2");abline(0,1,col='red')
plot(ctrl_3,rnase_3,pch=20,col='blue', xlab='Ctrl selected PC3',ylab='Rnase selected PC3', main = "Ctrl selected PC3 vs Rnase selected PC3");abline(0,1,col='red')


#Defines a target variable, so what should be predicted by the regression analysis
target_selected <- ctrl_selected$global_maximum


#Builds matrix for regression analysis from target variable with two PCA components
df_regression_selected_11 <- cbind(target = target_selected ,
                      ctrl_1, rnase_1)
df_regression_selected_12 <- cbind(target = target_selected ,
                       ctrl_1, rnase_2)
df_regression_selected_13 <- cbind(target = target_selected ,
                       ctrl_1, rnase_3)

df_regression_selected_21 <- cbind(target = target_selected ,
                       ctrl_2, rnase_1)
df_regression_selected_22 <- cbind(target =target_selected,
                       ctrl_2, rnase_2)
df_regression_selected_23 <- cbind(target = target_selected ,
                       ctrl_2, rnase_3)

df_regression_selected_31 <- cbind(target = target_selected ,
                       ctrl_3, rnase_1)
df_regression_selected_32 <- cbind(target =target_selected ,
                       ctrl_3, rnase_2)
df_regression_selected_33 <- cbind(target = target_selected ,
                       ctrl_3, rnase_3)


#Make matrix a data frame
df_regression_selected_11 <- as.data.frame(df_regression_selected_11)
df_regression_selected_12 <- as.data.frame(df_regression_selected_12)
df_regression_selected_13 <- as.data.frame(df_regression_selected_13)

df_regression_selected_21 <- as.data.frame(df_regression_selected_21)
df_regression_selected_22 <- as.data.frame(df_regression_selected_22)
df_regression_selected_23 <- as.data.frame(df_regression_selected_23)

df_regression_selected_31 <- as.data.frame(df_regression_selected_31)
df_regression_selected_32 <- as.data.frame(df_regression_selected_32)
df_regression_selected_33 <- as.data.frame(df_regression_selected_33)

#Multiple linear regression analysis
model_selected_pc1_1<- lm(target ~ ctrl_1 + rnase_1, data = df_regression_selected_11)
model_selected_pc1_2<- lm(target ~ctrl_1 + rnase_2, data = df_regression_selected_12)
model_selected_pc1_3<- lm(target ~ ctrl_1 + rnase_3, data = df_regression_selected_13)

model_selected_pc2_1<- lm(target ~ ctrl_2 + rnase_1, data = df_regression_selected_21)
model_selected_pc2_2<- lm(target ~ ctrl_2 + rnase_2, data = df_regression_selected_22)
model_selected_pc2_3<- lm(target ~ ctrl_2 + rnase_3, data = df_regression_selected_23)

model_selected_pc3_1<- lm(target ~ ctrl_3 + rnase_1, data = df_regression_selected_31)
model_selected_pc3_2<- lm(target ~ ctrl_3 + rnase_2, data = df_regression_selected_32)
model_selected_pc3_3<- lm(target ~ ctrl_3 + rnase_3, data = df_regression_selected_33)

#Show results/summary
summary(model_selected_pc1_1)
summary(model_selected_pc1_2)
summary(model_selected_pc1_3)

summary(model_selected_pc2_1)
summary(model_selected_pc2_2)
summary(model_selected_pc2_3)

summary(model_selected_pc3_1)
summary(model_selected_pc3_2)
summary(model_selected_pc3_3)
```

```{r}
#For ctrl not-selected vs rnase not-selected
#Rename relevant variables to avoid PC name redundance later on
ctrl_ns_1 <- pca_ctrl_pc1_pc2_not_selected$PC1
ctrl_ns_2 <- pca_ctrl_pc1_pc2_not_selected$PC2
ctrl_ns_3 <- pca_ctrl_pc1_pc3_not_selected$PC3

rnase_ns_1 <- pca_rnase_pc1_pc2_not_selected$PC1
rnase_ns_2 <- pca_rnase_pc1_pc2_not_selected$PC2
rnase_ns_3 <- pca_rnase_pc1_pc3_not_selected$PC3


#Generates plot with PCA datapoints and draws a trendline through it
plot(ctrl_ns_1,rnase_ns_1,pch=20,col='blue', xlab='Ctrl not-selected PC1',ylab='Rnase not-selected PC1', main = "Ctrl not-selected PC1 vs Rnase not-selected PC1");abline(0,1,col='red')
plot(ctrl_ns_1,rnase_ns_2,pch=20,col='blue', xlab='Ctrl not-selected PC1',ylab='Rnase not-selected PC2', main = "Ctrl not-selected PC1 vs Rnase not-selected PC2");abline(0,1,col='red')
plot(ctrl_ns_1,rnase_ns_3,pch=20,col='blue', xlab='Ctrl not-selected PC1',ylab='Rnase not-selected PC3', main = "Ctrl not-selected PC1 vs Rnase not-selected PC3");abline(0,1,col='red')

plot(ctrl_ns_2,rnase_ns_1,pch=20,col='blue', xlab='Ctrl not-selected PC2',ylab='Rnase not-selected PC1', main = "Ctrl not-selected PC2 vs Rnase not-selected PC1");abline(0,1,col='red')
plot(ctrl_ns_2,rnase_ns_2,pch=20,col='blue', xlab='Ctrl not-selected PC2',ylab='Rnase not-selected PC2', main = "Ctrl not-selected PC2 vs Rnase not-selected PC2");abline(0,1,col='red')
plot(ctrl_ns_2,rnase_ns_3,pch=20,col='blue', xlab='Ctrl not-selected PC2',ylab='Rnase not-selected PC3', main = "Ctrl not-selected PC2 vs Rnase not-selected PC3");abline(0,1,col='red')

plot(ctrl_ns_3,rnase_ns_1,pch=20,col='blue', xlab='Ctrl not-selected PC3',ylab='Rnase not-selected PC1', main = "Ctrl not-selected PC3 vs Rnase not-selected PC1");abline(0,1,col='red')
plot(ctrl_ns_3,rnase_ns_2,pch=20,col='blue', xlab='Ctrl not-selected PC3',ylab='Rnase not-selected PC2', main = "Ctrl not-selected PC3 vs Rnase not-selected PC2");abline(0,1,col='red')
plot(ctrl_ns_3,rnase_ns_3,pch=20,col='blue', xlab='Ctrl not-selected PC3',ylab='Rnase not-selected PC3', main = "Ctrl not-selected PC3 vs Rnase not-selected PC3");abline(0,1,col='red')


#Defines a target variable, so what should be predicted by the regression analysis
target_not_selected <- ctrl_selected$global_maximum


#Builds matrix for regression analysis from target variable with two PCA components
df_regression_not_selected_11 <- cbind(target = target_not_selected ,
                      ctrl_ns_1, rnase_ns_1)
df_regression_not_selected_12 <- cbind(target = target_not_selected ,
                       ctrl_ns_1, rnase_ns_2)
df_regression_not_selected_13 <- cbind(target = target_not_selected ,
                       ctrl_ns_1, rnase_ns_3)

df_regression_not_selected_21 <- cbind(target = target_not_selected ,
                       ctrl_ns_2, rnase_ns_1)
df_regression_not_selected_22 <- cbind(target =target_not_selected,
                       ctrl_ns_2, rnase_ns_2)
df_regression_not_selected_23 <- cbind(target = target_not_selected ,
                       ctrl_ns_2, rnase_ns_3)

df_regression_not_selected_31 <- cbind(target = target_not_selected ,
                       ctrl_ns_3, rnase_ns_1)
df_regression_not_selected_32 <- cbind(target =target_not_selected ,
                       ctrl_ns_3, rnase_ns_2)
df_regression_not_selected_33 <- cbind(target = target_not_selected ,
                       ctrl_ns_3, rnase_ns_3)


#Make matrix a data frame
df_regression_not_selected_11 <- as.data.frame(df_regression_not_selected_11)
df_regression_not_selected_12 <- as.data.frame(df_regression_not_selected_12)
df_regression_not_selected_13 <- as.data.frame(df_regression_not_selected_13)

df_regression_not_selected_21 <- as.data.frame(df_regression_not_selected_21)
df_regression_not_selected_22 <- as.data.frame(df_regression_not_selected_22)
df_regression_not_selected_23 <- as.data.frame(df_regression_not_selected_23)

df_regression_not_selected_31 <- as.data.frame(df_regression_not_selected_31)
df_regression_not_selected_32 <- as.data.frame(df_regression_not_selected_32)
df_regression_not_selected_33 <- as.data.frame(df_regression_not_selected_33)

#Multiple linear regression analysis
model_not_selected_pc1_1<- lm(target ~ ctrl_ns_1 + rnase_ns_1, data = df_regression_not_selected_11)
model_not_selected_pc1_2<- lm(target ~ctrl_ns_1 + rnase_ns_2, data = df_regression_not_selected_12)
model_not_selected_pc1_3<- lm(target ~ ctrl_ns_1 + rnase_ns_3, data = df_regression_not_selected_13)

model_not_selected_pc2_1<- lm(target ~ ctrl_ns_2 + rnase_ns_1, data = df_regression_not_selected_21)
model_not_selected_pc2_2<- lm(target ~ ctrl_ns_2 + rnase_ns_2, data = df_regression_not_selected_22)
model_not_selected_pc2_3<- lm(target ~ ctrl_ns_2 + rnase_ns_3, data = df_regression_not_selected_23)

model_not_selected_pc3_1<- lm(target ~ ctrl_ns_3 + rnase_ns_1, data = df_regression_not_selected_31)
model_not_selected_pc3_2<- lm(target ~ ctrl_ns_3 + rnase_ns_2, data = df_regression_not_selected_32)
model_not_selected_pc3_3<- lm(target ~ ctrl_ns_3 + rnase_ns_3, data = df_regression_not_selected_33)

#Show results/summary
summary(model_not_selected_pc1_1)
summary(model_not_selected_pc1_2)
summary(model_not_selected_pc1_3)

summary(model_not_selected_pc2_1)
summary(model_not_selected_pc2_2)
summary(model_not_selected_pc2_3)

summary(model_not_selected_pc3_1)
summary(model_not_selected_pc3_2)
summary(model_not_selected_pc3_3)


```
**************************************************************************************************************

Conclusion: 
The regression analyses for the selected proteins describe the target variable (ctrl_selected$global_maximum) well.
The regression analyses for the not-selected proteins describe its own target variable (ctrl_not_selected$global_maximum) also very well, in comparison to the selected proteins sometimes even better, as there are more proteins used in the model. However, the analysis for the not-selected proteins shows a bad fit for the selected target variable (ctrl_selected$global_maximum). This proves, that there is a difference between the selected and not-selected proteins, and therefore, that the selection criteria worked.

**************************************************************************************************************
**************************************************************************************************************
