**************************************************************************************************************

Proteome-wide screen for RNA-dependent proteins in non-synchronized HeLa cells
Molecular Biotechnology - Data science project summer term 2025
Julian Baureis, Julia Ferdin, Benjamin Nicklas, Luisa Wintel
Supervisors: Maïwen Caudron-Herger and Michela Pozzi 

**************************************************************************************************************

1.  Load dataset
2.  Data cleanup
3.  Normalization
4.  Identification of local maxima as fit parameters
5.  Identification of shoulders
6.  Total count of maxima (peaks and shoulders) per protein
7.  Identification of proteins with different maxima amount in ctrl vs rnase
8.  Add center of mass values
9.  Correlation functions and plotting function 
10. First criterion for data set purification
11. Second criterion for data set purification
12. Combining purified data sets
13. t-test
14. Further visualization/interpretation of purified data
15. Evaluation of selection criteria
16. Principle Component Analysis
17. k-means clustering
18. Linear regression analysis

**************************************************************************************************************
1. Load dataset and inspect row/column names 
  by Julia Ferdin
**************************************************************************************************************

```{r}
#Reads table by indicating path to directory where the dataset is stored, and stores it to variable NS_Table (NS for Non-synchronized HeLa-cells)

NS_Table <- read.table("Data/Excel table of original data, copy but dont open.csv", header=TRUE, row.names=1, sep = ";")
```

```{r}
#The first 12 titles of the table (NS_Table) rows/columns are read out

#Row names are protein names
head(rownames(NS_Table),12)

#Columns indicate the respective fractions from 1 to 25, and their replicates
head(colnames(NS_Table),12)
```

**************************************************************************************************************
2. Data cleanup - Rearrange and reorder the columns to their treatment, replicate and fraction
  by Julia Ferdin
**************************************************************************************************************

Define sample by using vectors for different conditions (treatment, replicates, fractions):
  levels_CR → was sample treated with CTRL or RNASE
  levels_fraction → labels the column with the replicate number (1–3) for either CTRL or RNASE
  fraction_names → creates the variables fraction1 to fraction25 to assign the replicates to each fraction

```{r}
#A vector consists of 2 variables (CTRL, RNASE) --> c("CTRL", "RNASE")
#The factor() function encodes a vector as a factor. The 2 variables CTRL and RNASE are ordered into 2 different levels (characters)
#rep(vector,75) repeats the factor() function 75 times, because we have 150 columns (75 times CTRL and RNASE)
#The factor is defined as the variable 'treatment'

levels_CR <- factor(rep(c("CTRL", "RNASE"),75))
```

```{r}
#Every sample of every fraction gets its own level to disconnect them from each other -> 6 levels per fraction because we have 3 CTRLs and 3 RNASEs per fraction

levels_fraction <- factor(rep(c("Ctrl_Rep1","RNase_Rep1","Ctrl_Rep2","RNase_Rep2","Ctrl_Rep3","RNase_Rep3"),25))
```

```{r}
# Creation of a matrix with 6 rows and 25 columns. The matrix is filled by row from fraction1 to fraction25 so every column has one single fraction.
# sep="" compares the word fraction with the numbers 1 to 25 without a blank space.
# paste("fraction",1:25,sep="") creates a vector with the strings fraction1 to fraction25
# as.vector changes the created matrix into a vector with 150 elements sorted from 6 times fraction1 to 6 times fraction25

fraction_names <- as.vector(matrix(rep(paste("fraction",1:25,sep=""),6), nrow = 6, ncol=25, byrow = TRUE))
```

**************************************************************************************************************

```{r}
# The number of rows are stored in a variable
n_row <- nrow(NS_Table)

# The row names (protein names) are stored in a variable
row_names <- rownames(NS_Table)
```

```{r}
# Creation of a data frame with levels_CR, levels_fraction and fraction_names. This assigns every replicate of the factions (levels_fraction) to their fraction (fraction_names) and their kind of treatment, CRTL or RNASE (levels_CR).

colmns_sorted <- data.frame(row.names = colnames(NS_Table), levels_CR = levels_CR, levels_fraction = levels_fraction, fraction_names = fraction_names)

#Check for missing values, there are none 
anyNA(NS_Table)
```

**************************************************************************************************************
3. Normalization step between the replicates in each fraction and for each treatment using the mean value method
  by Benjamin Nicklas influenced by ChatGPT
**************************************************************************************************************

```{r}
# lapply executes for every with paste created string (the fractions) a function fx
# colmns_sorted$fraction == fx: checks which columns are part of the fractions fx
# NS_Table[, ...] filters just these columns and assigns them to the list "fraction.tables"
# names(fraction.tables): the list "fraction.tables" gets names for its segments and assigns them to the variable selected_proteins 

fraction.tables <- lapply(paste("fraction", 1:25, sep = ""), function(fx) {NS_Table[, colmns_sorted$fraction_names == fx]})

names(fraction.tables) <- paste("fraction", 1:25, sep = "")

selected_proteins <- names(fraction.tables)
```

```{r}
# List with just CTRL/RNASE columns for each fraction
# subset filters just the fractions that fulfill the conditions: fraction_names == fx --> fraction name is part of the function fx, levels_CR == "CTRL" --> protein was treated as a CTRL
# rownames() takes the rownames of the filtered fractions and assigns them to the variable col
# NS_Table[, cols, drop = FALSE] the names that are part of NS_Table are filtered out and drop = FALSE makes sure that fraction.tables.CTRL will be a dataframe

# List with only CTRL columns for each fraction
fraction.tables.CTRL <- lapply(selected_proteins, function(fx) {
  cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "CTRL")) 
  NS_Table[, cols, drop = FALSE]
  })

# List with only CTRL rows for each fraction
fraction.tables.RNASE <- lapply(selected_proteins, function(fx) {
  cols <- rownames(subset(colmns_sorted, fraction_names == fx & levels_CR == "RNASE"))
  NS_Table[, cols, drop = FALSE]})

names(fraction.tables.CTRL) <- selected_proteins
names(fraction.tables.RNASE) <- selected_proteins
```

**************************************************************************************************************

```{r}
# sapply(df, mean) calculates the mean of every column of the dataframe fraction.tables.CTRL
# For every condition (e.g. fraction 1, Ctrl, Rep 1) the mean over the proteins is taken which is a single value per condition

avg.tables.CTRL <- lapply(fraction.tables.CTRL, function(df) {
  sapply(df, mean)
})

avg.tables.RNASE <- lapply(fraction.tables.RNASE, function(df) {
  sapply(df, mean)
})
```

```{r}
# Determine normalization factor for each condition (i.e. sample), as the mean of the 2 most similar replicates.
# Create a function norm_fact for this step:

norm_fact <- function(x) {
				if( (abs(x[1]-x[2])<abs(x[1]-x[3])) && (abs(x[1]-x[2])<abs(x[2]-x[3])) ) 
					{mean(c(x[1],x[2]))} else if( (abs(x[1]-x[3])<abs(x[1]-x[2])) && (abs(x[1]-x[3])<abs(x[2]-x[3])) )
												  {mean(c(x[1],x[3]))} else {mean(c(x[2],x[3]))} 
}
```

```{r}
# Normalization of the mean vectors
# norm_factor <- norm_fact(vec): The function norm_fact is applied to every vector in the list avg.tables.CTRL (length 3)
# norm_factor / vec: Results in new vector of length 3 and represents a correcting factor for the single replicates in order to align the amount of protein of the replicates

norm_mean_frxn_CTRL <- lapply(avg.tables.CTRL, function(vec) {
  norm_factor <- norm_fact(vec)
  norm_factor / vec 
})

norm_mean_frxn_RNASE <- lapply(avg.tables.RNASE, function(vec) {
  norm_factor <- norm_fact(vec)
  norm_factor / vec 
})
```

```{r}
# Correction factor for the overall protein quantity
# Normalization vectors for replicates 1-3
# function(x) x[1]: extracts the first element of each vector in the list
# norm.ctrl1 is a numeric vector consisting of the 1st element of each normalized CTRL vector

norm.ctrl1 <- sapply(norm_mean_frxn_CTRL, function(x) x[1])
norm.ctrl2 <- sapply(norm_mean_frxn_CTRL, function(x) x[2])
norm.ctrl3 <- sapply(norm_mean_frxn_CTRL, function(x) x[3])

norm.rnase1 <- sapply(norm_mean_frxn_RNASE, function(x) x[1])
norm.rnase2 <- sapply(norm_mean_frxn_RNASE, function(x) x[2])
norm.rnase3 <- sapply(norm_mean_frxn_RNASE, function(x) x[3])
```

```{r}
# Defines logical vectors (TRUE, FALSE), which are later used to create subtables - separately for treatment (Ctrl vs. RNase) and replica (Rep1, Rep2, Rep3)
# colmns_sorted$levels_fraction =="Ctrl_Rep1": checks at which position exactly in the columns_sorted Ctrl_Rep1 can be found (marks it with TRUE)

data.ctrl1 <- colmns_sorted$levels_fraction =="Ctrl_Rep1"
data.ctrl2 <- colmns_sorted$levels_fraction =="Ctrl_Rep2"
data.ctrl3 <- colmns_sorted$levels_fraction =="Ctrl_Rep3"
data.rnase1 <- colmns_sorted$levels_fraction =="RNase_Rep1"
data.rnase2 <- colmns_sorted$levels_fraction =="RNase_Rep2"
data.rnase3 <- colmns_sorted$levels_fraction =="RNase_Rep3"
```

```{r}
# Normalization step, fraction-wise
# takes specific columns from the protein intensity table and scales each row according to a normalization factor to compensate for measurement differences between replicates
# mask: A logical vector (TRUE/FALSE) that specifies which columns of NS_Table are selected
# selected <- NS_Table[, mask]: from NS_Table only the columns marked with TRUE in mask are selected
# (`*`, selected, norm_vec, SIMPLIFY = FALSE): Multiplication of colums of selected and the vector norm_vec saved as a list

normalize_group <- function(mask, norm_vec) {
  selected <- NS_Table[, mask]                  
  as.data.frame(mapply(`*`, selected, norm_vec, SIMPLIFY = FALSE))
}

# logical vectors (data.ctrl1) and vectors with normalization-factors (norm.ctrl1) form groups
# normalize_group(): multiplication of the vectors with their normalization-factor

table.ctrl1  <- normalize_group(data.ctrl1,  norm.ctrl1)
table.ctrl2  <- normalize_group(data.ctrl2,  norm.ctrl2)
table.ctrl3  <- normalize_group(data.ctrl3,  norm.ctrl3)
table.rnase1 <- normalize_group(data.rnase1, norm.rnase1)
table.rnase2 <- normalize_group(data.rnase2, norm.rnase2)
table.rnase3 <- normalize_group(data.rnase3, norm.rnase3)
```

```{r}
# Get the proper rownames for the tables

rownames(table.ctrl1) <- row_names
rownames(table.ctrl2) <- row_names
rownames(table.ctrl3) <- row_names
rownames(table.rnase1) <- row_names
rownames(table.rnase2) <- row_names
rownames(table.rnase3) <- row_names
```

```{r}
# Apply a sliding window/moving average of 3 points to the data to reduce noise in the data and obtain smoother curves (not possible for fraction 1 and 25)

smooth_table <- function(tbl) {
  data.frame(tbl[1], (tbl[1:23] + tbl[2:24] + tbl[3:25]) / 3, tbl[25])
}

table.ctrl1.SW <- smooth_table(table.ctrl1)
table.ctrl2.SW <- smooth_table(table.ctrl2)
table.ctrl3.SW <- smooth_table(table.ctrl3)
table.rnase1.SW <- smooth_table(table.rnase1)
table.rnase2.SW <- smooth_table(table.rnase2)
table.rnase3.SW <- smooth_table(table.rnase3)
```

```{r}
# Get the proper rownames for the tables

colnames(table.ctrl1.SW) <- colnames(table.ctrl1)
colnames(table.ctrl2.SW) <- colnames(table.ctrl2)
colnames(table.ctrl3.SW) <- colnames(table.ctrl3)
colnames(table.rnase1.SW) <- colnames(table.rnase1)
colnames(table.rnase2.SW) <- colnames(table.rnase2)
colnames(table.rnase3.SW) <- colnames(table.rnase3)
```

```{r}
# Normalization of the fractions: Sum of all fraction values equals 100 (%)

normalize_table <- function(tbl) {
  tbl * 100 / rowSums(tbl)
}


tables.ctrl <- list(
  ctrl1 = table.ctrl1.SW,
  ctrl2 = table.ctrl2.SW,
  ctrl3 = table.ctrl3.SW)

tables.rnase <- list(
  rnase1 = table.rnase1.SW,
  rnase2 = table.rnase2.SW,
  rnase3 = table.rnase3.SW)

# Calculation of the percentages of the fractions in the normalized tables (table.ctrl1.SW)

norm_tables.ctrl <- lapply(tables.ctrl, normalize_table)
norm_tables.rnase <- lapply(tables.rnase, normalize_table)
```

```{r}
# Function for replacing NA and NaN with 0

clean_table <- function(tbl) {
  tbl <- rapply(tbl, function(x) ifelse(is.na(x), 0, x), how = "replace")
  tbl <- rapply(tbl, function(x) ifelse(is.nan(x), 0, x), how = "replace")
  return(tbl)
}

# Getting the clean table

tables.norm.ctrl <- lapply(norm_tables.ctrl, clean_table)
tables.norm.rnase <- lapply(norm_tables.rnase, clean_table)
```

```{r}
my.list.ctrl.norm <- list(table.ctrl1.SW, table.ctrl2.SW, table.ctrl3.SW)
my.list.rnase.norm <- list(table.rnase1.SW, table.rnase2.SW, table.rnase3.SW)

# Addition of all data-frames in the list my.list.ctrl.norm (element-wise) and Division of the Sum with 3 to get the mean of all 3 replicates

ctrl_norm_mean <- Reduce("+", my.list.ctrl.norm)/length(my.list.ctrl.norm)
rnase_norm_mean <- Reduce("+", my.list.rnase.norm)/length(my.list.rnase.norm)
```

```{r}
# Change names of the columns: from "fraction1" to "fraction25"

col_fractions <- paste("fraction",1:25,sep="")
colnames(ctrl_norm_mean) <- col_fractions
colnames(rnase_norm_mean) <- col_fractions
```

```{r}
# second normalization of the fractions (mean destroyed first normalization): Sum of all fraction values equals 100 (%)

ctrl_norm_mean <- ctrl_norm_mean*100/rowSums(ctrl_norm_mean)
rnase_norm_mean <- rnase_norm_mean*100/rowSums(rnase_norm_mean)

```

```{r}
# Function for replacing NA and NaN with 0

replace_na_nan <- function(x) rapply(x, function(y) ifelse(is.na(y) | is.nan(y), 0, y), how = "replace")

ctrl_norm_mean <- replace_na_nan(ctrl_norm_mean)
rnase_norm_mean <- replace_na_nan(rnase_norm_mean)
```

```{r}
# If a curve is 0 in all fractions, the other fraction is also set to 0 and is excluded from the analysis

ctrl_norm_mean[rowSums(rnase_norm_mean[1:25])==0,] <- 0
rnase_norm_mean[rowSums(ctrl_norm_mean[1:25])==0,] <- 0
```

```{r}
par(mfrow = c(1, 2)) 

row_data1 <- as.numeric(ctrl_norm_mean["SPTN1_HUMAN", 1:25])
row_data2 <- as.numeric(rnase_norm_mean["SPTN1_HUMAN", 1:25])

# Plot
plot(row_data1,
     type = "l",        
     main = "Plot for SPTN1_HUMAN",
     xlab = "Fractions",
     ylab = "Values",
     col = "midnightblue",
     lwd = 2)
     
lines(row_data2,
      type = "l",
      col = "firebrick3",
      lwd = 2)

row_data3 <- as.numeric(ctrl_norm_mean["DDX21_HUMAN", 1:25])
row_data4 <- as.numeric(rnase_norm_mean["DDX21_HUMAN", 1:25])

# Plot
plot(row_data3,
     type = "l",        
     main = "Plot for DDX21_HUMAN",
     xlab = "Fractions",
     ylab = "Values",
     col = "midnightblue",
     lwd = 2)
     
lines(row_data4,
      type = "l",
      col = "firebrick3",
      lwd = 2)

par(mfrow = c(1, 1))
```

**************************************************************************************************************
4. Find Local Maxima
  by Julian Baureis & Luisa Wintel influenced by ChatGPT & Ms_Statistical_Alnalysis (Maïwen Caudron-Herger)
**************************************************************************************************************

- Local maxima are peaks, that are higher than the two surrounding values 
- In order to get rid of the noise, only values above 2 are considered.
- Find shoulders that were not discovered previously.

```{r}
# Create backup "ctrl/rnase_norm_mean_original" 
# -> allows to go back to the unmodified data later if needed
ctrl_norm_mean_original = ctrl_norm_mean
rnase_norm_mean_original = rnase_norm_mean
```

Define a Function to Find Local Maxima

```{r}
# Function "find_local_maxima" finds local maxima (peaks) in a numeric vector (of protein intensities) 
# A peak is a protein intensity that is higher than the surrounding values within a certain "window" (= amount of fractions on each side).
# Bigger window => more stringent peak finding procedure 

find_local_maxima <- function(x, window = 2) {
  n <- length(x)         # 25 fractions
  peaks <- c()           # Store the indices of detected peaks

  for (i in 1:n) {
    # Define left and right boundaries of the window around the current point (fraction)
    left <- max(1, i - window)
    right <- min(n, i + window)
    # Extract neighboring values (excluding the current point itself)
    # x[2:6][-3] removes third vector entry -> forth protein intensity x[4]
    neighbors <- x[left:right][-which((left:right) == i)]   

    # Check if the current value is higher than all its neighbors
    if (all(neighbors <= x[i])) {
      peaks <- c(peaks, i)     # Save the index if it qualifies as a peak
    }
  }
  return(peaks) # all fractions with maximum for every protein 
}
```

```{r}
# Apply the peak detection function to each protein (-> row in ctrl_norm_mean)
# Only peaks above a threshold (> 2) are kept to filter out background noise
# New column: "local_maxima" (column 26)

ctrl_norm_mean$local_maxima <- apply(ctrl_norm_mean, 1, function(x) {   
															   peak_indices <- find_local_maxima(x)
															   filtered <- peak_indices[x[peak_indices] > 2]  # Only keep those fractions (in filtered) that have protein intensities >2
															   local_maxima <- unlist(filtered)
															   local_maxima
															   })
															   
rnase_norm_mean$local_maxima <- apply(rnase_norm_mean, 1, function(x) {
															   peak_indices <- find_local_maxima(x)
															   filtered <- peak_indices[x[peak_indices] > 2] 
															   local_maxima <- unlist(filtered)
															   local_maxima
															   })
```

Find Main Maximum for each Protein

```{r}
# Out of the local maxima, extract the global (greatest) maximum, and save it in a new column "global_maximum" (column 27)

ctrl_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
  x <- as.numeric(ctrl_norm_mean[i, 1:25])
  peaks <- ctrl_norm_mean$local_maxima[[i]]

  if (length(peaks) == 0) {
    return(NA)
  } else {
    peak_values <- x[peaks]
    return(peaks[which.max(peak_values)])    # Return the position of the highest-intensity peak
  }
})

rnase_norm_mean$global_maximum <- sapply(1:nrow(ctrl_norm_mean), function(i) {
  x <- as.numeric(rnase_norm_mean[i, 1:25])
  peaks <- rnase_norm_mean$local_maxima[[i]]

  if (length(peaks) == 0) {
    return(NA)
  } else {
    peak_values <- x[peaks]
    return(peaks[which.max(peak_values)])
  }
})
```


****************************************************************************************************************
5. Identify Shoulders
  by Julian Baureis & Luisa Wintel
****************************************************************************************************************

- Shoulders are regions that are not recognized as peaks, even though they have a high signal intensity.
- Create Binary Data Frames Indicating Signal > 2%

```{r}
# Identify the RNAse fractions with signal intensity > 2%. 
# Create a new data frame containing 0 (= this fraction value was ≤2% ) and 1 (= this fraction value was >2%.), as well as the intensity maxima.
# The two new data frames are created, rnase_3 and ctrl_3, as copies of the previously calculated, normalized mean tables (*_norm_mean).

rnase_3 <- rnase_norm_mean
# Compare each value in columns 1 to 25 (the fractions) of the rnase_norm_mean dataframe with the threshold of 2%.
# Convert TRUE to 1 and FALSE to 0. 
rnase_3[1:25] <- (rnase_norm_mean[1:25] > 2)*1

# Identify the CTRL fractions with signal intensity > 2%. 
# Create a new data frames containing 0 / 1, as well as the intensity maxima.
ctrl_3 <- ctrl_norm_mean
ctrl_3[1:25] <- (ctrl_norm_mean[1:25] > 2)*1
```

Mask Regions Around Detected Peaks to Exclude Them from Shoulder Search

```{r}
# Remove and exclude 3 fractions left and right of each peak (7 in total) from the shoulder search.

th_max_reg_simple <- function(x) {
  peaks <- as.numeric(unlist(x$local_maxima)) 
  mask <- rep(1, 25)
  
  for (peak in peaks) { # peak = current peak value, peaks = detected maxima (column 26)
    if (peak > 0) { 
      left <- max(1, peak - 3)
      right <- min(25, peak + 3) 
      mask[left:right] <- 0 # For each peak, the range from peak–3 to peak+3 is calculated and set to 0 in the mask
      
    }
  }

  x_values <- as.numeric(x[1:25])  
  x_values <- x_values * mask # Fractions with mask = 1 are retained. Fractions with mask = 0 are set to 0.
  return(x_values)
}

# Apply the function row by row to the entire rnase_3 or ctrl_3 Dataframe.
rnase_3[1:25] <- t(apply(rnase_3, 1, th_max_reg_simple))
ctrl_3[1:25]  <- t(apply(ctrl_3, 1, th_max_reg_simple))
```

Identify Shoulder Regions: Consecutive Fractions > 2% Without Peaks

```{r}
# Detect "shoulder regions"
# Define a function that identifies signal regions where there are at least 4 consecutive fractions with an intensity above 2% using the data frames rnase_3 and ctrl_3.
# select the middle of this region as shoulder

peaks_regions = function(x) {
  rle_result = rle(as.numeric(x[1:25])) # rle() finds all consecutive equal values -> $lengths and $values
  
  #Find positions of all blocks consisting of 1s with length ≥4. These blocks are considered “shoulder regions”.
  peak_blocks = which(rle_result$values == 1 & rle_result$lengths >= 4)
  
  #If there are no such blocks of length >4, return an empty vector
  if (length(peak_blocks) == 0) {
    return(numeric(0))
  }
  
  #Calculate estimate middle for the peak blocks
  peak_positions = numeric(length(peak_blocks))
  
  for(i in seq_along(peak_blocks)) {
    
    #Position of the end of the respective block 
    end_of_block = sum(rle_result$lengths[1:peak_blocks[i]])
    
    #Calculate half length of the block
    half_length = floor(rle_result$lengths[peak_blocks[i]] /2)
    
    #Middle position of the shoulder 
    peak_positions[i] = end_of_block - half_length
  }
  
  return(peak_positions)
}
```

```{r}
# Calculate the positions of the "shoulders" for each row for the data.frames ctrl/rnase_3 and ctrl/rnase_norm_mean
# New column: "shoulders" (column 28)

rnase_3$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_3$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )


rnase_norm_mean$shoulders <- apply(rnase_3, 1, function(x) { peaks_regions(x) } )
ctrl_norm_mean$shoulders <- apply(ctrl_3, 1, function(x) { peaks_regions(x) } )
```

Combine Peak and Shoulder Positions for Each Protein

```{r}
# Calculate the total of all relevant signal maxima (real peaks and shoulders) for each protein row in the data.frames
# New column: "combined_max_ctrl" and "combined_max_rnase" (column 29) respectively
						   						
rnase_3$combined_max_rnase <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima)) # ls_max = numerical vector with the peak positions of this protein
												 ls_shoulder <- as.numeric(unlist(x$shoulders))
												 
												 combined_max_rnase <- c(ls_max, ls_shoulder) # Combine to common vector.
												 combined_max_rnase <- unlist(combined_max_rnase)
												 combined_max_rnase <- combined_max_rnase[combined_max_rnase!=0] # Remove all 0 entries from the result vector, as these do not represent real signals.
												 combined_max_rnase <- sort(combined_max_rnase, decreasing = FALSE) # Sort all peak and shoulder positions in ascending order (1 → 25)
												 if (length(combined_max_rnase) == 0) {0} else {combined_max_rnase} # If there are no peaks or shoulders, 0 (as a placeholder) is stored.
												 })

ctrl_3$combined_max_ctrl <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 ls_shoulder <- as.numeric(unlist(x$shoulders))
												 
												 combined_max_ctrl <- c(ls_max, ls_shoulder)
												 combined_max_ctrl <- unlist(combined_max_ctrl)
												 combined_max_ctrl <- combined_max_ctrl[combined_max_ctrl!=0]
												 combined_max_ctrl <- sort(combined_max_ctrl, decreasing = FALSE)
												 if (length(combined_max_ctrl) == 0) {0} else {combined_max_ctrl} 
												 })


# Add new column of the combined maxima to ctrl/rnase_nrom_mean, to continue working with it

ctrl_norm_mean$combined_max_ctrl = ctrl_3[, "combined_max_ctrl"]
rnase_norm_mean$combined_max_rnase = rnase_3[, "combined_max_rnase"]
```

***********************************************************************************************************
6. Count Total Number of Maxima (Peaks + Shoulders) per Protein
   by Julian Baureis & Luisa Wintel influenced by ChatGPT 
***********************************************************************************************************

```{r}
# Determine the number of combined maxima (peaks + shoulders) per protein
# New column: "n_max_comb" (column 30)

rnase_3$n_max_comb <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$combined_max_rnase))
												 n = length(ls_max) # determines how many peaks (maxima and shoulders) the protein has
												 if (sum(ls_max) == 0) {0} else {n}  
												 })
												 
ctrl_3$n_max_comb <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$combined_max_ctrl))
												 n = length(ls_max)
												 if (sum(ls_max) == 0) {0} else {n} 
												 })


# Same for ctrl/rnase_norm_mean

ctrl_norm_mean$n_max_comb = ctrl_3[, "n_max_comb"]
rnase_norm_mean$n_max_comb = rnase_3[, "n_max_comb"] 
```


***********************************************************************************************************
7. Identification of proteins with a different number of peaks in CTRL vs. RNASE
   by Julian Baureis & Luisa Wintel influenced by ChatGPT 
***********************************************************************************************************

```{r}
# Determine the number of only peak maxima ("local_maxima") per protein
# New column: "n_local_maxima" (column 31)

rnase_3$n_local_maxima <- apply(rnase_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 n = length(ls_max) 
												 if (sum(ls_max) == 0) {0} else {n}  
												 })
												 
ctrl_3$n_local_maxima <- apply(ctrl_3, 1, function(x) {
												 ls_max <- as.numeric(unlist(x$local_maxima))
												 n = length(ls_max)
												 if (sum(ls_max) == 0) {0} else {n} 
												 })

# Same for ctrl/rnase_norm_mean

ctrl_norm_mean$n_local_maxima = ctrl_3[, "n_local_maxima"]
rnase_norm_mean$n_local_maxima = rnase_3[, "n_local_maxima"]  
```


***********************************************************************************************************
8. Add COM (center of mass) values 
   by Julian Baureis & Luisa Wintel influenced by ChatGPT 
***********************************************************************************************************

```{r}
# Calculate the center of mass for each row 
# x is the vector with the intensities of a protein across all 25 fractions for which the COM is currently being calculated
# * means element-wise multiplication

ctrl_norm_mean$COM <- apply(ctrl_norm_mean[, 1:25], 1, function(x) {
  sum((1:25) * x, na.rm = TRUE) / sum(x, na.rm = TRUE)
})

rnase_norm_mean$COM <- apply(rnase_norm_mean[, 1:25], 1, function(x) {
  sum((1:25) * x, na.rm = TRUE) / sum(x, na.rm = TRUE)
})
```


***********************************************************************************************************
Code in the following parts (rows 700 - 1265) by Julian Baureis, Codewriting was assisted by ChatGPT 
***********************************************************************************************************

***********************************************************************************************************
9. Useful functions, that will be used in the further parts 
(by Julian Baureis)
***********************************************************************************************************

Correlation function 
Inputs: - df1: data.frame 1
        - df2: data.frame 2
Output: - List with 1. $correlations: the single correaltion values, 2. $mean_abs_correlation: the mean value of the abolute correaltion values
```{r}
# Function to calculate the row-wise correlation between the rows of two data.frames

correlations <- function(df1, df2, methode = "pearson") {
  
  # Check whether both data frames have the same dimensions
  if (!all(dim(df1) == dim(df2))) {
    stop("Both data frames need to have same dimension")
  }

  # Number of rows
  n <- nrow(df1)

  # Vector for storing the correlation values
  correlations <- numeric(n)

  # Loop over all rows
  for (i in 1:n) {
    v1 <- as.numeric(df1[i, 1:25])
    v2 <- as.numeric(df2[i, 1:25])

    # Calculate correlation only if both vectors have variance
    if (sd(v1, na.rm = TRUE) != 0 && sd(v2, na.rm = TRUE) != 0) {
      correlations[i] <- cor(v1, v2, method = methode, use = "complete.obs")
    } else {
      correlations[i] <- NA
    }
  }

  abs_correlations = abs(correlations)
  
  mean_abs_correlation = mean(abs_correlations, na.rm = TRUE)
  
  return(list(
    correlations = correlations, mean_abs_correlation = mean_abs_correlation
  ))
}
```


Plotting function
Inputs: - cor_vector: vector with the correlation values 
        - ctrl_data & rnase_data: the data.frames, that were used, to calculate the row-wise correlations
        - n: Number of example plots to be plotted
        - cor_threshold: threshold of correlation values, to only get certain entries of the cor_vector
        - direction: defines the conditions by which the cor_vector is compared with the threshold
Output: - n plots for the desired conditions
```{r}
# Function to plot a defined amount of protein curves (ctrl & rnase), based on a selected threshold and condition (= direction)
header_plotting <- function(cor_vector,
                             ctrl_data,
                             rnase_data,
                             n = 5,
                             cor_threshold = 0.6,
                             direction = "abs_lt") {
  # selecting the indices based on the direction 
  selected <- switch(direction,
                     lt      = which(cor_vector < cor_threshold),
                     gt      = which(cor_vector > cor_threshold),
                     abs_lt  = which(abs(cor_vector) < cor_threshold),
                     abs_gt  = which(abs(cor_vector) > cor_threshold),
                     stop("wrong value for direction used")
  )
  
  # Just use n plots
  selected_indices = head(selected, n)
  
  # Plotting
  for (i in selected_indices) {
    cs = as.numeric(ctrl_data[i, 1:25])
    rs = as.numeric(rnase_data[i, 1:25])
    corr_value = cor_vector[i]
    
    plot(
      cs,
      type = "l",
      main = paste("Protein at index", i, "/ Correlation: ", round(corr_value, 3), "/ name: ", rownames(ctrl_data)[i]),
      xlab = "Fractions",
      ylab = "Values",
      col = "midnightblue",
      lwd = 2,
      ylim = range(c(cs, rs), na.rm = TRUE)
    )
    
    lines(
      rs,
      type = "l",
      col = "firebrick",
      lwd = 2
    )
  }
}
```


***********************************************************************************************************
10. First Criterion for data set purification:
The center of mass for a RNA-dependent protein is shifted by at least two fractions
(by Julian Baureis)
***********************************************************************************************************

Create new data.frames out of ctrl/rnase_norm_mean to select those proteins, that exhibit a shift in their overall center of mass
```{r}
# Calculate the absolute difference of the positions of the COM values between ctrl and rnase 
diff_COM <- abs(ctrl_norm_mean$COM - rnase_norm_mean$COM)

# Indices of proteins with deviation ≥ 2 fractions
deviating_COM <- which(diff_COM >= 2)

# Apply on the data.frames
ctrl_COM_shift = ctrl_norm_mean[deviating_COM, ]
rnase_COM_shift = rnase_norm_mean[deviating_COM, ]

# Create the complementary data.frame that contains all proteins whose COM do not shift by at least 2 fractions
ctrl_no_COM_shift = ctrl_norm_mean[!rownames(ctrl_norm_mean) %in% rownames(ctrl_COM_shift), ]
rnase_no_COM_shift = rnase_norm_mean[!rownames(rnase_norm_mean) %in% rownames(rnase_COM_shift), ]
```


***********************************************************************************************************
Hypothesis: Correlation of ctrl_COM_shift with rnase_COM_shift is lower than that of ctrl_no_COM_shift with rnase_no_COM_shift
***********************************************************************************************************

Correlation can be seen as a measure for the similarity between the distribution of two curves. In case of low correlation, the two curves are less similar compared to high correlation. 

Define the variables for the correlation values, use the correlation function 
```{r}
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose COM is shifted by at least 2 fractions
COM_shifter = correlations(ctrl_COM_shift, rnase_COM_shift)
COM_shifter$mean_abs_correlation

# Mean of the correlation values (ctrl vs. rnase) for those proteins whose COM is not shifted by at least 2 fractions
COM_no_shifter = correlations(ctrl_no_COM_shift, rnase_no_COM_shift)
COM_no_shifter$mean_abs_correlation

# Calculate the mean correlation value among all proteins 
cor_all_proteins = correlations(ctrl_norm_mean, rnase_norm_mean)
cor_all_proteins$mean_abs_correlation
```

Our hypothesis was confirmed. The mean correlation between ctrl and rnase is smaller for proteins whose COM was shifted by at least two fractions. Here, it is 0.36. For proteins without a large shift of their COM, it is 0.91. The mean correlation for all proteins is 0.79. This is less than 0.92 and greater than 0.36.

Plotting the correlation values in a histogram
```{r}
par(mfrow = c(1, 2)) 

hist(
  COM_shifter$correlations,
  main = "Correlation values for COM shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "midnightblue",
  border = "white",
  xlim = c(-1, 1) 
)


hist(
  COM_no_shifter$correlations,
  main = "Correlation values for not COM shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "firebrick",
  border = "white",
  xlim = c(-1, 1)
)

par(mfrow = c(1, 1))
```
The correlation values for proteins with a shifted COM are much more located around 0. The correlation values for proteins with no COM shift show a clear tendency to high correlation values, most of them for correlation values between 0.9 and 1. 


Examine some proteins, that still show a high correlation value, despite showing a shift in their center of mass, use the plotting function. You can change n to how many plots you want to receive.
```{r}
header_plotting(COM_shifter$correlations, ctrl_COM_shift, rnase_COM_shift, n = 5, cor_threshold = 0.9, direction = "gt")
```
They show a high correlation, because the curves look very similar, only a small portion shifted.
Possible Interpretation: The proteins are partially RNA-dependent, and through RNase digestion in the experiment, they shifted to the much larger rest, that is normally not associated with RNA, and therefore not affected by RNAse digestion. Thats why blue (ctrl) and red (rnase) curve often have a joined big peak, and the blue (ctrl) curve has an additional small peak, that is RNA-dependent. 


Examine some proteins with no big COM shift, that have a very high correlation value. 
```{r}
header_plotting(COM_no_shifter$correlations, ctrl_no_COM_shift, rnase_no_COM_shift, n = 5, cor_threshold = 0.9, direction = "gt")
```
As expected, these proteins have a very similar distribution. They should not be considered RNA-dependent. But what about the proteins, that show no big COM shift, but still a low correlation value. How do they look?


Examine some proteins with no big COM shift, that have a lower correlation value
```{r}
header_plotting(COM_no_shifter$correlations, ctrl_no_COM_shift, rnase_no_COM_shift, n = 5, cor_threshold = 0.7, direction = "lt")
```
The proteins did not show a COM shift. However, their overall distribution looks different. Often, one curve shifts a bit to both sides at the same time, resulting in the effect of no COM shift.

***********************************************************************************************************
11. Second Criterion for data set purification:
The shift of the global maximum between ctrl and rnase is used as a further purification criterion
(by Julian Baureis)
***********************************************************************************************************

We use a shift in the global maximum as another criterion, to identify those proteins, that do not show a big shift in their COM, but still look very different, and therefore should exhibit a shift, when only observing their greatest/global maximum. 
Therefore, from the dataframe "ctrl/rnase_no_COM_shift", we first separate the proteins, that actually show a shift in their global maxima. 

```{r}
# Calculate the absolute difference of the position of the global maximum between ctrl and rnase 
diff_main_maxima <- abs(ctrl_no_COM_shift$global_maximum - rnase_no_COM_shift$global_maximum)

# Indices of proteins with deviation ≥ 3 fractions
deviating_main_maxima <- which(diff_main_maxima >= 3)

# Apply on the dataframes
ctrl_main_shift = ctrl_no_COM_shift[deviating_main_maxima, ]
rnase_main_shift = rnase_no_COM_shift[deviating_main_maxima, ]

# Create the complementary dataframe that contains all proteins whose main maximum does not shift by at least 2 fractions
ctrl_no_main_shift = ctrl_no_COM_shift[!rownames(ctrl_no_COM_shift) %in% rownames(ctrl_main_shift), ]
rnase_no_main_shift = rnase_no_COM_shift[!rownames(rnase_no_COM_shift) %in% rownames(rnase_main_shift), ]
```

Define the variables for the correlation values, use again the correlation function
```{r}
# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is shifted by at least 2 fractions
main_shifter = correlations(ctrl_main_shift, rnase_main_shift)
main_shifter$mean_abs_correlation

# Mean of the correlation values (ctrl vs. rnase) for those proteins whose main maximum is not shifted by at least 2 fractions
main_no_shifter = correlations(ctrl_no_main_shift, rnase_no_main_shift)
main_no_shifter$mean_abs_correlation

# Calculate the mean correlation value among all proteins, that show no shift in their COM
cor_all_proteins_no_COM = correlations(ctrl_no_COM_shift, rnase_no_COM_shift)
cor_all_proteins_no_COM$mean_abs_correlation
```
The mean correlation value for the proteins with a COM shift AND an additional shift in their global maximum is much lower with 0.61 than the mean correlation value for those proteins with no COM shift and no global maximum shift with 0.93 The correlation values are separately plotted in a histogram. 

Plotting the correlation values in a histogram, remember: both histograms are based on the proteins, that showed NO big shift in their COM
```{r}
par(mfrow = c(1, 2)) 

hist(
  main_shifter$correlations,
  main = "Corr values for main shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "midnightblue",
  border = "white",
  xlim = c(-1, 1) 
)


hist(
  main_no_shifter$correlations,
  main = "Corr values for not main shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "firebrick",
  border = "white",
  xlim = c(-1, 1)
)

par(mfrow = c(1, 1))
```

Examine some proteins of the left histogram, that additional to no big COM shift, showed a main shift, but still had a high correlation value
```{r}
header_plotting(main_shifter$correlations, ctrl_main_shift, rnase_main_shift, n = 5, cor_threshold = 0.9, direction = "gt" )
```

These proteins do not seem RNA-dependent, the curves look very similar. This is because there is no COM shift, and the existent global maximum shift usually does not lead to a change in the overall curve, for example because there are two big maxima in each ctrl and rnase, and ctrl has the global maximum at one of them, rnase has its global maximum at the other one. On paper, this is a global maximum shift, but the overall curves still look very similar. 
In order to separate these proteins, an arbitrary threshold is used, to cut off those proteins, whose curves look to similar despite a global maximum shift. 

Plot the left histogram and the arbitrary threshold. On the right side of the threshold, the respective proteins will be considered as not RNA-dependent for our analysis. 
```{r}
hist(
  main_shifter$correlations,
  main = "Corr values main shifter",
  xlab = "Correlation value",
  ylab = "Frequency",
  col = "midnightblue",
  border = "white",
  breaks = 50, 
  xlim = c(-1, 1)
)
abline(v = 0.70, lwd = 3, col = "firebrick")
```

```{r}
# Define threshold
threshold = 0.7

keep_indices = main_shifter$correlations <= threshold

# New data.frames with the proteins, that might be RNA-dependent
ctrl_under_threshold = ctrl_main_shift[keep_indices, ]
rnase_under_threshold = rnase_main_shift[keep_indices, ]

# New data.frames with the proteins, that are not RNA-dependent by arbitrary choice
ctrl_above_threshold = ctrl_main_shift[!keep_indices, ]
rnase_above_threshold = rnase_main_shift[!keep_indices, ]
```

***********************************************************************************************************
12. Combining the purified data sets back together for further analysis
(by Julian Baureis)
***********************************************************************************************************


1: ctrl_COM_shift and ctrl_under_threshold, as well as rnase_COM_shift and rnase_under_threshold are combined
--> ctrl_selected & rnase_selected

2: Test, if rownames(ctrl_selected) != rownames(rnase_selected), so that they contain the same proteins in the same order. If the result is 0, then everything worked.

3: ctrl_no_main_shift and ctrl_above_threshold, as well as rnase_no_main_shift and rnase_above_threshold are combined
--> ctrl_not_selected & rnase_not_selected

4: Test, if rownames(ctrl_not_selected) != rownames(rnase_not_selected), so that they contain the same proteins in the same order. If the result is 0, then everything worked. 

5: Check, if the combination of both data.frames would still consist of all the proteins from the start data.frames. If the result is TRUE, then everything worked. 


```{r}
#1
ctrl_selected = rbind(ctrl_COM_shift, ctrl_under_threshold)
rnase_selected = rbind(rnase_COM_shift, rnase_under_threshold)

#2
sum(rownames(ctrl_selected) != rownames(rnase_selected))

#3
ctrl_not_selected = rbind(ctrl_no_main_shift, ctrl_above_threshold)
rnase_not_selected = rbind(rnase_no_main_shift, rnase_above_threshold)

#4
sum(rownames(ctrl_not_selected) != rownames(rnase_not_selected))

#5 
dim(ctrl_not_selected)[1] + dim(ctrl_selected)[1] == dim(ctrl_norm_mean)[1]
```
Evaluation of the data purification criteria so far:
As shown, a shift in the center of mass on its own is not suitable to identify all RNA-binding proteins. Even with a totally unchanged center of mass a protein can still be RNA-dependent. However, by additionally applying the criterion of a shift in the global maximum and by cutting out those proteins, that despite change in the global maximum retained their general appearance of the distribution curve, statements on the RNA-dependency of a protein can be made more certainly. 

***********************************************************************************************************
13. Statistical Tests (t-tests)
(by Julian Baureis)
***********************************************************************************************************

We assume, that RBPs, due to their ability to interact with the negatively charged RNA, should exhibit a higher isoelectric point than neutral proteins. Here, we perform a statistical test, to assess, whether the selected proteins have a statistically higher isoelectric point than the neutral value, which is represented by the isoelectric point of 7. As a source for the values of the isoelectric points, we use the database RBP2GO. 


```{r}
# Read the two data sets from the website RBP2GO, among other things they contain protein names for RBPs and not RBPs, as well as the values for their isoelectric points
rbp_pos <- read.delim("Data/RBP2GO Table RBPs.txt", skip = 6, sep = "\t", stringsAsFactors = FALSE)
rbp_neg <- read.delim("Data/RBP2GO Table Non-RBPs.txt", skip = 6, sep = "\t", stringsAsFactors = FALSE)
```

```{r}
# Create a new dataframe, that only contains those proteins from our selected group, that were also listed in the external data rbp_pos & rbp_neg, as well as the respective isoelectric points for these proteins.

# Protein names of all selected proteins 
protein_names = rownames(ctrl_selected)

# Extract the protein names from rbp_pos and rbp_neg
rbp_pos_proteins = rbp_pos$Entry_Name
rbp_neg_proteins = rbp_neg$Entry_Name

# Get indices of the matching proteins
indices_pos = which(protein_names %in% rbp_pos_proteins)
indices_neg = which(protein_names %in% rbp_neg_proteins)

# Get the subsets for the included proteins
df_pos = ctrl_selected[indices_pos, ]
df_neg = ctrl_selected[indices_neg, ]

# Get the matching protein names
matched_pos_names = rownames(df_pos)
matched_neg_names = rownames(df_neg)

# Get the values for the isoelectric points
df_pos_pI = rbp_pos$pI[match(matched_pos_names, rbp_pos$Entry_Name)]
df_neg_pI = rbp_neg$pI[match(matched_neg_names, rbp_pos$Entry_Name)]

# Combine to new dataframes, with Protein Names and their isoelectric point 
df_pos_combined_selected = data.frame(protein = matched_pos_names, isoelectric_point = df_pos_pI)
df_neg_combined_selected = data.frame(protein = matched_neg_names, isoelectric_point = df_neg_pI)

# Merge those two dataframes together 
final_df_combined_selected = rbind(df_pos_combined_selected, df_neg_combined_selected)

# How many proteins were not listed in either rbp_pos or rbp_neg, but are still in ctrl_selected - 39
# dim(ctrl_selected)[1] - dim(final_df_combined_selected)[1]
```

First t-test is performed (One sided, right tailed)
Question: Are the isoelectric points of the selected proteins greater than the neutral value of 7?

--> H0: Random variable X (the isoelectric points) origin from a population with an expected value ≤ 7    
--> E(X) ≤ 7

--> H1: Random variable X (the isoelectric points) origin from a population with an expected value > 7     
--> E(X) > 7

```{r}
# Perform the first t-test
t.test(final_df_combined_selected$isoelectric_point, mu = 7.0, alternative = "greater")
```

We get a very high value for the test statistic (19,4), and a clearly significant p-value (p << 0.05). The H0-hypothesis is rejected, and the H1-hypothesis is statistically proven. The mean isoelectric point of the selected proteins is significantly greater than the neutral value of 7. The mean value of all isoelectric points is 8.2, which is unambiguously different from 7. 

Perform the same data set preparations again for the whole data set with all initial proteins (use ctrl_norm_mean as the data set)
```{r}
# Create a new dataframe, that only contains all initial proteins, that were also listed in the external data rbp_pos & rbp_neg, as well as their respective isoelectric points for these proteins.

# Protein names of all initial proteins 
protein_names = rownames(ctrl_norm_mean)

# Extract the protein names from rbp_pos and rbp_neg
rbp_pos_proteins = rbp_pos$Entry_Name
rbp_neg_proteins = rbp_neg$Entry_Name

# Get indices of the matching proteins
indices_pos = which(protein_names %in% rbp_pos_proteins)
indices_neg = which(protein_names %in% rbp_neg_proteins)

# Get the subsets for the included proteins
df_pos = ctrl_norm_mean[indices_pos, ]
df_neg = ctrl_norm_mean[indices_neg, ]

# Get the matching protein names
matched_pos_names = rownames(df_pos)
matched_neg_names = rownames(df_neg)

# Get the values for the isoelectric points
df_pos_pI = rbp_pos$pI[match(matched_pos_names, rbp_pos$Entry_Name)]
df_neg_pI = rbp_neg$pI[match(matched_neg_names, rbp_pos$Entry_Name)]

# Combine to new dataframes, with Protein Names and their isoelectric point 
df_pos_combined_all_proteins = data.frame(protein = matched_pos_names, isoelectric_point = df_pos_pI)
df_neg_combined_all_proteins = data.frame(protein = matched_neg_names, isoelectric_point = df_neg_pI)

# Merge those two dataframes together 
final_df_combined_all_proteins = rbind(df_pos_combined_all_proteins, df_neg_combined_all_proteins)

# How many proteins were not listed in either rbp_pos or rbp_neg, but still used in our data set - 274
# dim(ctrl_norm_mean)[1] - dim(final_df_combined_all_proteins)[1]
```


Second t-test is performed (two sided, tow-tailed)
Question: Are the isoelectric points of the not selected proteins different from 7?

--> H0: Random variable X (the isoelectric points) origin from a population with an expected value = 7    
--> E(X) = 7

--> H1: Random variable X (the isoelectric points) origin from a population with an expected value ≠ 7     
--> E(X) ≠ 7

```{r}
# Perform the second t-test
t.test(final_df_combined_all_proteins$isoelectric_point, mu = 7.0, alternative = "two.sided")
```
The value for the test-statistic is still high (6.1), and the p-value is again very small (p << 0.05). However, it should be noted, that the observed effect is not as clear as for the last test. For example, the p-value in this test is still higher compared to the previous test. The mean value of the isoelectric points in this test is 7.2, and therefore much smaller than the mean value of 8.2, we gained for the last test. 


Visualize the isoelectric points in a histogram 
```{r}
par(mfrow = c(1, 2)) 

hist(
  final_df_combined_selected$isoelectric_point,
  main = "Isoelectric points of the selected proteins",
  xlab = "Isoelectric point",
  ylab = "Frequency",
  breaks = 30,
  col = "salmon",
  border = "white",
  xlim = c(0, 14) 
)

# ablines
abline(v = 7, col = "firebrick", lwd = 4, lty = 2)

abline(v = mean(final_df_combined_selected$isoelectric_point, na.rm = TRUE),
       col = "black", lwd = 4)


hist(
  final_df_combined_all_proteins$isoelectric_point,
  main = "Isoelectric points for all proteins",
  xlab = "Isoelectric point",
  ylab = "Frequency",
  breaks = 30,
  col = "grey70",
  border = "white",
  xlim = c(0, 14)
)

# ablines 
abline(v = 7, col = "firebrick", lwd = 4, lty = 2)

abline(v = mean(final_df_combined_all_proteins$isoelectric_point, na.rm = TRUE),
       col = "black", lwd = 4)

par(mfrow = c(1, 1))
```

The selected proteins (left histogram) show a tendency to higher values for the isoelectric point. The mean value (black line) of the isoelectric points is higher in this histogram than in the other histogram, and differs more from the neutral value (red line). There are in general more values for higher isoelectric points among the selected proteins. Based on our intensity distribution criteria we managed to separate proteins we assumed are RNA-dependent. This assumption seems to be in accord with the observed behaviour of the histograms, in which our likely RNA-dependent proteins tend to show a higher isoelectric point.


***********************************************************************************************************
14. Further visualizations and interpretation of the purified data
(by Julian Baureis)
***********************************************************************************************************

Scatter plot for visualizing how the COM values behave for the selected and not_selected proteins between ctrl and rnase groups 
```{r}
par(mfrow = c(1, 2)) 

plot(
  ctrl_COM_shift$COM, rnase_COM_shift$COM,
  xlab = "COM from ctrl_selected",
  ylab = "COM from rnase_selected",
  main = "COM: selected proteins",
  pch = 19,       
  col = "salmon"    
)

points(
  ctrl_under_threshold$COM, rnase_under_threshold$COM,
  pch = 19,
  col = "firebrick"
)

abline(a = 0, b = 1, col = "black", lwd = 3, lty = 3)


plot(
  ctrl_no_main_shift$COM, rnase_no_main_shift$COM,
  xlab = "COM from ctrl_not_selected",
  ylab = "COM from rnase_not_selected",
  main = "COM: not selected proteins",
  pch = 19,       
  col = "mediumpurple1"    
)

points(
  ctrl_above_threshold$COM, rnase_above_threshold$COM,
  pch = 19,
  col = "midnightblue"
)

abline(a = 0, b = 1, col = "black", lwd = 3, lty = 3)



par(mfrow = c(1, 1)) 
```
The selected proteins consist of the two subsets ctrl/rnase_COM_shift (color salmon) and ctrl/rnase_under_threshold (color firebrick). The not selected proteins consist of the two subsets ctrl/rnase_no_main_shift (color purple) and ctrl/rnase_above_threshold (color midnightblue).
Interpretation: For the selected proteins, there is a clear trend observable when comparing the COM values of ctrl and rnase. Most of the proteins show a high COM value in the ctrl group, and at the same time, a lower COM value for the rnase group. This indicates, that during the RNase digestion in the experiment, those proteins previously bound to RNA were freed and isolated from their RNP-complexes and migrated into less dense fractions. A big part of their intensity "potential" and hence their center of mass consequently appears in smaller fractions, leading to the observed lower COM values for the rnase group.
It should be further noted, that among our selected proteins, there are also a few with no big COM shift. They are marked in red. They mostly show their COM value for ctrl and rnase in higher fractions. Per definition, these proteins have a shift in their main maximum between ctrl and rnase, and also have a correlation value < 0.7 between ctrl and rnase. The combination of these properties (main maximum shift + lower correlation value + no big COM shift) may be explained by the protein partially shifting left and right in the rnase group compared to the ctrl group. If one part of the protein distribution moves in lower fractions and the other part in higher fractions, the overall COM value is not changed that much, but there is a shift in the main maximum and a reduced correlation value, which is seen for these red proteins.




***********************************************************************************************************
15. Evaluation of the Selection Criteria
  by Luisa Wintel & Julian Baureis influenced by ChatGPT
***********************************************************************************************************

Loading Reference Datasets from RBP2GO

```{r}
# RBP2GO database contains proteome-wide datasets for RBPs from 53 studies including 105 datasets -> 22 552 identified RBP candidates across 13 species.)
# Load the RBP2GO tables: One for known RBPs (RNA-binding proteins) and one for known non-RBPs in humans.
# Skip the first 6 lines of the file (-> Not part of the datatable)
# "\t" means the values are separated by tabs.
# stringsAsFactors => FALSE means text columns are treated as text and not turned into factors. Characters remain usable.

rbp_pos <- read.delim("Data/RBP2GO Table RBPs.txt", skip = 6, sep = "\t", stringsAsFactors = FALSE)
rbp_neg <- read.delim("Data/RBP2GO Table Non-RBPs.txt", skip = 6, sep = "\t", stringsAsFactors = FALSE)
```

Classifying Proteins According to RBP2GO

```{r}
# Add a new column to the ctrl_norm_mean dataframe to store RBP2GO status
# The status "RBP" or "Non-RBP" confirms that the protein has been identified as an RBP in previous studies / datasets.
# Set status "unknown", will be replaced if possible.
ctrl_norm_mean$RBP2GO_status <- "unkown"

# If the protein name (row name) is found in the list of known RBPs (toupper makes it case-insensitive), mark it as "RBP"
ctrl_norm_mean$RBP2GO_status[
  toupper(rownames(ctrl_norm_mean)) %in% toupper(rbp_pos$Entry_Name)
] <- "RBP"
 
# If the protein is in the list of known non-RBPs, mark it as "Non-RBP"
ctrl_norm_mean$RBP2GO_status[
  toupper(rownames(ctrl_norm_mean)) %in% toupper(rbp_neg$Entry_Name)
] <- "Non-RBP"
```

Visualization of the RBP2GO Classification

```{r}
library(ggplot2)

# Count how many proteins fall into each category ("RBP", "Non-RBP", "unknown")
# table counts how often a status occured -> see "df_plot" (dataframe)
df_plot <- as.data.frame(table(ctrl_norm_mean$RBP2GO_status))
colnames(df_plot) <- c("Status", "Amount")

# Create a pie chart from these counts
ggplot(df_plot, aes(x = "", y = Amount, fill = Status)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  theme_void() +
  labs(title = "RBP2GO Classification of all ctrl_norm_mean proteins") + 
  scale_fill_manual(values = c("firebrick", "midnightblue", "darkseagreen3"))
```

Assessing Selection Accuracy for RBP2GO-Known RBPs (True Positives, False Negatives)

```{r}
# Convert all protein names to uppercase to make matching case-insensitive (-> "toupper")
# Vectors for all proteins in ctrl_norm_mean (all-prots), rbp_pos (rbp_known), ctrl_selected (selected_prots), ctrl_not_selected (not_selected_prots)
all_prots <- toupper(rownames(ctrl_norm_mean))
rbp_known <- toupper(rbp_pos$Entry_Name)
selected_prots <- toupper(rownames(ctrl_selected))
not_selected_prots <- toupper(rownames(ctrl_not_selected))

# Find RBPs (from the database) that are in our dataset (ctrl_norm_mean)
rbps_in_ctrl <- all_prots[all_prots %in% rbp_known]
#sum(rbps_in_ctrl)

# From the RBPs that are in ctrl_norm_mean and RBP2GO-known RBPs, identify the ones we selected (in ctrl_selected)
# True Positives: Selected RBP2GO-known RBPs
selected_rbps <- rbps_in_ctrl[rbps_in_ctrl %in% selected_prots]
# Identify the ones that were not selected (in ctrl_not_selected)
# False negatives: Not selected but RBP2GO-known RBPs
not_selected_rbps <- rbps_in_ctrl[rbps_in_ctrl %in% not_selected_prots]

# Create a "status label" for each RBP: "Selected" or "Not Selected"
status <- c(
  rep("Selected RBP", length(selected_rbps)),
  rep("Not Selected RBP", length(not_selected_rbps))
)

# Create a dataframe counting ("table") how many fall into each category
df_rbp_pie <- as.data.frame(table(status))
colnames(df_rbp_pie) <- c("Status", "Amount")

# Pie Chart 1: RBP2GO-known RBPs and how many we selected, not selected
# Load plotting library
library(ggplot2)

# Create a pie chart showing how many known RBPs were selected or not selected
ggplot(df_rbp_pie, aes(x = "", y = Amount, fill = Status)) +
  geom_bar(stat = "identity", width = 1) +  # Make bar chart (for pie)
  coord_polar("y") +                        # Convert bar chart to pie chart
  theme_void() +                            # Remove background, axes, etc.
  labs(title = "Known RBPs: Selected vs Not Selected") +     
  scale_fill_manual(values = c("Selected RBP" = "firebrick", 
                               "Not Selected RBP" = "salmon"))
```

Assessing False Positives in Non-RBPs (False Positives, True Negatives)

```{r}
# Convert all protein names to uppercase to make matching case-insensitive (-> "toupper")
# Vectors for all proteins in ctrl_norm_mean (all-prots), rbp_neg (non_rbp_known), ctrl_selected (selected_prots), ctrl_not_selected (not_selected_prots)
all_prots <- toupper(rownames(ctrl_norm_mean))
non_rbp_known <- toupper(rbp_neg$Entry_Name)

# Find known Non-RBPs that are in our HeLa-dataset (ctrl_norm_mean)
non_rbps_in_HeLa <- all_prots[all_prots %in% non_rbp_known]

# From the proteins that are in ctrl_norm_mean and are RBP2GO-known non-RBPs, find how many were wrongly selected (in ctrl_selected)
# False positives: selected known non_RBPs 
selected_non_rbps <- non_rbps_in_HeLa[non_rbps_in_HeLa %in% selected_prots]  
# remember: selected_prots <- toupper(rownames(ctrl_selected))

# Finds how many were correctly not selected
# True negatives: not selected non_RBPs 
not_selected_non_rbps <- non_rbps_in_HeLa[non_rbps_in_HeLa %in% not_selected_prots] 
# remember: not_selected_prots <- toupper(rownames(ctrl_not_selected))

# Create "status labels"
status_non_rbps <- c(
  rep("Selected Non-RBP", length(selected_non_rbps)),         # "Wrongly selected"
  rep("Not Selected Non-RBP", length(not_selected_non_rbps))  # "Correctly ignored"
)

# Create dataframe and calculate percentages
df_non_rbp_pie <- as.data.frame(table(status_non_rbps))
colnames(df_non_rbp_pie) <- c("Status", "Amount")
# df_non_rbp_pie$Percentage <- round((df_non_rbp_pie$Amount / sum(df_non_rbp_pie$Amount)) * 100, 1)
# print(df_non_rbp_pie)


# Pie Chart 2: RBP2GO-known RBPs and how many we selected, not selected
library(ggplot2)

# Create a pie chart showing how many known Non-RBPs were selected or not selected
ggplot(df_non_rbp_pie, aes(x = "", y = Amount, fill = Status)) +
  geom_bar(stat = "identity", width = 1) +  # Make bar chart (for pie) 
  coord_polar("y") +                        # Convert bar chart to pie chart
  theme_void() +                            # Remove background, axes, etc.
  labs(title = "Known Non-RBPs: Selected vs Not Selected") +
  scale_fill_manual(values = c("Selected Non-RBP" = "mediumpurple1", 
                               "Not Selected Non-RBP" = "midnightblue"))
```

***********************************************************************************************************
16. Principle Component Analysis (PCA)
  by Benjamin Nicklas influenced by ChatGPT
***********************************************************************************************************

```{r}
# Keep only numerical columns
pca_ctrl_numeric <- ctrl_selected[, sapply(ctrl_selected, is.numeric)][, 1:25]
pca_rnase_numeric <- rnase_selected[, sapply(rnase_selected, is.numeric)][, 1:25]

# Remove rows with NAs
pca_ctrl_clean <- pca_ctrl_numeric[complete.cases(pca_ctrl_numeric), ]
pca_rnase_clean <- pca_rnase_numeric[complete.cases(pca_rnase_numeric), ]

pca_result_ctrl <- prcomp(pca_ctrl_clean, center = TRUE, scale. = TRUE, )
pca_result_rnase <- prcomp(pca_rnase_clean, center = TRUE, scale. = TRUE)
```

```{r}
# Keep only numerical columns
pca_ctrl_numeric_not_selected <- ctrl_not_selected[,sapply(ctrl_not_selected, is.numeric)][, 1:25]
pca_rnase_numeric_not_selected <- rnase_not_selected[,sapply(rnase_not_selected, is.numeric)][, 1:25]

# Remove rows with NAs
pca_ctrl_clean_not_selected <- pca_ctrl_numeric_not_selected[complete.cases(pca_ctrl_numeric_not_selected), ]
pca_rnase_clean_not_selected <- pca_rnase_numeric_not_selected[complete.cases(pca_rnase_numeric_not_selected), ]

pca_result_ctrl_not_selected <- prcomp(pca_ctrl_clean_not_selected, center = TRUE, scale. = TRUE, )
pca_result_rnase_not_selected <- prcomp(pca_rnase_clean_not_selected, center = TRUE, scale. = TRUE)
```

```{r}
# Check which PCs have the most variance
summary(pca_result_ctrl)
summary(pca_result_rnase)

summary(pca_result_ctrl_not_selected)
summary(pca_result_rnase_not_selected)
```

```{r}
#plot PC1 with PC2
plot(pca_result_ctrl$x[,1:2], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL (SHIFT)")

plot(pca_result_rnase$x[,1:2], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE (SHIFT)")

#plot PC1 with PC3
plot(pca_result_ctrl$x[,c(1, 3)], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL (SHIFT)")

plot(pca_result_rnase$x[,c(1, 3)], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE (SHIFT)")


#plot PC2 with PC3
plot(pca_result_ctrl$x[,2:3], col = "midnightblue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL (SHIFT)")

plot(pca_result_rnase$x[,2:3], col = "midnightblue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE (SHIFT)")



# Simple 2D PCA-Plot
plot(pca_result_ctrl_not_selected$x[,1:2], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,1:2], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC2", main = "PCA: PC1 vs PC2 RNASE (NO SHIFT)")

#plot PC1 with PC3
plot(pca_result_ctrl_not_selected$x[,c(1, 3)], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,c(1, 3)], col = "midnightblue", pch = 16,
     xlab = "PC1", ylab = "PC3", main = "PCA: PC1 vs PC3 RNASE (NO SHIFT)")


#plot PC2 with PC3
plot(pca_result_ctrl_not_selected$x[,2:3], col = "midnightblue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 CTRL (NO SHIFT)")

plot(pca_result_rnase_not_selected$x[,2:3], col = "midnightblue", pch = 16,
     xlab = "PC2", ylab = "PC3", main = "PCA: PC2 vs PC3 RNASE (NO SHIFT)")
```

```{r}
#Recognize centers for k-means clustering -> 3 centers
plot(pca_result_ctrl, type = "l", main = "Elbow-Plot CTRL (SHIFT)")
plot(pca_result_rnase, type = "l", main = "Elbow-Plot RNASE (SHIFT)")

#Recognize centers for k-means clustering -> 2 centers
plot(pca_result_ctrl_not_selected, type = "l", main = "Elbow-Plot CTRL (NO SHIFT)")
plot(pca_result_rnase_not_selected, type = "l", main = "Elbow-Plot RNASE (NO SHIFT)")
```

```{r}
pca_ctrl_pc1_pc2 <- as.data.frame(pca_result_ctrl$x[, 1:2])
pca_ctrl_pc1_pc3 <- as.data.frame(pca_result_ctrl$x[, c(1,3)])
pca_ctrl_pc2_pc3 <- as.data.frame(pca_result_ctrl$x[, 2:3])

pca_rnase_pc1_pc2 <- as.data.frame(pca_result_rnase$x[, 1:2])
pca_rnase_pc1_pc3 <- as.data.frame(pca_result_rnase$x[, c(1,3)])
pca_rnase_pc2_pc3 <- as.data.frame(pca_result_rnase$x[, 2:3])
```

```{r}
pca_ctrl_pc1_pc2_not_selected <- as.data.frame(pca_result_ctrl_not_selected$x[, 1:2])
pca_ctrl_pc1_pc3_not_selected <- as.data.frame(pca_result_ctrl_not_selected$x[, c(1,3)])
pca_ctrl_pc2_pc3_not_selected <- as.data.frame(pca_result_ctrl_not_selected$x[, 2:3])

pca_rnase_pc1_pc2_not_selected <- as.data.frame(pca_result_rnase_not_selected$x[, 1:2])
pca_rnase_pc1_pc3_not_selected <- as.data.frame(pca_result_rnase_not_selected$x[, c(1,3)])
pca_rnase_pc2_pc3_not_selected <- as.data.frame(pca_result_rnase_not_selected$x[, 2:3])
```

```{r}
library(factoextra)

fviz_nbclust(pca_ctrl_pc1_pc2, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc1_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc2_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC2/PC3") +
  theme_minimal()

fviz_nbclust(pca_rnase_pc1_pc2, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC3") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc2_pc3, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC2/PC3") +
  theme_minimal()



fviz_nbclust(pca_ctrl_pc1_pc2_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc1_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_ctrl_pc2_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode CTRL PC2/PC3") +
  theme_minimal()

fviz_nbclust(pca_rnase_pc1_pc2_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC2") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc1_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC1/PC3") +
  theme_minimal()
fviz_nbclust(pca_rnase_pc2_pc3_not_selected, kmeans, method = "silhouette") +
  labs(title = "Silhouette-Methode RNASE PC2/PC3") +
  theme_minimal()
```

***********************************************************************************************************
17. K-means clustering 
  by Benjamin Nicklas influenced by ChatGPT
***********************************************************************************************************

```{r}
#kmeans is executed with 3 centers --> see elbow-Plot and silhouette plot
km_result_ctrl_pc1_pc2<- kmeans(pca_ctrl_pc1_pc2, centers = 3)
km_result_ctrl_pc1_pc3<- kmeans(pca_ctrl_pc1_pc3, centers = 3)
km_result_ctrl_pc2_pc3<- kmeans(pca_ctrl_pc2_pc3, centers = 3)

km_result_rnase_pc1_pc2<- kmeans(pca_rnase_pc1_pc2, centers = 3)
km_result_rnase_pc1_pc3<- kmeans(pca_rnase_pc1_pc3, centers = 3)
km_result_rnase_pc2_pc3<- kmeans(pca_rnase_pc2_pc3, centers = 3)
```

```{r}
#kmeans is executed with 2 centers
km_result_ctrl_pc1_pc2_not_selected<- kmeans(pca_ctrl_pc1_pc2_not_selected, centers = 3)
km_result_ctrl_pc1_pc3_not_selected<- kmeans(pca_ctrl_pc1_pc3_not_selected, centers = 3)
km_result_ctrl_pc2_pc3_not_selected<- kmeans(pca_ctrl_pc2_pc3_not_selected, centers = 3)

km_result_rnase_pc1_pc2_not_selected<- kmeans(pca_rnase_pc1_pc2_not_selected, centers = 3)
km_result_rnase_pc1_pc3_not_selected<- kmeans(pca_rnase_pc1_pc3_not_selected, centers = 3)
km_result_rnase_pc2_pc3_not_selected<- kmeans(pca_rnase_pc2_pc3_not_selected, centers = 3)
```

```{r}
library(factoextra)

# pca_df contains the data, e.g. PC1 and PC2
fviz_cluster(km_result_ctrl_pc1_pc2, data = pca_ctrl_pc1_pc2,
             geom = "point", ellipse.type = "norm", stand = FALSE, 
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 CTRL (SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc2, data = pca_rnase_pc1_pc2,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("violetred4", "firebrick3", "midnightblue"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 RNASE (SHIFT)")

fviz_cluster(km_result_ctrl_pc1_pc3, data = pca_ctrl_pc1_pc3,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 CTRL (SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc3, data = pca_rnase_pc1_pc3,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 RNASE (SHIFT)")

fviz_cluster(km_result_ctrl_pc2_pc3, data = pca_ctrl_pc2_pc3,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 CTRL (SHIFT)")
fviz_cluster(km_result_rnase_pc2_pc3, data = pca_rnase_pc2_pc3,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 RNASE (SHIFT)")



# pca_df contains the data, e.g. PC1 and PC2
fviz_cluster(km_result_ctrl_pc1_pc2_not_selected, data = pca_ctrl_pc1_pc2_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 CTRL (NO SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc2_not_selected, data = pca_rnase_pc1_pc2_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("violetred4", "firebrick3", "midnightblue"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC2 RNASE (NO SHIFT)")

fviz_cluster(km_result_ctrl_pc1_pc3_not_selected, data = pca_ctrl_pc1_pc3_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 CTRL (NO SHIFT)")
fviz_cluster(km_result_rnase_pc1_pc3_not_selected, data = pca_rnase_pc1_pc3_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC1 vs PC3 RNASE (NO SHIFT)")

fviz_cluster(km_result_ctrl_pc2_pc3_not_selected, data = pca_ctrl_pc2_pc3_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 CTRL (NO SHIFT)")
fviz_cluster(km_result_rnase_pc2_pc3_not_selected, data = pca_rnase_pc2_pc3_not_selected,
             geom = "point", ellipse.type = "norm", stand = FALSE,
             palette = c("midnightblue", "firebrick3", "violetred4"), ggtheme = theme_minimal(),
             main = "k-Means Cluster: PC2 vs PC3 RNASE (SHIFT)")
```

**************************************************************************************************************
18. Linear regression analysis
  by Julia Ferdin influenced by ChatGPT
**************************************************************************************************************

```{r}
#For ctrl selected vs rnase selected 
#Rename relevant variables to avoid PC name redundance later on
ctrl_1 <- pca_ctrl_pc1_pc2$PC1
ctrl_2 <- pca_ctrl_pc1_pc2$PC2
ctrl_3 <- pca_ctrl_pc1_pc3$PC3

rnase_1 <- pca_rnase_pc1_pc2$PC1
rnase_2 <- pca_rnase_pc1_pc2$PC2
rnase_3 <- pca_rnase_pc1_pc3$PC3


#Generates plot with PCA datapoints and draws a trendline through it
plot(ctrl_1,rnase_1,pch=20,col='blue', xlab='Ctrl selected PC1',ylab='Rnase selected PC1', main = "Ctrl selected PC1 vs Rnase selected PC1");abline(0,1,col='red')
plot(ctrl_1,rnase_2,pch=20,col='blue', xlab='Ctrl selected PC1',ylab='Rnase selected PC2', main = "Ctrl selected PC1 vs Rnase selected PC2");abline(0,1,col='red')
plot(ctrl_1,rnase_3,pch=20,col='blue', xlab='Ctrl selected PC1',ylab='Rnase selected PC3', main = "Ctrl selected PC1 vs Rnase selected PC3");abline(0,1,col='red')

plot(ctrl_2,rnase_1,pch=20,col='blue', xlab='Ctrl selected PC2',ylab='Rnase selected PC1', main = "Ctrl selected PC2 vs Rnase selected PC1");abline(0,1,col='red')
plot(ctrl_2,rnase_2,pch=20,col='blue', xlab='Ctrl selected PC2',ylab='Rnase selected PC2', main = "Ctrl selected PC2 vs Rnase selected PC2");abline(0,1,col='red')
plot(ctrl_2,rnase_3,pch=20,col='blue', xlab='Ctrl selected PC2',ylab='Rnase selected PC3', main = "Ctrl selected PC2 vs Rnase selected PC3");abline(0,1,col='red')

plot(ctrl_3,rnase_1,pch=20,col='blue', xlab='Ctrl selected PC3',ylab='Rnase selected PC1', main = "Ctrl selected PC3 vs Rnase selected PC1");abline(0,1,col='red')
plot(ctrl_3,rnase_2,pch=20,col='blue', xlab='Ctrl selected PC3',ylab='Rnase selected PC2', main = "Ctrl selected PC3 vs Rnase selected PC2");abline(0,1,col='red')
plot(ctrl_3,rnase_3,pch=20,col='blue', xlab='Ctrl selected PC3',ylab='Rnase selected PC3', main = "Ctrl selected PC3 vs Rnase selected PC3");abline(0,1,col='red')


#Defines a target variable, so what should be predicted by the regression analysis
target_selected <- ctrl_selected$global_maximum


#Builds matrix for regression analysis from target variable with two PCA components
df_regression_selected_11 <- cbind(target = target_selected ,
                      ctrl_1, rnase_1)
df_regression_selected_12 <- cbind(target = target_selected ,
                       ctrl_1, rnase_2)
df_regression_selected_13 <- cbind(target = target_selected ,
                       ctrl_1, rnase_3)

df_regression_selected_21 <- cbind(target = target_selected ,
                       ctrl_2, rnase_1)
df_regression_selected_22 <- cbind(target =target_selected,
                       ctrl_2, rnase_2)
df_regression_selected_23 <- cbind(target = target_selected ,
                       ctrl_2, rnase_3)

df_regression_selected_31 <- cbind(target = target_selected ,
                       ctrl_3, rnase_1)
df_regression_selected_32 <- cbind(target =target_selected ,
                       ctrl_3, rnase_2)
df_regression_selected_33 <- cbind(target = target_selected ,
                       ctrl_3, rnase_3)


#Make matrix a data frame
df_regression_selected_11 <- as.data.frame(df_regression_selected_11)
df_regression_selected_12 <- as.data.frame(df_regression_selected_12)
df_regression_selected_13 <- as.data.frame(df_regression_selected_13)

df_regression_selected_21 <- as.data.frame(df_regression_selected_21)
df_regression_selected_22 <- as.data.frame(df_regression_selected_22)
df_regression_selected_23 <- as.data.frame(df_regression_selected_23)

df_regression_selected_31 <- as.data.frame(df_regression_selected_31)
df_regression_selected_32 <- as.data.frame(df_regression_selected_32)
df_regression_selected_33 <- as.data.frame(df_regression_selected_33)

#Multiple linear regression analysis
model_selected_pc1_1<- lm(target ~ ctrl_1 + rnase_1, data = df_regression_selected_11)
model_selected_pc1_2<- lm(target ~ctrl_1 + rnase_2, data = df_regression_selected_12)
model_selected_pc1_3<- lm(target ~ ctrl_1 + rnase_3, data = df_regression_selected_13)

model_selected_pc2_1<- lm(target ~ ctrl_2 + rnase_1, data = df_regression_selected_21)
model_selected_pc2_2<- lm(target ~ ctrl_2 + rnase_2, data = df_regression_selected_22)
model_selected_pc2_3<- lm(target ~ ctrl_2 + rnase_3, data = df_regression_selected_23)

model_selected_pc3_1<- lm(target ~ ctrl_3 + rnase_1, data = df_regression_selected_31)
model_selected_pc3_2<- lm(target ~ ctrl_3 + rnase_2, data = df_regression_selected_32)
model_selected_pc3_3<- lm(target ~ ctrl_3 + rnase_3, data = df_regression_selected_33)

#Show results/summary
summary(model_selected_pc1_1)
summary(model_selected_pc1_2)
summary(model_selected_pc1_3)

summary(model_selected_pc2_1)
summary(model_selected_pc2_2)
summary(model_selected_pc2_3)

summary(model_selected_pc3_1)
summary(model_selected_pc3_2)
summary(model_selected_pc3_3)
```

```{r}
#For ctrl not-selected vs rnase not-selected
#Rename relevant variables to avoid PC name redundance later on
ctrl_ns_1 <- pca_ctrl_pc1_pc2_not_selected$PC1
ctrl_ns_2 <- pca_ctrl_pc1_pc2_not_selected$PC2
ctrl_ns_3 <- pca_ctrl_pc1_pc3_not_selected$PC3

rnase_ns_1 <- pca_rnase_pc1_pc2_not_selected$PC1
rnase_ns_2 <- pca_rnase_pc1_pc2_not_selected$PC2
rnase_ns_3 <- pca_rnase_pc1_pc3_not_selected$PC3


#Generates plot with PCA datapoints and draws a trendline through it
plot(ctrl_ns_1,rnase_ns_1,pch=20,col='blue', xlab='Ctrl not-selected PC1',ylab='Rnase not-selected PC1', main = "Ctrl not-selected PC1 vs Rnase not-selected PC1");abline(0,1,col='red')
plot(ctrl_ns_1,rnase_ns_2,pch=20,col='blue', xlab='Ctrl not-selected PC1',ylab='Rnase not-selected PC2', main = "Ctrl not-selected PC1 vs Rnase not-selected PC2");abline(0,1,col='red')
plot(ctrl_ns_1,rnase_ns_3,pch=20,col='blue', xlab='Ctrl not-selected PC1',ylab='Rnase not-selected PC3', main = "Ctrl not-selected PC1 vs Rnase not-selected PC3");abline(0,1,col='red')

plot(ctrl_ns_2,rnase_ns_1,pch=20,col='blue', xlab='Ctrl not-selected PC2',ylab='Rnase not-selected PC1', main = "Ctrl not-selected PC2 vs Rnase not-selected PC1");abline(0,1,col='red')
plot(ctrl_ns_2,rnase_ns_2,pch=20,col='blue', xlab='Ctrl not-selected PC2',ylab='Rnase not-selected PC2', main = "Ctrl not-selected PC2 vs Rnase not-selected PC2");abline(0,1,col='red')
plot(ctrl_ns_2,rnase_ns_3,pch=20,col='blue', xlab='Ctrl not-selected PC2',ylab='Rnase not-selected PC3', main = "Ctrl not-selected PC2 vs Rnase not-selected PC3");abline(0,1,col='red')

plot(ctrl_ns_3,rnase_ns_1,pch=20,col='blue', xlab='Ctrl not-selected PC3',ylab='Rnase not-selected PC1', main = "Ctrl not-selected PC3 vs Rnase not-selected PC1");abline(0,1,col='red')
plot(ctrl_ns_3,rnase_ns_2,pch=20,col='blue', xlab='Ctrl not-selected PC3',ylab='Rnase not-selected PC2', main = "Ctrl not-selected PC3 vs Rnase not-selected PC2");abline(0,1,col='red')
plot(ctrl_ns_3,rnase_ns_3,pch=20,col='blue', xlab='Ctrl not-selected PC3',ylab='Rnase not-selected PC3', main = "Ctrl not-selected PC3 vs Rnase not-selected PC3");abline(0,1,col='red')


#Defines a target variable, so what should be predicted by the regression analysis
target_not_selected <- ctrl_selected$global_maximum


#Builds matrix for regression analysis from target variable with two PCA components
df_regression_not_selected_11 <- cbind(target = target_not_selected ,
                      ctrl_ns_1, rnase_ns_1)
df_regression_not_selected_12 <- cbind(target = target_not_selected ,
                       ctrl_ns_1, rnase_ns_2)
df_regression_not_selected_13 <- cbind(target = target_not_selected ,
                       ctrl_ns_1, rnase_ns_3)

df_regression_not_selected_21 <- cbind(target = target_not_selected ,
                       ctrl_ns_2, rnase_ns_1)
df_regression_not_selected_22 <- cbind(target =target_not_selected,
                       ctrl_ns_2, rnase_ns_2)
df_regression_not_selected_23 <- cbind(target = target_not_selected ,
                       ctrl_ns_2, rnase_ns_3)

df_regression_not_selected_31 <- cbind(target = target_not_selected ,
                       ctrl_ns_3, rnase_ns_1)
df_regression_not_selected_32 <- cbind(target =target_not_selected ,
                       ctrl_ns_3, rnase_ns_2)
df_regression_not_selected_33 <- cbind(target = target_not_selected ,
                       ctrl_ns_3, rnase_ns_3)


#Make matrix a data frame
df_regression_not_selected_11 <- as.data.frame(df_regression_not_selected_11)
df_regression_not_selected_12 <- as.data.frame(df_regression_not_selected_12)
df_regression_not_selected_13 <- as.data.frame(df_regression_not_selected_13)

df_regression_not_selected_21 <- as.data.frame(df_regression_not_selected_21)
df_regression_not_selected_22 <- as.data.frame(df_regression_not_selected_22)
df_regression_not_selected_23 <- as.data.frame(df_regression_not_selected_23)

df_regression_not_selected_31 <- as.data.frame(df_regression_not_selected_31)
df_regression_not_selected_32 <- as.data.frame(df_regression_not_selected_32)
df_regression_not_selected_33 <- as.data.frame(df_regression_not_selected_33)

#Multiple linear regression analysis
model_not_selected_pc1_1<- lm(target ~ ctrl_ns_1 + rnase_ns_1, data = df_regression_not_selected_11)
model_not_selected_pc1_2<- lm(target ~ctrl_ns_1 + rnase_ns_2, data = df_regression_not_selected_12)
model_not_selected_pc1_3<- lm(target ~ ctrl_ns_1 + rnase_ns_3, data = df_regression_not_selected_13)

model_not_selected_pc2_1<- lm(target ~ ctrl_ns_2 + rnase_ns_1, data = df_regression_not_selected_21)
model_not_selected_pc2_2<- lm(target ~ ctrl_ns_2 + rnase_ns_2, data = df_regression_not_selected_22)
model_not_selected_pc2_3<- lm(target ~ ctrl_ns_2 + rnase_ns_3, data = df_regression_not_selected_23)

model_not_selected_pc3_1<- lm(target ~ ctrl_ns_3 + rnase_ns_1, data = df_regression_not_selected_31)
model_not_selected_pc3_2<- lm(target ~ ctrl_ns_3 + rnase_ns_2, data = df_regression_not_selected_32)
model_not_selected_pc3_3<- lm(target ~ ctrl_ns_3 + rnase_ns_3, data = df_regression_not_selected_33)

#Show results/summary
summary(model_not_selected_pc1_1)
summary(model_not_selected_pc1_2)
summary(model_not_selected_pc1_3)

summary(model_not_selected_pc2_1)
summary(model_not_selected_pc2_2)
summary(model_not_selected_pc2_3)

summary(model_not_selected_pc3_1)
summary(model_not_selected_pc3_2)
summary(model_not_selected_pc3_3)


```
**************************************************************************************************************

Conclusion: 
The regression analyses for the selected proteins describe the target variable (ctrl_selected$global_maximum) well.
The regression analyses for the not-selected proteins describe its own target variable (ctrl_not_selected$global_maximum) also very well, in comparison to the selected proteins sometimes even better, as there are more proteins used in the model. However, the analysis for the not-selected proteins shows a bad fit for the selected target variable (ctrl_selected$global_maximum). This proves, that there is a difference between the selected and not-selected proteins, and therefore, that the selection criteria worked.

**************************************************************************************************************
**************************************************************************************************************
